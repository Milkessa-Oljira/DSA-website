<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Mastery - Python Edition</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #06b6d4;
            --accent: #f59e0b;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --dark: #0f172a;
            --gray-900: #111827;
            --gray-800: #1f2937;
            --gray-700: #374151;
            --gray-600: #4b5563;
            --gray-500: #6b7280;
            --gray-400: #9ca3af;
            --gray-300: #d1d5db;
            --gray-200: #e5e7eb;
            --gray-100: #f3f4f6;
            --white: #ffffff;
            --gradient-1: linear-gradient(135deg, #6366f1 0%, #06b6d4 100%);
            --gradient-2: linear-gradient(135deg, #f59e0b 0%, #ef4444 100%);
            --gradient-3: linear-gradient(135deg, #10b981 0%, #06b6d4 100%);
            --glass: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background: var(--dark);
            color: var(--white);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* Animated Background */
        .bg-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: var(--dark);
        }

        .bg-animation::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle at 20% 80%, var(--primary) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, var(--secondary) 0%, transparent 50%),
                        radial-gradient(circle at 40% 40%, var(--accent) 0%, transparent 50%);
            animation: float 20s ease-in-out infinite;
            opacity: 0.1;
        }

        @keyframes float {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
            33% { transform: translate(-30%, -60%) rotate(120deg); }
            66% { transform: translate(-70%, -40%) rotate(240deg); }
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 1000;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--glass-border);
            transition: all 0.3s ease;
        }

        .header.scrolled {
            background: rgba(15, 23, 42, 0.95);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 800;
            background: var(--gradient-1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            list-style: none;
        }

        .nav-links a {
            color: var(--gray-300);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
            position: relative;
        }

        .nav-links a:hover {
            color: var(--primary);
            transform: translateY(-2px);
        }

        .nav-links a::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 0;
            height: 2px;
            background: var(--gradient-1);
            transition: width 0.3s ease;
        }

        .nav-links a:hover::after {
            width: 100%;
        }

        .mobile-menu-btn {
            display: none;
            background: none;
            border: none;
            color: var(--white);
            font-size: 1.5rem;
            cursor: pointer;
        }

        /* Main Content */
        .main-content {
            display: flex;
            min-height: 100vh;
            padding-top: 80px;
        }

        /* Sidebar */
        .sidebar {
            width: 350px;
            background: rgba(31, 41, 55, 0.8);
            backdrop-filter: blur(20px);
            border-right: 1px solid var(--glass-border);
            padding: 2rem 0;
            overflow-y: auto;
            height: calc(100vh - 80px);
            position: sticky;
            top: 80px;
        }

        .sidebar-header {
            padding: 0 2rem 2rem;
            border-bottom: 1px solid var(--gray-700);
            margin-bottom: 2rem;
        }

        .sidebar-title {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: var(--gradient-1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--gray-700);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 1rem;
        }

        .progress-fill {
            height: 100%;
            background: var(--gradient-1);
            border-radius: 3px;
            width: 15%;
            transition: width 0.5s ease;
        }

        .topic-list {
            list-style: none;
        }

        .topic-item {
            margin-bottom: 0.5rem;
        }

        .topic-link {
            display: flex;
            align-items: center;
            padding: 1rem 2rem;
            color: var(--gray-300);
            text-decoration: none;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
            position: relative;
        }

        .topic-link:hover {
            background: rgba(99, 102, 241, 0.1);
            color: var(--white);
            border-left-color: var(--primary);
            transform: translateX(5px);
        }

        .topic-link.active {
            background: rgba(99, 102, 241, 0.2);
            color: var(--white);
            border-left-color: var(--primary);
        }

        .topic-icon {
            margin-right: 1rem;
            font-size: 1.1rem;
            width: 20px;
            text-align: center;
        }

        .topic-number {
            background: var(--gray-600);
            color: var(--white);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            margin-right: 1rem;
            transition: all 0.3s ease;
        }

        .topic-link:hover .topic-number,
        .topic-link.active .topic-number {
            background: var(--primary);
        }

        /* Content Area */
        .content-area {
            flex: 1;
            padding: 2rem;
            max-width: calc(100% - 350px);
        }

        .content-header {
            margin-bottom: 3rem;
            text-align: center;
        }

        .content-title {
            font-size: 3rem;
            font-weight: 800;
            margin-bottom: 1rem;
            background: var(--gradient-1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: slideInUp 1s ease;
        }

        .content-subtitle {
            font-size: 1.2rem;
            color: var(--gray-400);
            max-width: 600px;
            margin: 0 auto;
            animation: slideInUp 1s ease 0.2s both;
        }

        .topic-content {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .topic-content.active {
            display: block;
        }

        .section {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 2rem;
            margin-bottom: 2rem;
            transition: all 0.3s ease;
        }

        .section:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        }

        .section-title {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--primary);
        }

        .section-content {
            color: var(--gray-300);
            line-height: 1.8;
        }

        /* Code Blocks */
        .code-block {
            background: var(--gray-800);
            border: 1px solid var(--gray-700);
            border-radius: 12px;
            margin: 1.5rem 0;
            overflow: hidden;
        }

        .code-header {
            background: var(--gray-700);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--gray-600);
        }

        .code-language {
            color: var(--gray-300);
            font-size: 0.9rem;
            font-weight: 600;
        }

        .copy-btn {
            background: var(--primary);
            color: var(--white);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .copy-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }

        /* Interactive Components */
        .interactive-demo {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 2rem;
            margin: 2rem 0;
        }

        .demo-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .btn {
            background: var(--gradient-1);
            color: var(--white);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(99, 102, 241, 0.3);
        }

        .btn:active {
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--gradient-3);
        }

        .btn-warning {
            background: var(--gradient-2);
        }

        /* Visualization Area */
        .visualization {
            background: var(--gray-800);
            border: 2px dashed var(--gray-600);
            border-radius: 15px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 2rem 0;
            position: relative;
            overflow: hidden;
        }

        .viz-placeholder {
            color: var(--gray-500);
            font-size: 1.1rem;
            text-align: center;
        }

        /* Complexity Analysis */
        .complexity-table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
            background: var(--glass);
            backdrop-filter: blur(20px);
            border-radius: 15px;
            overflow: hidden;
        }

        .complexity-table th,
        .complexity-table td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid var(--gray-700);
        }

        .complexity-table th {
            background: var(--gray-700);
            font-weight: 700;
            color: var(--white);
        }

        .complexity-table td {
            color: var(--gray-300);
        }

        .complexity-good {
            color: var(--success);
            font-weight: 600;
        }

        .complexity-average {
            color: var(--warning);
            font-weight: 600;
        }

        .complexity-bad {
            color: var(--error);
            font-weight: 600;
        }

        /* Quiz Section */
        .quiz-section {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 2rem;
            margin: 2rem 0;
        }

        .quiz-question {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: var(--white);
        }

        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .quiz-option {
            background: var(--gray-700);
            padding: 1rem 1.5rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .quiz-option:hover {
            background: var(--gray-600);
            transform: translateX(5px);
        }

        .quiz-option.selected {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.2);
        }

        .quiz-option.correct {
            border-color: var(--success);
            background: rgba(16, 185, 129, 0.2);
        }

        .quiz-option.incorrect {
            border-color: var(--error);
            background: rgba(239, 68, 68, 0.2);
        }

        /* Animations */
        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading {
            animation: pulse 2s infinite;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .sidebar {
                width: 300px;
            }
            
            .content-area {
                max-width: calc(100% - 300px);
            }
        }

        @media (max-width: 768px) {
            .nav-links {
                display: none;
            }
            
            .mobile-menu-btn {
                display: block;
            }
            
            .main-content {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                position: static;
            }
            
            .content-area {
                max-width: 100%;
                padding: 1rem;
            }
            
            .content-title {
                font-size: 2rem;
            }
            
            .nav-container {
                padding: 1rem;
            }
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--gray-800);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--gray-600);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--gray-500);
        }

        /* Welcome Screen */
        .welcome-screen {
            text-align: center;
            padding: 4rem 2rem;
        }

        .welcome-title {
            font-size: 4rem;
            font-weight: 900;
            margin-bottom: 2rem;
            background: var(--gradient-1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: slideInUp 1s ease;
        }

        .welcome-subtitle {
            font-size: 1.5rem;
            color: var(--gray-400);
            margin-bottom: 3rem;
            animation: slideInUp 1s ease 0.2s both;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin: 4rem 0;
        }

        .feature-card {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 2rem;
            text-align: center;
            transition: all 0.3s ease;
        }

        .feature-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .feature-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            background: var(--gradient-1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .feature-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--white);
        }

        .feature-description {
            color: var(--gray-400);
            line-height: 1.6;
        }
        
        .growth-function {
            padding: 0.5rem;
            margin: 0.25rem;
            border-radius: 4px;
            color: var(--white);
            font-weight: bold;
            text-align: center;
            min-width: 80px;
        }

        .complexity-o1 { background: #10b981; }
        .complexity-logn { background: #3b82f6; }
        .complexity-n { background: #8b5cf6; }
        .complexity-nlogn { background: #f59e0b; }
        .complexity-n2 { background: #ef4444; }
        .complexity-n3 { background: #dc2626; }
        .complexity-2n { background: #7c2d12; }
        .complexity-nfact { background: #450a0a; }

        .complexity-analysis {
            background: var(--gray-800);
            border-radius: 8px;
            padding: 1rem;
            margin: 0.5rem 0;
        }

        .code-snippet {
            background: var(--gray-900);
            border: 1px solid var(--gray-700);
            border-radius: 6px;
            padding: 1rem;
            margin: 0.5rem 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }

        .complexity-steps {
            background: var(--gray-800);
            padding: 1rem;
            border-radius: 6px;
            border-left: 4px solid var(--primary);
        }

        .step {
            margin: 0.5rem 0;
            padding: 0.5rem;
            background: var(--gray-700);
            border-radius: 4px;
        }

        .step-number {
            color: var(--primary);
            font-weight: bold;
        }

        #growthChart {
            border-radius: 4px;
        }

        .growth-table {
            overflow-x: auto;
            margin-top: 1rem;
        }

        .growth-table table {
            width: 100%;
            border-collapse: collapse;
            background: var(--gray-800);
            border-radius: 8px;
            overflow: hidden;
        }

        .growth-table th,
        .growth-table td {
            padding: 0.75rem;
            text-align: center;
            border-bottom: 1px solid var(--gray-700);
        }

        .growth-table th {
            background: var(--gray-700);
            font-weight: bold;
            color: var(--primary);
        }

        .growth-table tr:hover {
            background: var(--gray-700);
        }

        .notation-comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .notation-card {
            background: var(--gray-800);
            padding: 1rem;
            border-radius: 8px;
            border: 2px solid var(--gray-700);
            text-align: center;
        }

        .notation-symbol {
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }

    </style>
</head>
<body>
    <div class="bg-animation"></div>
    
    <header class="header" id="header">
        <div class="nav-container">
            <div class="logo">
                <i class="fas fa-code"></i> DSA Mastery
            </div>
            <nav>
                <ul class="nav-links">
                    <li><a href="#home">Home</a></li>
                    <li><a href="#topics">Topics</a></li>
                    <li><a href="#practice">Practice</a></li>
                    <li><a href="#progress">Progress</a></li>
                </ul>
            </nav>
            <button class="mobile-menu-btn" id="mobileMenuBtn">
                <i class="fas fa-bars"></i>
            </button>
        </div>
    </header>

    <main class="main-content">
        <aside class="sidebar">
            <div class="sidebar-header">
                <h2 class="sidebar-title">Course Progress</h2>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p style="color: var(--gray-400); margin-top: 0.5rem; font-size: 0.9rem;">
                    <span id="progressText">0/24 topics completed</span>
                </p>
            </div>
            
            <ul class="topic-list" id="topicList">
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="data-types">
                        <div class="topic-number">1</div>
                        <i class="topic-icon fas fa-database"></i>
                        Data Types
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="adts">
                        <div class="topic-number">2</div>
                        <i class="topic-icon fas fa-cube"></i>
                        Abstract Data Types
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="runtime-analysis">
                        <div class="topic-number">3</div>
                        <i class="topic-icon fas fa-chart-line"></i>
                        Runtime Analysis
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="big-o">
                        <div class="topic-number">4</div>
                        <i class="topic-icon fas fa-infinity"></i>
                        Big-O, Ω, Θ Notation
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="asymptotic">
                        <div class="topic-number">5</div>
                        <i class="topic-icon fas fa-calculator"></i>
                        Asymptotic Analysis
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="master-theorem">
                        <div class="topic-number">6</div>
                        <i class="topic-icon fas fa-crown"></i>
                        Master Theorem
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="amortized">
                        <div class="topic-number">7</div>
                        <i class="topic-icon fas fa-balance-scale"></i>
                        Amortized Analysis
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="recursion">
                        <div class="topic-number">8</div>
                        <i class="topic-icon fas fa-redo"></i>
                        Recursion & Backtracking
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="linkedlist">
                        <div class="topic-number">9</div>
                        <i class="topic-icon fas fa-link"></i>
                        Linked Lists
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="stacks-queues">
                        <div class="topic-number">10</div>
                        <i class="topic-icon fas fa-layer-group"></i>
                        Stacks & Queues
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="trees-heaps">
                        <div class="topic-number">11</div>
                        <i class="topic-icon fas fa-sitemap"></i>
                        Trees & Heaps
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="disjoint-sets">
                        <div class="topic-number">12</div>
                        <i class="topic-icon fas fa-project-diagram"></i>
                        Disjoint Sets
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="graphs">
                        <div class="topic-number">13</div>
                        <i class="topic-icon fas fa-network-wired"></i>
                        Graphs
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="sorting">
                        <div class="topic-number">14</div>
                        <i class="topic-icon fas fa-sort"></i>
                        Sorting Algorithms
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="searching">
                        <div class="topic-number">15</div>
                        <i class="topic-icon fas fa-search"></i>
                        Search Algorithms
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="selection">
                        <div class="topic-number">16</div>
                        <i class="topic-icon fas fa-crosshairs"></i>
                        Selection Algorithms
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="symbol-tables">
                        <div class="topic-number">17</div>
                        <i class="topic-icon fas fa-table"></i>
                        Symbol Tables
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="hashing">
                        <div class="topic-number">18</div>
                        <i class="topic-icon fas fa-hashtag"></i>
                        Hashing
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="strings">
                        <div class="topic-number">19</div>
                        <i class="topic-icon fas fa-font"></i>
                        String Algorithms
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="algorithm-design">
                        <div class="topic-number">20</div>
                        <i class="topic-icon fas fa-drafting-compass"></i>
                        Algorithm Design
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="greedy">
                        <div class="topic-number">21</div>
                        <i class="topic-icon fas fa-hand-holding-usd"></i>
                        Greedy Algorithms
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="divide-conquer">
                        <div class="topic-number">22</div>
                        <i class="topic-icon fas fa-cut"></i>
                        Divide & Conquer
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="dynamic-programming">
                        <div class="topic-number">23</div>
                        <i class="topic-icon fas fa-chess"></i>
                        Dynamic Programming
                    </a>
                </li>
                <li class="topic-item">
                    <a href="#" class="topic-link" data-topic="complexity-classes">
                        <div class="topic-number">24</div>
                        <i class="topic-icon fas fa-layer-group"></i>
                        Complexity Classes
                    </a>
                </li>
            </ul>
        </aside>

        <section class="content-area">
            <!-- Welcome Screen -->
            <div class="topic-content active" id="welcome">
                <div class="welcome-screen">
                    <h1 class="welcome-title">Master Data Structures & Algorithms</h1>
                    <p class="welcome-subtitle">
                        Comprehensive Python-focused course covering 24 essential topics
                    </p>
                    
                    <div class="feature-grid">
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-code"></i>
                            </div>
                            <h3 class="feature-title">Interactive Learning</h3>
                            <p class="feature-description">
                                Hands-on coding examples and visualizations to understand complex concepts
                            </p>
                        </div>
                        
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-chart-bar"></i>
                            </div>
                            <h3 class="feature-title">Performance Analysis</h3>
                            <p class="feature-description">
                                Deep dive into time and space complexity with real-world examples
                            </p>
                        </div>
                        
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fas fa-trophy"></i>
                            </div>
                            <h3 class="feature-title">Progressive Mastery</h3>
                            <p class="feature-description">
                                Structured learning path from basics to advanced algorithm design patterns
                            </p>
                        </div>
                    </div>
                    
                    <div class="demo-controls">
                        <button class="btn" onclick="startLearning()">
                            <i class="fas fa-play"></i> Start Learning
                        </button>
                        <button class="btn btn-secondary" onclick="showProgress()">
                            <i class="fas fa-chart-line"></i> View Progress
                        </button>
                    </div>
                </div>
            </div>

            <!-- Topic Content Templates -->
            <div class="topic-content" id="data-types">
                <div class="content-header">
                    <h1 class="content-title">Python Data Types</h1>
                    <p class="content-subtitle">Understanding fundamental data types and their operations in Python.</p>
                </div>

                <div class="section">
                    <h2 class="section-title">Overview: The Building Blocks</h2>
                    <div class="section-content">
                        <p>Data types are the classification or categorization of data items. Python has various built-in data types that are fundamental for programming. These types define:</p>
                        <ul>
                            <li>The nature of the values (e.g., numbers, text, collections).</li>
                            <li>The operations that can be performed on those values.</li>
                            <li>How the values are stored in memory.</li>
                        </ul>
                        <p>Understanding data types is crucial as they form the foundation of any Python program. We'll explore numeric types, sequences (like strings, lists, and tuples), mappings (dictionaries), sets, and boolean types. Each type has unique characteristics and use cases.</p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Core Building Blocks: Primitive Types</h2>
                    <div class="section-content">
                        <p>Primitive data types are the most basic types available.</p>
                        <p><strong>Integers (<code>int</code>):</strong></p>
                        <p>Represent whole numbers, both positive and negative, without any decimal point. Python integers support arbitrary precision, meaning they can be as large as your system's memory allows.</p>
                        <p><em>Examples:</em> <code>count = 100</code>, <code>temperature = -5</code>, <code>large_number = 12345678901234567890</code></p>

                        <p><strong>Floating-Point Numbers (<code>float</code>):</strong></p>
                        <p>Represent real numbers, which can have a decimal point or be expressed in exponential (scientific) notation. Floats are used for values that require fractional precision.</p>
                        <p><em>Examples:</em> <code>pi_value = 3.14159</code>, <code>price = 19.99</code>, <code>scientific_notation = 6.022e23</code> (which is $6.022 \times 10^{23}$)</p>

                        <p><strong>Booleans (<code>bool</code>):</strong></p>
                        <p>Represent one of two truth values: <code>True</code> or <code>False</code>. Booleans are fundamental in control flow statements (like <code>if</code> conditions) and logical operations.</p>
                        <p><em>Examples:</em> <code>is_active = True</code>, <code>has_permission = False</code>, <code>is_greater = (10 > 5)</code> (evaluates to <code>True</code>)</p>

                        <p><strong>NoneType (<code>None</code>):</strong></p>
                        <p>Represents the absence of a value or a null value. It is a special data type with a single value, <code>None</code>. It's often used to initialize variables before they are assigned a meaningful value or to indicate that a function doesn't return anything explicitly.</p>
                        <p><em>Example:</em> <code>user_input = None</code></p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Grouping Data: Collection Types</h2>
                    <div class="section-content">
                        <p>Collection types are used to store multiple items together.</p>
                        <p><strong>Strings (<code>str</code>):</strong></p>
                        <p>Ordered, immutable sequences of Unicode characters. Strings are used to represent textual data. Immutable means that once a string is created, its contents cannot be changed directly; operations that seem to modify strings actually create new string objects.</p>
                        <p><em>Examples:</em> <code>name = "Alice Wonderland"</code>, <code>message = 'Python is fun!'</code>, <code>char = 'A'</code></p>

                        <p><strong>Lists (<code>list</code>):</strong></p>
                        <p>Ordered, mutable sequences of items. Lists can hold items of different data types, including other lists (allowing for nested structures). Mutable means you can change their content (add, remove, or modify elements) after creation.</p>
                        <p><em>Examples:</em> <code>numbers = [1, 2, 3, 4, 5]</code>, <code>mixed_data = [10, "hello", 3.14, True]</code>, <code>empty_list = []</code></p>

                        <p><strong>Tuples (<code>tuple</code>):</strong></p>
                        <p>Ordered, immutable sequences of items. Similar to lists in that they store an ordered collection of items, but tuples cannot be changed after they are created. They are often used for fixed collections of items, like coordinates or RGB color values.</p>
                        <p><em>Examples:</em> <code>point = (10.0, 20.5)</code>, <code>rgb_color = (255, 128, 0)</code>, <code>single_element_tuple = (42,)</code> (note the trailing comma)</p>

                        <p><strong>Sets (<code>set</code>):</strong></p>
                        <p>Unordered collections of unique items. Sets are mutable. They are useful for operations like membership testing, removing duplicates from a sequence, and mathematical set operations (union, intersection, difference).</p>
                        <p><em>Examples:</em> <code>unique_numbers = {1, 2, 3, 2, 1}</code> (evaluates to <code>{1, 2, 3}</code>), <code>fruits = {"apple", "banana", "cherry"}</code></p>

                        <p><strong>Dictionaries (<code>dict</code>):</strong></p>
                        <p>Unordered (in Python versions before 3.7; ordered from 3.7+) collections of key-value pairs. Dictionaries are mutable. Each key must be unique and immutable (e.g., strings, numbers, or tuples containing only immutable elements). Dictionaries are highly optimized for retrieving values when the key is known.</p>
                        <p><em>Examples:</em> <code>student = {"name": "Bob Smith", "age": 22, "major": "Computer Science"}</code>, <code>capitals = {"USA": "Washington D.C.", "UK": "London"}</code></p>
                    </div>
                </div>

                <div class="interactive-demo">
                    <h3>Interactive Demo: Data Type Explorer</h3>
                    <div class="demo-controls">
                        <button class="btn" onclick="runDemo('data-types-explorer')">Explore Types</button>
                        <button class="btn btn-secondary" onclick="resetDemo('data-types-explorer')">Reset</button>
                    </div>
                    <div class="visualization" id="data-types-viz">
                        <div class="viz-placeholder">
                            <i class="fas fa-flask" style="font-size: 3rem; margin-bottom: 1rem; display: block;"></i>
                            Interactive area to explore data types and their properties. (Demo not yet implemented)
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-python"># Code examples will be populated here by JavaScript</code></pre>
                </div>

                <div class="quiz-section">
                    <h3>Knowledge Check</h3>
                    </div>
            </div>

            <div class="topic-content" id="adts">
                <div class="content-header">
                    <h1 class="content-title">Abstract Data Types (ADTs)</h1>
                    <p class="content-subtitle">Understanding the 'what' before the 'how' in data organization.</p>
                </div>

                <div class="section">
                    <h2 class="section-title">What is an Abstract Data Type?</h2>
                    <div class="section-content">
                        <p>An Abstract Data Type (ADT) is a theoretical concept that defines a data type by its behavior (semantics) from the point of view of a user. It specifies:</p>
                        <ul>
                            <li><strong>Data:</strong> The kind of data that can be stored (e.g., a collection of integers, a set of key-value pairs).</li>
                            <li><strong>Operations:</strong> A set of operations that can be performed on that data (e.g., add an item, remove an item, find an item).</li>
                        </ul>
                        <p>Crucially, an ADT <strong>does not specify how</strong> these operations are implemented or how the data is stored in memory. It's like a blueprint or a contract. For example, a "List" ADT might specify operations like <code>add(item)</code>, <code>remove(item)</code>, <code>get(index)</code>, and <code>size()</code>, but it doesn't say whether it should be implemented using an array or a linked list.</p>
                        <p><strong>Key Idea:</strong> Separation of interface (what it does) from implementation (how it does it). This is a fundamental principle in software engineering called <strong>abstraction</strong>.</p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Interface vs. Implementation</h2>
                    <div class="section-content">
                        <p>The distinction between an ADT's interface and its concrete implementation is vital:</p>
                        <p><strong>Interface:</strong></p>
                        <ul>
                            <li>Defines the set of operations available to the user.</li>
                            <li>Specifies the expected behavior of these operations (e.g., what inputs they take, what outputs they produce, any pre/post-conditions).</li>
                            <li>Acts as a contract between the ADT and its user.</li>
                        </ul>
                        <p><strong>Implementation (Data Structure):</strong></p>
                        <ul>
                            <li>Provides the actual code that makes the ADT work.</li>
                            <li>Chooses how to store the data (e.g., using arrays, linked lists, hash tables).</li>
                            <li>Writes the algorithms for each operation defined in the interface.</li>
                        </ul>
                        <p><strong>Benefits of this separation:</strong></p>
                        <ul>
                            <li><strong>Modularity:</strong> The implementation can be changed (e.g., to improve performance) without affecting the code that uses the ADT, as long as the interface remains the same.</li>
                            <li><strong>Reusability:</strong> A well-defined ADT can be used in many different parts of a program or in different programs.</li>
                            <li><strong>Simplicity:</strong> Users of the ADT only need to understand the interface, not the complex details of the implementation.</li>
                        </ul>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Common Abstract Data Types</h2>
                    <div class="section-content">
                        <p>Several ADTs are fundamental in computer science:</p>
                        <p><strong>1. List ADT:</strong> Represents an ordered sequence of elements. Operations typically include adding elements, removing elements, accessing elements by position, and finding the size.</p>
                        <p><strong>2. Stack ADT:</strong> Represents a collection of items with Last-In, First-Out (LIFO) semantics. Think of a stack of plates. Operations include <code>push</code> (add to top), <code>pop</code> (remove from top), and <code>peek</code> or <code>top</code> (view top item).</p>
                        <p><strong>3. Queue ADT:</strong> Represents a collection of items with First-In, First-Out (FIFO) semantics. Think of a queue of people waiting. Operations include <code>enqueue</code> (add to rear) and <code>dequeue</code> (remove from front).</p>
                        <p><strong>4. Deque (Double-Ended Queue) ADT:</strong> A generalization of a queue where items can be added or removed from either the front or the rear.</p>
                        <p><strong>5. Set ADT:</strong> Represents an unordered collection of unique items. Operations include adding items, removing items, checking for membership, and set operations like union, intersection, and difference.</p>
                        <p><strong>6. Map (Dictionary or Associative Array) ADT:</strong> Represents a collection of key-value pairs, where each key is unique. Operations include adding a pair, removing a pair, retrieving a value by its key, and checking if a key exists.</p>
                        <p><strong>7. Priority Queue ADT:</strong> A collection of items where each item has an associated priority. The <code>dequeue</code> operation removes the item with the highest (or lowest) priority.</p>
                        <p>We will explore many of these in detail, along with their common implementations (data structures), throughout this course.</p>
                    </div>
                </div>

                <div class="interactive-demo">
                    <h3>ADT Implementation Demo</h3>
                    <p style="margin-bottom: 1rem; color: var(--gray-400); font-size: 0.9rem;">Visualize basic operations for common ADTs. Select an ADT, then enter values and click an operation.</p>
                    <div class="demo-controls" style="flex-wrap: wrap; justify-content: flex-start; gap: 0.5rem;">
                        <button class="btn btn-sm" onclick="runDemo('adts-stack')">Stack</button>
                        <button class="btn btn-sm btn-secondary" onclick="runDemo('adts-queue')">Queue</button>
                        <button class="btn btn-sm" onclick="runDemo('adts-set')" style="background-color: var(--secondary); border-color: var(--secondary-dark);">Set</button>
                        <button class="btn btn-sm" onclick="runDemo('adts-map')" style="background-color: var(--accent); border-color: var(--accent-dark);">Map</button>
                        <button class="btn btn-sm btn-warning" onclick="resetDemo('adts')">Reset Demo</button>
                    </div>
                    <div id="adt-controls-area" style="margin-top: 1.5rem; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; min-height: 40px; padding: 0.5rem; background-color: var(--gray-800); border-radius: 8px;">
                        </div>
                    <div class="visualization" id="adts-viz" style="min-height: 150px; margin-top: 1rem; padding: 1rem; display: flex; flex-direction: column; align-items: center; justify-content: center; border: 2px dashed var(--gray-700); border-radius: 8px; background-color: var(--gray-900); overflow: auto;">
                        <div class="viz-placeholder">
                            <i class="fas fa-cubes" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i>
                            <span style="color: var(--gray-500);">Select an ADT to start the interactive demo.</span>
                        </div>
                    </div>
                    <div id="adt-message-area" style="margin-top: 1rem; min-height: 20px; text-align: center; padding: 0.5rem; border-radius: 4px;">
                        </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-python"># Python implementations & conceptual interfaces for ADTs will be shown here.</code></pre>
                </div>

                <div class="quiz-section">
                    <h3>Knowledge Check: ADTs</h3>
                    <!-- Quiz items will be generated by JavaScript -->
                </div>
            </div>

            <div class="topic-content" id="runtime-analysis">
                <div class="content-header">
                    <h1 class="content-title">Runtime Analysis</h1>
                    <p class="content-subtitle">Understanding how algorithms perform as input size grows.</p>
                </div>

                <div class="section">
                    <h2 class="section-title">What is Runtime Analysis?</h2>
                    <div class="section-content">
                        <p>Runtime analysis is the process of determining how an algorithm's execution time (or resource usage, like memory) scales with the size of its input. It's a crucial skill in algorithm design because it allows us to:</p>
                        <ul>
                            <li><strong>Predict Performance:</strong> Estimate how long an algorithm will take for a given input size.</li>
                            <li><strong>Compare Algorithms:</strong> Objectively compare different algorithms that solve the same problem to choose the most efficient one.</li>
                            <li><strong>Identify Bottlenecks:</strong> Pinpoint parts of an algorithm that contribute most to its runtime, guiding optimization efforts.</li>
                        </ul>
                        <p>Instead of measuring actual time (which can vary based on hardware, programming language, and other factors), runtime analysis focuses on the <em>growth rate</em> of the number of operations an algorithm performs as the input size increases. This is often expressed using asymptotic notation (like Big-O, which we'll cover next).</p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Counting Basic Operations</h2>
                    <div class="section-content">
                        <p>To analyze runtime, we identify and count the "basic operations" an algorithm performs. A basic operation is one whose execution time is considered constant and does not depend on the values of its operands. Examples include:</p>
                        <ul>
                            <li>Assignments (e.g., <code>x = 5</code>)</li>
                            <li>Arithmetic operations (e.g., <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>)</li>
                            <li>Comparisons (e.g., <code>==</code>, <code><</code>, <code>></code>, <code>!=</code>)</li>
                            <li>Accessing an element in an array/list by index (e.g., <code>my_list[i]</code>)</li>
                            <li>Returning from a function</li>
                        </ul>
                        <p>We then express the total number of these operations as a function of the input size, typically denoted by 'n'. For example, if an algorithm performs <code>3n + 2</code> operations for an input of size 'n', this function describes its runtime characteristic.</p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Input Size (n)</h2>
                    <div class="section-content">
                        <p>The "input size" (often denoted as 'n') is a critical parameter in runtime analysis. It quantifies the amount of data the algorithm processes. The definition of 'n' depends on the problem:</p>
                        <ul>
                            <li>For sorting algorithms, 'n' is usually the number of items to be sorted.</li>
                            <li>For graph algorithms, 'n' might be the number of vertices or edges (or both).</li>
                            <li>For string algorithms, 'n' could be the length of the string.</li>
                            <li>For matrix operations, 'n' might be the dimensions of the matrix.</li>
                        </ul>
                        <p>The goal is to understand how the runtime changes as 'n' grows very large.</p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Worst-Case, Average-Case, and Best-Case Analysis</h2>
                    <div class="section-content">
                        <p>An algorithm's runtime can vary even for inputs of the same size, depending on the specific arrangement or values of the data. Therefore, we often consider different scenarios:</p>
                        <ul>
                            <li><strong>Worst-Case Analysis:</strong> Determines the maximum number of operations for any input of size 'n'. This provides an upper bound on the runtime and is often the most important analysis because it guarantees performance.</li>
                            <li><strong>Average-Case Analysis:</strong> Determines the expected number of operations for a "typical" or random input of size 'n'. This can be more complex to calculate as it requires defining what a "typical" input is and may involve probabilistic analysis.</li>
                            <li><strong>Best-Case Analysis:</strong> Determines the minimum number of operations for any input of size 'n'. This provides a lower bound but is often less useful for practical purposes than worst-case or average-case.</li>
                        </ul>
                        <p>Unless specified otherwise, "runtime analysis" usually refers to <strong>worst-case analysis</strong>.</p>
                    </div>
                </div>

                <div class="interactive-demo" id="runtime-analysis-interactive-demo">
                    <h3 style="margin-bottom: 1.5rem;">Runtime Growth Visualizer</h3>
                    <div class="demo-controls" style="display: flex; flex-wrap: wrap; gap: 1rem; align-items: center; margin-bottom: 1.5rem; padding: 1rem; background-color: var(--gray-800); border-radius: 12px;">
                        <div style="flex-grow: 1; min-width: 250px;">
                            <label for="raSnippetSelect" style="display: block; margin-bottom: 0.5rem; color: var(--gray-300); font-size: 0.9em;">Select Algorithm Pattern:</label>
                            <select id="raSnippetSelect" class="adt-input" style="width: 100%;">
                                <!-- Options will be populated by JS -->
                            </select>
                        </div>
                        <div style="min-width: 150px;">
                            <label for="raInputSize" style="display: block; margin-bottom: 0.5rem; color: var(--gray-300); font-size: 0.9em;">Input Size (n):</label>
                            <input type="number" id="raInputSize" value="8" min="1" max="50" class="adt-input" style="width: 100%;">
                             <p style="font-size: 0.75em; color: var(--gray-500); margin-top: 0.25rem;">(Keep n small for animations, 1-50)</p>
                        </div>
                        <button class="btn" onclick="runRaDemo()" style="align-self: flex-end; padding: 0.75rem 1.25rem;">
                            <i class="fas fa-play-circle" style="margin-right: 0.5rem;"></i>Visualize
                        </button>
                    </div>

                    <div id="ra-code-display-container" style="margin-bottom: 1.5rem; background-color: var(--gray-800); border: 1px solid var(--gray-700); border-radius: 12px; overflow: hidden;">
                        <div style="background: var(--gray-700); padding: 0.75rem 1.25rem; border-bottom: 1px solid var(--gray-600);">
                            <span style="color: var(--gray-300); font-size: 0.9em; font-weight: 600;">Conceptual Code Snippet:</span>
                        </div>
                        <pre style="margin:0; max-height: 200px; overflow-y: auto;"><code class="language-python" id="raCodeSnippet" style="font-size: 0.85em;"># Select a snippet to see code.</code></pre>
                    </div>

                    <div id="ra-animation-container" style="position: relative; min-height: 250px; background-color: var(--gray-900); border: 1px solid var(--gray-700); border-radius: 12px; padding: 1.5rem; display: flex; flex-direction: column; align-items: center; justify-content: center; overflow: hidden;">
                        <div id="ra-viz" style="width: 100%; height: 100%; display: flex; flex-wrap: wrap; align-content: flex-start; justify-content: center; gap: 5px; position: relative;">
                            <!-- Animation elements will be injected here -->
                            <div class="viz-placeholder" style="text-align: center;">
                                <i class="fas fa-cogs" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i>
                                <span style="color: var(--gray-500);">Animation of operations will appear here.</span>
                            </div>
                        </div>
                    </div>
                    <div id="ra-analysis-output" style="margin-top: 1.5rem; padding: 1rem; background-color: var(--gray-800); border-radius: 8px; text-align: center; font-size: 1.1em; color: var(--white);">
                        <!-- Analysis like T(n) = ... will appear here -->
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-python"># Python code examples illustrating runtime analysis concepts.</code></pre>
                </div>

                <div class="quiz-section">
                    <h3>Knowledge Check: Runtime Analysis</h3>
                    <!-- Quiz questions for Runtime Analysis will be dynamically populated here -->
                </div>
            </div>

            <div class="topic-content" id="big-o">
                <div class="content-header">
                    <h1 class="content-title">Big-O, Ω, Θ Notation</h1>
                    <p class="content-subtitle">Mathematical tools for describing algorithm efficiency bounds.</p>
                </div>

                <div class="section">
                    <h2 class="section-title">What is Asymptotic Notation?</h2>
                    <div class="section-content">
                        <p>Asymptotic notation provides a mathematical framework for describing how an algorithm's resource usage (time or space) grows as the input size approaches infinity. It helps us classify algorithms by their efficiency characteristics rather than exact measurements.</p>
                        <p><strong>Why do we need this?</strong> Exact running times depend on many factors: hardware, programming language, compiler optimizations, and input specifics. Asymptotic notation abstracts away these details to focus on the fundamental growth rate.</p>
                        <p>The three most important notations are:</p>
                        <ul>
                            <li><strong>Big-O (O):</strong> Upper bound - "algorithm will never be worse than this"</li>
                            <li><strong>Big-Omega (Ω):</strong> Lower bound - "algorithm will never be better than this"</li>
                            <li><strong>Big-Theta (Θ):</strong> Tight bound - "algorithm grows exactly like this"</li>
                        </ul>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Big-O Notation (Upper Bound)</h2>
                    <div class="section-content">
                        <p><strong>Mathematical Definition:</strong> f(n) = O(g(n)) if there exist positive constants c and n₀ such that f(n) ≤ c·g(n) for all n ≥ n₀.</p>
                        <p><strong>Intuitive Meaning:</strong> Big-O describes the worst-case scenario. It tells us that no matter how bad things get, the algorithm will never perform worse than this bound.</p>
                        <p><strong>Common Big-O Classes (from best to worst):</strong></p>
                        <ul>
                            <li><strong>O(1) - Constant:</strong> Array access, hash table lookup (average case)</li>
                            <li><strong>O(log n) - Logarithmic:</strong> Binary search, balanced tree operations</li>
                            <li><strong>O(n) - Linear:</strong> Array traversal, linear search</li>
                            <li><strong>O(n log n) - Linearithmic:</strong> Efficient sorting (merge sort, heap sort)</li>
                            <li><strong>O(n²) - Quadratic:</strong> Nested loops, bubble sort, selection sort</li>
                            <li><strong>O(n³) - Cubic:</strong> Triple nested loops, naive matrix multiplication</li>
                            <li><strong>O(2ⁿ) - Exponential:</strong> Recursive Fibonacci, subset enumeration</li>
                            <li><strong>O(n!) - Factorial:</strong> Traveling salesman (brute force), permutation generation</li>
                        </ul>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Big-Omega Notation (Lower Bound)</h2>
                    <div class="section-content">
                        <p><strong>Mathematical Definition:</strong> f(n) = Ω(g(n)) if there exist positive constants c and n₀ such that f(n) ≥ c·g(n) for all n ≥ n₀.</p>
                        <p><strong>Intuitive Meaning:</strong> Big-Omega describes the best-case scenario or establishes a lower limit. It tells us that the algorithm will require at least this much time/space, no matter how favorable the conditions.</p>
                        <p><strong>Examples:</strong></p>
                        <ul>
                            <li><strong>Comparison-based sorting is Ω(n log n):</strong> Any algorithm that sorts by comparing elements must make at least n log n comparisons in the worst case.</li>
                            <li><strong>Finding an element in an unsorted array is Ω(n):</strong> In the worst case, you might need to check every element.</li>
                            <li><strong>Matrix multiplication is Ω(n²):</strong> You must at least read all n² elements of the result matrix.</li>
                        </ul>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Big-Theta Notation (Tight Bound)</h2>
                    <div class="section-content">
                        <p><strong>Mathematical Definition:</strong> f(n) = Θ(g(n)) if f(n) = O(g(n)) AND f(n) = Ω(g(n)).</p>
                        <p><strong>Intuitive Meaning:</strong> Big-Theta provides both upper and lower bounds, giving us the exact growth rate. When we say an algorithm is Θ(g(n)), we mean it grows exactly like g(n) - no faster and no slower asymptotically.</p>
                        <p><strong>Key Point:</strong> Θ notation is the most precise, but also the hardest to establish. You need to prove both the upper and lower bounds.</p>
                        <p><strong>Examples:</strong></p>
                        <ul>
                            <li><strong>Linear search:</strong> Θ(n) - best case is 1 comparison, worst case is n comparisons, average is n/2 comparisons</li>
                            <li><strong>Merge sort:</strong> Θ(n log n) - always divides the array in half and merges in linear time</li>
                            <li><strong>Matrix multiplication (standard algorithm):</strong> Θ(n³) - always performs n³ multiplications</li>
                        </ul>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Practical Rules for Analysis</h2>
                    <div class="section-content">
                        <p><strong>1. Drop Constants:</strong> O(5n) = O(n), O(n/2) = O(n)</p>
                        <p><strong>2. Drop Lower-Order Terms:</strong> O(n² + n + 1) = O(n²)</p>
                        <p><strong>3. Multiplication Rule:</strong> If you have nested loops, multiply their complexities</p>
                        <p><strong>4. Addition Rule:</strong> If you have sequential operations, add their complexities (then apply rule 2)</p>
                        <p><strong>5. Logarithm Base Doesn't Matter:</strong> O(log₂ n) = O(log₁₀ n) = O(log n)</p>
                        <p><strong>6. Focus on the Input Size:</strong> Identify what n represents (array length, number of nodes, etc.)</p>
                    </div>
                </div>

                <div class="interactive-demo">
                    <h3>Growth Rate Visualization</h3>
                    <p style="margin-bottom: 1rem; color: var(--gray-400); font-size: 0.9rem;">
                        Visualize how different complexity classes grow with input size. Adjust the input size to see the dramatic differences.
                    </p>
                    <div class="demo-controls" style="flex-wrap: wrap; justify-content: flex-start; gap: 0.5rem; margin-bottom: 1rem;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; color: var(--gray-300);">
                            Input Size (n): 
                            <input type="range" id="inputSizeSlider" min="1" max="50" value="10" 
                                style="margin-left: 0.5rem;" onchange="updateGrowthChart()">
                            <span id="inputSizeValue" style="min-width: 30px; font-weight: bold;">10</span>
                        </label>
                        <button class="btn btn-sm btn-warning" onclick="animateGrowth()">Animate Growth</button>
                        <button class="btn btn-sm btn-secondary" onclick="resetGrowthDemo()">Reset</button>
                    </div>
                    <div class="visualization" id="growth-viz" style="min-height: 300px; background: var(--gray-900); border-radius: 8px; padding: 1rem;">
                        <canvas id="growthChart" width="800" height="250" style="max-width: 100%; background: var(--gray-800);"></canvas>
                    </div>
                    <div id="growth-table" style="margin-top: 1rem; overflow-x: auto;">
                        <!-- Growth comparison table will be generated here -->
                    </div>
                </div>

                <div class="interactive-demo">
                    <h3>Algorithm Complexity Analyzer</h3>
                    <p style="margin-bottom: 1rem; color: var(--gray-400); font-size: 0.9rem;">
                        Analyze code snippets to determine their time complexity. Select a code pattern and see the step-by-step analysis.
                    </p>
                    <div class="demo-controls" style="flex-wrap: wrap; justify-content: flex-start; gap: 0.5rem;">
                        <button class="btn btn-sm" onclick="analyzeComplexity('single-loop')">Single Loop</button>
                        <button class="btn btn-sm" onclick="analyzeComplexity('nested-loops')">Nested Loops</button>
                        <button class="btn btn-sm" onclick="analyzeComplexity('binary-search')">Binary Search</button>
                        <button class="btn btn-sm" onclick="analyzeComplexity('recursive-fibonacci')">Recursive Fibonacci</button>
                        <button class="btn btn-sm" onclick="analyzeComplexity('merge-sort')">Merge Sort</button>
                        <button class="btn btn-sm btn-warning" onclick="resetComplexityAnalyzer()">Reset</button>
                    </div>
                    <div class="visualization" id="complexity-viz" style="min-height: 250px; margin-top: 1rem; padding: 1rem; background: var(--gray-900); border-radius: 8px; display: flex; flex-direction: column; gap: 1rem;">
                        <div class="viz-placeholder">
                            <i class="fas fa-code" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i>
                            <span style="color: var(--gray-500);">Select a code pattern to analyze its complexity.</span>
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-python"># Big-O Analysis Examples in Python

            # O(1) - Constant Time
            def constant_time_operation(arr):
                """Accessing array element by index"""
                if len(arr) > 0:
                    return arr[0]  # Always takes same time regardless of array size
                return None

            # O(log n) - Logarithmic Time
            def binary_search(arr, target):
                """Binary search in sorted array"""
                left, right = 0, len(arr) - 1
                
                while left <= right:
                    mid = (left + right) // 2
                    if arr[mid] == target:
                        return mid
                    elif arr[mid] < target:
                        left = mid + 1  # Eliminate half the search space
                    else:
                        right = mid - 1  # Eliminate half the search space
                
                return -1  # Each iteration cuts problem size in half

            # O(n) - Linear Time
            def linear_search(arr, target):
                """Linear search through array"""
                for i in range(len(arr)):  # May need to check every element
                    if arr[i] == target:
                        return i
                return -1

            def array_sum(arr):
                """Sum all elements in array"""
                total = 0
                for num in arr:  # Must visit each element exactly once
                    total += num
                return total

            # O(n log n) - Linearithmic Time
            def merge_sort(arr):
                """Efficient divide-and-conquer sorting"""
                if len(arr) <= 1:
                    return arr
                
                mid = len(arr) // 2
                left = merge_sort(arr[:mid])    # T(n/2)
                right = merge_sort(arr[mid:])   # T(n/2)
                
                return merge(left, right)       # O(n) to merge

            def merge(left, right):
                """Merge two sorted arrays"""
                result = []
                i = j = 0
                
                while i < len(left) and j < len(right):
                    if left[i] <= right[j]:
                        result.append(left[i])
                        i += 1
                    else:
                        result.append(right[j])
                        j += 1
                
                result.extend(left[i:])
                result.extend(right[j:])
                return result

            # O(n²) - Quadratic Time
            def bubble_sort(arr):
                """Bubble sort with nested loops"""
                n = len(arr)
                for i in range(n):          # Outer loop: n iterations
                    for j in range(n - 1):  # Inner loop: (n-1) iterations
                        if arr[j] > arr[j + 1]:
                            arr[j], arr[j + 1] = arr[j + 1], arr[j]
                return arr

            def find_all_pairs(arr):
                """Find all pairs in array"""
                pairs = []
                for i in range(len(arr)):       # Outer loop: n iterations
                    for j in range(i + 1, len(arr)):  # Inner loop: decreasing iterations
                        pairs.append((arr[i], arr[j]))
                return pairs  # Total: n(n-1)/2 = O(n²)

            # O(2ⁿ) - Exponential Time
            def fibonacci_recursive(n):
                """Naive recursive Fibonacci (exponential time)"""
                if n <= 1:
                    return n
                # Each call creates 2 more calls, creating a binary tree of height n
                return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

            def power_set(s):
                """Generate all subsets of a set"""
                if not s:
                    return [set()]
                
                first = s[0]
                rest = s[1:]
                subsets_without_first = power_set(rest)  # 2^(n-1) subsets
                subsets_with_first = [subset | {first} for subset in subsets_without_first]
                
                return subsets_without_first + subsets_with_first  # Total: 2^n subsets

            # Space Complexity Examples
            def constant_space(n):
                """O(1) space - only using a few variables"""
                total = 0
                count = 0
                for i in range(n):
                    total += i
                    count += 1
                return total / count

            def linear_space_recursive(n):
                """O(n) space - recursion creates n stack frames"""
                if n <= 0:
                    return 0
                return n + linear_space_recursive(n - 1)

            def quadratic_space(n):
                """O(n²) space - creating n×n matrix"""
                matrix = []
                for i in range(n):
                    row = []
                    for j in range(n):
                        row.append(i * j)
                    matrix.append(row)
                return matrix

            # Analyzing Complex Algorithms
            def complex_algorithm(arr):
                """Mixed complexity analysis"""
                n = len(arr)
                
                # Phase 1: O(n log n) - sorting
                sorted_arr = merge_sort(arr.copy())
                
                # Phase 2: O(n) - single pass
                max_val = max(sorted_arr)
                
                # Phase 3: O(n²) - nested loops (dominates overall complexity)
                result = []
                for i in range(n):
                    for j in range(i, n):
                        if sorted_arr[i] + sorted_arr[j] == max_val:
                            result.append((i, j))
                
                # Overall: O(n log n) + O(n) + O(n²) = O(n²)
                return result

            # Best, Average, and Worst Case Analysis
            def quick_sort_analysis(arr, low=0, high=None):
                """
                QuickSort Analysis:
                - Best Case: O(n log n) - pivot always divides array evenly
                - Average Case: O(n log n) - random pivot placement
                - Worst Case: O(n²) - pivot is always smallest or largest element
                """
                if high is None:
                    high = len(arr) - 1
                
                if low < high:
                    pivot_index = partition(arr, low, high)
                    quick_sort_analysis(arr, low, pivot_index - 1)
                    quick_sort_analysis(arr, pivot_index + 1, high)

            def partition(arr, low, high):
                """Partition function for QuickSort"""
                pivot = arr[high]
                i = low - 1
                
                for j in range(low, high):
                    if arr[j] <= pivot:
                        i += 1
                        arr[i], arr[j] = arr[j], arr[i]
                
                arr[i + 1], arr[high] = arr[high], arr[i + 1]
                return i + 1</code></pre>
                </div>

                <div class="quiz-section">
                    <h3>Knowledge Check: Big-O, Ω, Θ Notation</h3>
                    <!-- Quiz items will be generated by JavaScript -->
                </div>
            </div>

            <div class="topic-content" id="asymptotic">
                <div class="content-header">
                    <h1 class="content-title">Asymptotic Analysis</h1>
                    <p class="content-subtitle">Understanding algorithm behavior as input size approaches infinity.</p>
                </div>

                <div class="section">
                    <h2 class="section-title">What is Asymptotic Analysis?</h2>
                    <div class="section-content">
                        <p>Asymptotic analysis is a mathematical approach to analyze the behavior of algorithms as the input size grows to infinity. It helps us understand:</p>
                        <ul>
                            <li><strong>Scalability:</strong> How does performance change with larger inputs?</li>
                            <li><strong>Comparative Analysis:</strong> Which algorithm is fundamentally better?</li>
                            <li><strong>Resource Requirements:</strong> Time and space complexity patterns</li>
                        </ul>
                        <p>Instead of measuring exact runtime (which depends on hardware, implementation, etc.), we focus on the <strong>growth rate</strong> of resource consumption relative to input size.</p>
                        <p><strong>Key Insight:</strong> We care about the dominant term that grows fastest as n approaches infinity, ignoring constants and lower-order terms.</p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Mathematical Foundation</h2>
                    <div class="section-content">
                        <p>Given functions f(n) and g(n) representing algorithm complexities:</p>
                        <p><strong>Big-O (Upper Bound):</strong> f(n) = O(g(n)) if there exist positive constants c and n₀ such that f(n) ≤ c·g(n) for all n ≥ n₀</p>
                        <p><strong>Big-Ω (Lower Bound):</strong> f(n) = Ω(g(n)) if there exist positive constants c and n₀ such that f(n) ≥ c·g(n) for all n ≥ n₀</p>
                        <p><strong>Big-Θ (Tight Bound):</strong> f(n) = Θ(g(n)) if f(n) = O(g(n)) AND f(n) = Ω(g(n))</p>
                        <p><strong>Practical Meaning:</strong></p>
                        <ul>
                            <li>O(g(n)): Algorithm will never be worse than g(n) growth rate</li>
                            <li>Ω(g(n)): Algorithm will never be better than g(n) growth rate</li>
                            <li>Θ(g(n)): Algorithm grows exactly at g(n) rate (tight characterization)</li>
                        </ul>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Common Growth Rates & Properties</h2>
                    <div class="section-content">
                        <p><strong>Hierarchy (from fastest to slowest growing):</strong></p>
                        <p>O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)</p>
                        <p><strong>Key Properties:</strong></p>
                        <ul>
                            <li><strong>Transitivity:</strong> If f(n) = O(g(n)) and g(n) = O(h(n)), then f(n) = O(h(n))</li>
                            <li><strong>Reflexivity:</strong> f(n) = O(f(n))</li>
                            <li><strong>Sum Rule:</strong> O(f(n)) + O(g(n)) = O(max(f(n), g(n)))</li>
                            <li><strong>Product Rule:</strong> O(f(n)) × O(g(n)) = O(f(n) × g(n))</li>
                            <li><strong>Constant Factors:</strong> O(c × f(n)) = O(f(n)) for any constant c > 0</li>
                        </ul>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Analyzing Algorithms Step-by-Step</h2>
                    <div class="section-content">
                        <p><strong>1. Identify Basic Operations:</strong> Count the most frequently executed operations</p>
                        <p><strong>2. Express as Function of n:</strong> Write T(n) representing total operations</p>
                        <p><strong>3. Find Dominant Term:</strong> Identify the fastest-growing term</p>
                        <p><strong>4. Apply Asymptotic Notation:</strong> Express using O, Ω, or Θ</p>
                        <p><strong>Example Analysis:</strong></p>
                        <pre><code>def example_algorithm(arr):
                n = len(arr)           # O(1)
                for i in range(n):     # Loop runs n times
                    for j in range(i): # Inner loop runs 0,1,2,...,n-1 times
                        print(arr[j])  # O(1) operation
                
            # Total operations: 0 + 1 + 2 + ... + (n-1) = n(n-1)/2 = O(n²)</code></pre>
                    </div>
                </div>

                <div class="interactive-demo">
                    <h3>Growth Rate Visualization</h3>
                    <p style="margin-bottom: 1rem; color: var(--gray-400); font-size: 0.9rem;">Compare how different complexity functions grow with input size. Adjust the input size and see the dramatic differences!</p>
                    <div class="demo-controls">
                        <label for="asymptoticN">Input Size (n): </label>
                        <input type="range" id="asymptoticN" min="1" max="20" value="10" style="margin: 0 10px;">
                        <span id="asymptoticNValue">10</span>
                        <button class="btn btn-sm btn-secondary" onclick="runDemo('asymptotic-comparison')">Update Chart</button>
                        <button class="btn btn-sm btn-warning" onclick="resetDemo('asymptotic')">Reset</button>
                    </div>
                    <div class="visualization" id="asymptotic-viz" style="min-height: 300px; margin-top: 1rem; padding: 1rem; border: 2px solid var(--gray-600); border-radius: 8px; background-color: var(--gray-900);">
                        <div class="viz-placeholder">
                            <i class="fas fa-chart-line" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i>
                            <span style="color: var(--gray-500);">Click 'Update Chart' to visualize growth rates.</span>
                        </div>
                    </div>
                    <div id="asymptotic-results" style="margin-top: 1rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-python"># Asymptotic Analysis Examples in Python

            import time
            import math

            # Example 1: Constant Time - O(1)
            def constant_operation(arr):
                """Always takes same time regardless of input size"""
                if len(arr) > 0:
                    return arr[0]  # First element access
                return None

            # Example 2: Linear Time - O(n)
            def linear_search(arr, target):
                """Time grows linearly with input size"""
                for i, item in enumerate(arr):
                    if item == target:
                        return i
                return -1

            # Example 3: Quadratic Time - O(n²)
            def bubble_sort(arr):
                """Nested loops create quadratic growth"""
                n = len(arr)
                for i in range(n):
                    for j in range(0, n - i - 1):
                        if arr[j] > arr[j + 1]:
                            arr[j], arr[j + 1] = arr[j + 1], arr[j]
                return arr

            # Example 4: Logarithmic Time - O(log n)
            def binary_search(arr, target):
                """Divides search space in half each iteration"""
                left, right = 0, len(arr) - 1
                while left <= right:
                    mid = (left + right) // 2
                    if arr[mid] == target:
                        return mid
                    elif arr[mid] < target:
                        left = mid + 1
                    else:
                        right = mid - 1
                return -1

            # Example 5: Linearithmic Time - O(n log n)
            def merge_sort(arr):
                """Divide and conquer with linear merge"""
                if len(arr) <= 1:
                    return arr
                
                mid = len(arr) // 2
                left = merge_sort(arr[:mid])
                right = merge_sort(arr[mid:])
                
                return merge(left, right)

            def merge(left, right):
                result = []
                i = j = 0
                
                while i < len(left) and j < len(right):
                    if left[i] <= right[j]:
                        result.append(left[i])
                        i += 1
                    else:
                        result.append(right[j])
                        j += 1
                
                result.extend(left[i:])
                result.extend(right[j:])
                return result

            # Asymptotic Analysis Helper Functions
            def analyze_complexity(func, input_sizes):
                """Measure actual runtime to verify theoretical analysis"""
                results = {}
                
                for n in input_sizes:
                    # Generate test data
                    test_data = list(range(n))
                    
                    # Time the function
                    start_time = time.perf_counter()
                    func(test_data.copy())  # Use copy to avoid modifying original
                    end_time = time.perf_counter()
                    
                    results[n] = end_time - start_time
                
                return results

            def calculate_growth_rates(n):
                """Calculate values for common growth rates"""
                return {
                    'O(1)': 1,
                    'O(log n)': math.log2(n) if n > 0 else 0,
                    'O(n)': n,
                    'O(n log n)': n * math.log2(n) if n > 0 else 0,
                    'O(n²)': n * n,
                    'O(n³)': n * n * n,
                    'O(2ⁿ)': min(2**n, 1000000),  # Cap to prevent overflow
                    'O(n!)': min(math.factorial(min(n, 10)), 1000000)  # Cap factorial
                }

            # Example usage and testing
            if __name__ == "__main__":
                # Test with different input sizes
                sizes = [10, 100, 1000]
                
                print("Bubble Sort Complexity Analysis:")
                bubble_results = analyze_complexity(bubble_sort, sizes)
                for size, time_taken in bubble_results.items():
                    print(f"n={size}: {time_taken:.6f} seconds")
                
                print("\nGrowth Rate Comparison for n=10:")
                rates = calculate_growth_rates(10)
                for complexity, value in rates.items():
                    print(f"{complexity}: {value}")
            </code></pre>
                </div>

                <div class="quiz-section">
                    <h3>Knowledge Check: Asymptotic Analysis</h3>
                </div>
            </div>

            <div class="topic-content" id="master-theorem">
                <div class="content-header">
                    <h1 class="content-title">Master Theorem</h1>
                    <p class="content-subtitle">A powerful tool for analyzing divide-and-conquer algorithms.</p>
                </div>

                <div class="section">
                    <h2 class="section-title">What is the Master Theorem?</h2>
                    <div class="section-content">
                        <p>The Master Theorem provides a direct way to determine the time complexity of divide-and-conquer algorithms without solving complex recurrence relations manually.</p>
                        <p><strong>Recurrence Form:</strong> T(n) = aT(n/b) + f(n)</p>
                        <ul>
                            <li><strong>a ≥ 1:</strong> Number of subproblems</li>
                            <li><strong>b > 1:</strong> Factor by which subproblem size is reduced</li>
                            <li><strong>f(n):</strong> Cost of work done outside recursive calls (divide + combine)</li>
                        </ul>
                        <p><strong>Intuition:</strong> We compare the cost of recursive calls (a·T(n/b)) with the cost of non-recursive work (f(n)) to determine which dominates the overall complexity.</p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">The Three Cases</h2>
                    <div class="section-content">
                        <p>Let n<sub>log<sub>b</sub>a</sub> be the critical exponent. The Master Theorem has three cases:</p>
                        
                        <p><strong>Case 1: Recursion Dominates</strong></p>
                        <p>If f(n) = O(n<sup>c</sup>) where c < log<sub>b</sub>a, then <strong>T(n) = Θ(n<sup>log<sub>b</sub>a</sup>)</strong></p>
                        <p><em>The recursive calls do most of the work.</em></p>
                        
                        <p><strong>Case 2: Balanced</strong></p>
                        <p>If f(n) = Θ(n<sup>c</sup> log<sup>k</sup>n) where c = log<sub>b</sub>a and k ≥ 0, then <strong>T(n) = Θ(n<sup>c</sup> log<sup>k+1</sup>n)</strong></p>
                        <p><em>Recursive calls and non-recursive work are roughly equal.</em></p>
                        
                        <p><strong>Case 3: Non-recursive Work Dominates</strong></p>
                        <p>If f(n) = Ω(n<sup>c</sup>) where c > log<sub>b</sub>a, and af(n/b) ≤ δf(n) for some δ < 1 and sufficiently large n, then <strong>T(n) = Θ(f(n))</strong></p>
                        <p><em>The work done outside recursive calls dominates.</em></p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Step-by-Step Application</h2>
                    <div class="section-content">
                        <p><strong>Step 1:</strong> Identify a, b, and f(n) from the recurrence</p>
                        <p><strong>Step 2:</strong> Calculate n<sup>log<sub>b</sub>a</sup></p>
                        <p><strong>Step 3:</strong> Compare f(n) with n<sup>log<sub>b</sub>a</sup></p>
                        <p><strong>Step 4:</strong> Apply the appropriate case</p>
                        <p><strong>Step 5:</strong> Verify regularity condition for Case 3 if needed</p>
                        
                        <p><strong>Example: Merge Sort</strong></p>
                        <p>T(n) = 2T(n/2) + Θ(n)</p>
                        <ul>
                            <li>a = 2, b = 2, f(n) = Θ(n)</li>
                            <li>n<sup>log<sub>2</sub>2</sup> = n<sup>1</sup> = n</li>
                            <li>f(n) = Θ(n) = Θ(n<sup>log<sub>b</sub>a</sup>)</li>
                            <li>This is Case 2 with k = 0</li>
                            <li>Therefore: T(n) = Θ(n log n)</li>
                        </ul>
                    </div>
                </div>

                <div class="interactive-demo">
                    <h3>Master Theorem Calculator</h3>
                    <p style="margin-bottom: 1rem; color: var(--gray-400); font-size: 0.9rem;">Enter the parameters of your recurrence relation T(n) = aT(n/b) + f(n) to see which case applies.</p>
                    <div class="demo-controls" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                        <div>
                            <label for="masterA">Number of subproblems (a):</label>
                            <input type="number" id="masterA" min="1" value="2" class="master-input">
                        </div>
                        <div>
                            <label for="masterB">Subproblem size factor (b):</label>
                            <input type="number" id="masterB" min="2" value="2" class="master-input">
                        </div>
                        <div>
                            <label for="masterF">f(n) exponent (c in n^c):</label>
                            <input type="number" id="masterF" step="0.1" value="1" class="master-input">
                        </div>
                        <div>
                            <label for="masterK">Log factor (k in log^k n):</label>
                            <input type="number" id="masterK" min="0" value="0" class="master-input">
                        </div>
                    </div>
                    <div style="text-align: center; margin-bottom: 1rem;">
                        <button class="btn" onclick="runDemo('master-theorem')">Analyze Recurrence</button>
                        <button class="btn btn-secondary" onclick="runDemo('master-examples')">Show Examples</button>
                        <button class="btn btn-warning" onclick="resetDemo('master')">Reset</button>
                    </div>
                    <div class="visualization" id="master-viz" style="min-height: 250px; margin-top: 1rem; padding: 1rem; border: 2px solid var(--gray-600); border-radius: 8px; background-color: var(--gray-900);">
                        <div class="viz-placeholder">
                            <i class="fas fa-calculator" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i>
                            <span style="color: var(--gray-500);">Enter parameters and click 'Analyze Recurrence' to see the Master Theorem analysis.</span>
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-python"># Master Theorem Examples and Implementation

            import math

            def master_theorem_analyzer(a, b, f_exponent, log_factor=0):
                """
                Analyze a recurrence using Master Theorem
                T(n) = aT(n/b) + f(n) where f(n) = Θ(n^f_exponent * log^log_factor(n))
                """
                if a < 1 or b <= 1:
                    return "Invalid parameters: a must be ≥ 1, b must be > 1"
                
                # Calculate critical exponent
                log_b_a = math.log(a) / math.log(b)
                
                result = {
                    'a': a,
                    'b': b,
                    'f_exponent': f_exponent,
                    'log_factor': log_factor,
                    'critical_exponent': log_b_a,
                    'case': None,
                    'complexity': None,
                    'explanation': None
                }
                
                # Determine which case applies
                if f_exponent < log_b_a:
                    # Case 1: Recursion dominates
                    result['case'] = 1
                    result['complexity'] = f"Θ(n^{log_b_a:.3f})"
                    result['explanation'] = f"f(n) grows slower than n^{log_b_a:.3f}, so recursion dominates"
                    
                elif abs(f_exponent - log_b_a) < 1e-10:  # Approximately equal
                    # Case 2: Balanced
                    result['case'] = 2
                    result['complexity'] = f"Θ(n^{log_b_a:.3f} * log^{log_factor + 1}(n))"
                    result['explanation'] = f"f(n) and n^{log_b_a:.3f} grow at same rate"
                    
                else:  # f_exponent > log_b_a
                    # Case 3: Non-recursive work dominates
                    result['case'] = 3
                    if log_factor == 0:
                        result['complexity'] = f"Θ(n^{f_exponent})"
                    else:
                        result['complexity'] = f"Θ(n^{f_exponent} * log^{log_factor}(n))"
                    result['explanation'] = f"f(n) grows faster than n^{log_b_a:.3f}, so f(n) dominates"
                    result['note'] = "Verify regularity condition: af(n/b) ≤ δf(n) for some δ < 1"
                
                return result

            # Common Algorithm Examples
            def analyze_common_algorithms():
                """Analyze recurrences for well-known algorithms"""
                algorithms = {
                    'Merge Sort': (2, 2, 1, 0),  # T(n) = 2T(n/2) + Θ(n)
                    'Binary Search': (1, 2, 0, 0),  # T(n) = T(n/2) + Θ(1)
                    'Karatsuba Multiplication': (3, 2, 2, 0),  # T(n) = 3T(n/2) + Θ(n²)
                    'Strassen Matrix Multiplication': (7, 2, 2, 0),  # T(n) = 7T(n/2) + Θ(n²)
                    'Quick Sort (average)': (2, 2, 1, 1),  # T(n) = 2T(n/2) + Θ(n log n)
                }
                
                results = {}
                for name, (a, b, f_exp, log_f) in algorithms.items():
                    results[name] = master_theorem_analyzer(a, b, f_exp, log_f)
                
                return results

            # Detailed Examples with Step-by-Step Analysis
            def step_by_step_example(algorithm_name, a, b, f_description, f_exponent):
                """Provide detailed step-by-step Master Theorem analysis"""
                print(f"\n=== {algorithm_name} Analysis ===")
                print(f"Recurrence: T(n) = {a}T(n/{b}) + {f_description}")
                print(f"\nStep 1: Identify parameters")
                print(f"  a = {a} (number of subproblems)")
                print(f"  b = {b} (subproblem size reduction factor)")
                print(f"  f(n) = {f_description}")
                
                log_b_a = math.log(a) / math.log(b)
                print(f"\nStep 2: Calculate critical exponent")
                print(f"  log_b(a) = log_{b}({a}) = {log_b_a:.3f}")
                print(f"  So n^(log_b(a)) = n^{log_b_a:.3f}")
                
                print(f"\nStep 3: Compare f(n) with n^{log_b_a:.3f}")
                
                result = master_theorem_analyzer(a, b, f_exponent)
                
                print(f"\nStep 4: Apply Master Theorem")
                print(f"  Case {result['case']}: {result['explanation']}")
                print(f"  Result: T(n) = {result['complexity']}")
                
                return result

            if __name__ == "__main__":
                # Example 1: Merge Sort
                step_by_step_example("Merge Sort", 2, 2, "Θ(n)", 1)
                
                # Example 2: Binary Search
                step_by_step_example("Binary Search", 1, 2, "Θ(1)", 0)
                
                # Example 3: Strassen's Algorithm
                step_by_step_example("Strassen Matrix Mult", 7, 2, "Θ(n²)", 2)
                
                # Analyze all common algorithms
                print("\n" + "="*50)
                print("COMMON ALGORITHM COMPLEXITIES")
                print("="*50)
                
                common_results = analyze_common_algorithms()
                for name, analysis in common_results.items():
                    print(f"\n{name}:")
                    print(f"  Parameters: a={analysis['a']}, b={analysis['b']}")
                    print(f"  Case {analysis['case']}: {analysis['complexity']}")
            </code></pre>
                </div>

                <div class="quiz-section">
                    <h3>Knowledge Check: Master Theorem</h3>
                </div>
            </div>
            
            <div class="topic-content" id="amortized">
                <div class="content-header">
                    <h1 class="content-title">Amortized Analysis</h1>
                    <p class="content-subtitle">Analyzing the average cost of operations over a sequence, not just the worst-case of one.</p>
                </div>

                <div class="section">
                    <h2 class="section-title">What is Amortized Analysis?</h2>
                    <div class="section-content">
                        <p>Amortized analysis is a technique used to determine the average time taken per operation in a sequence of operations. While some individual operations in the sequence might be very expensive, amortized analysis shows that the average cost over the entire sequence can be quite low, especially if expensive operations are rare.</p>
                        <p>It's different from:</p>
                        <ul>
                            <li><strong>Worst-Case Analysis:</strong> Focuses on the maximum cost of a single operation.</li>
                            <li><strong>Average-Case Analysis:</strong> Considers the expected cost of an operation over all possible inputs, assuming a certain probability distribution of inputs.</li>
                        </ul>
                        <p>Amortized analysis is particularly useful for data structures that occasionally need to perform a costly reorganization (like resizing a dynamic array or rebuilding a splay tree) but are otherwise efficient for most operations. It gives a more realistic performance guarantee for a sequence of operations.</p>
                        <p>The key idea is that the "amortized cost" of an operation can be thought of as an "average cost in the long run." If an operation has a small amortized cost, it means that any sequence of <i>m</i> operations will take at most <i>m</i> times the amortized cost, even if some of those operations were individually expensive.</p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Why Use Amortized Analysis?</h2>
                    <div class="section-content">
                        <ul>
                            <li><strong>More Realistic Performance Picture:</strong> For some data structures, worst-case analysis of a single operation can be overly pessimistic. Amortized analysis provides a tighter bound on the total time for a sequence.</li>
                            <li><strong>Design Justification:</strong> It can justify using data structures that have occasional expensive operations by showing that these costs are effectively "paid for" by earlier, cheaper operations.</li>
                            <li><strong>Algorithm Comparison:</strong> Helps in comparing algorithms where one might have a better worst-case for a single operation, but another has a better amortized cost over a sequence.</li>
                        </ul>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Common Methods for Amortized Analysis</h2>
                    <div class="section-content">
                        <p>There are three main techniques to perform amortized analysis:</p>
                        <p><strong>1. Aggregate Method (Brute Force):</strong></p>
                        <ul>
                            <li>Determine the total worst-case cost, T(n), for a sequence of 'n' operations.</li>
                            <li>The amortized cost per operation is then T(n) / n.</li>
                            <li>This method directly calculates the average cost without using complex accounting.</li>
                        </ul>
                        <p><strong>2. Accounting Method (Banker's Method):</strong></p>
                        <ul>
                            <li>Assign a specific "amortized cost" (which might be different from its actual cost) to each type of operation.</li>
                            <li>If an operation's amortized cost is greater than its actual cost, the difference is stored as "credit" in a "bank account" associated with the data structure.</li>
                            <li>If an operation's amortized cost is less than its actual cost, the difference is "paid for" by the accumulated credit.</li>
                            <li>The key is to ensure the credit in the bank never goes negative. The total amortized cost for a sequence of operations is an upper bound on the total actual cost, provided the credit remains non-negative.</li>
                        </ul>
                        <p><strong>3. Potential Method (Physicist's Method):</strong></p>
                        <ul>
                            <li>Defines a "potential function" Φ (Phi) that maps the current state of the data structure to a real number (the "potential"). Φ(D<sub>0</sub>) is usually 0 for the initial state D<sub>0</sub>.</li>
                            <li>The amortized cost (â<sub>i</sub>) of the i-th operation is its actual cost (c<sub>i</sub>) plus the change in potential due to the operation: â<sub>i</sub> = c<sub>i</sub> + Φ(D<sub>i</sub>) - Φ(D<sub>i-1</sub>).</li>
                            <li>For a sequence of 'n' operations, the total amortized cost is Σâ<sub>i</sub> = Σ(c<sub>i</sub> + Φ(D<sub>i</sub>) - Φ(D<sub>i-1</sub>)). This telescopes to (Σc<sub>i</sub>) + Φ(D<sub>n</sub>) - Φ(D<sub>0</sub>).</li>
                            <li>If we can ensure Φ(D<sub>n</sub>) ≥ Φ(D<sub>0</sub>) (often by ensuring potential is always non-negative and starts at 0), then the total amortized cost is an upper bound on the total actual cost.</li>
                        </ul>
                    </div>
                </div>

                <div class="interactive-demo" id="amortized-analysis-interactive-demo">
                    <h3 style="margin-bottom: 1.5rem;">Dynamic Array Append Visualizer (Amortized Costs)</h3>
                    <div class="demo-controls" style="display: flex; flex-wrap: wrap; gap: 1rem; align-items: center; margin-bottom: 1.5rem; padding: 1rem; background-color: var(--gray-800); border-radius: 12px;">
                        <button class="btn" onclick="aa_appendItem()" style="padding: 0.75rem 1.25rem;">
                            <i class="fas fa-plus-circle" style="margin-right: 0.5rem;"></i>Append Item
                        </button>
                        <button class="btn btn-warning" onclick="aa_resetDemo()" style="padding: 0.75rem 1.25rem;">
                            <i class="fas fa-undo" style="margin-right: 0.5rem;"></i>Reset Demo
                        </button>
                         <div style="flex-grow: 1; text-align: right;">
                            <label for="aaInitialCapacity" style="font-size: 0.9em; color: var(--gray-300); margin-right: 0.5rem;">Initial Capacity:</label>
                            <input type="number" id="aaInitialCapacity" value="4" min="1" max="10" class="adt-input" style="width: 70px;">
                        </div>
                    </div>

                    <div id="aa-array-visualization" style="min-height: 80px; background-color: var(--gray-900); border: 1px solid var(--gray-700); border-radius: 8px; padding: 1rem; display: flex; flex-wrap: nowrap; align-items: center; margin-bottom: 1rem; overflow-x: auto;">
                        <!-- Array elements will be visualized here -->
                        <span class="viz-placeholder" style="color: var(--gray-500);">Array will be shown here.</span>
                    </div>

                    <div id="aa-cost-tracking" style="background-color: var(--gray-800); border-radius: 8px; padding: 1rem; font-size: 0.9em;">
                        <h4 style="color: var(--primary); margin-bottom: 0.75rem;">Cost Analysis (Accounting Method):</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.75rem;">
                            <p><strong>Items Added:</strong> <span id="aaItemsCount">0</span></p>
                            <p><strong>Current Capacity:</strong> <span id="aaCurrentCapacity">0</span></p>
                            <p><strong>Last Actual Cost:</strong> <span id="aaActualCost">0</span></p>
                            <p><strong>Amortized Cost (for append):</strong> <span id="aaAmortizedOpCost" style="color: var(--secondary);">3 units</span></p>
                            <p><strong>Total Actual Cost:</strong> <span id="aaTotalActualCost" style="color: var(--error-dark);">0</span></p>
                            <p><strong>Total Credits Spent (Amortized):</strong> <span id="aaTotalAmortizedCost" style="color: var(--success-dark);">0</span></p>
                            <p><strong>Credit Bank Balance:</strong> <span id="aaCreditBank" style="color: var(--accent);">0</span></p>
                        </div>
                         <div id="aaEventLog" style="margin-top: 1rem; max-height: 100px; overflow-y: auto; background-color: var(--gray-900); padding: 0.5rem; border-radius: 4px; font-size: 0.85em; color: var(--gray-300);">
                            Event Log: Click "Append Item" to start...
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Example: Dynamic Array Resizing</h2>
                    <div class="section-content">
                        <p>A common example used to illustrate amortized analysis is a dynamic array (like Python's list) that doubles its capacity when it becomes full.
                        Consider an <code>append</code> operation:</p>
                        <ul>
                            <li><strong>If array not full:</strong> Add element. Actual cost = 1 (constant).</li>
                            <li><strong>If array is full:</strong>
                                <ol>
                                    <li>Allocate a new array, typically double the size (cost = 1 or proportional to new size for allocation, simplify to 1).</li>
                                    <li>Copy all N old elements to the new array (cost = N).</li>
                                    <li>Add the new element (cost = 1).</li>
                                    <li>Total actual cost for this "expensive" append ≈ N + 2.</li>
                                </ol>
                            </li>
                        </ul>
                        <p>While a single append can be O(N) in the worst case (when resizing), amortized analysis shows that the average cost per append over a sequence of operations is O(1) (constant).</p>
                        <p>Using the <strong>accounting method</strong>: Let's assign an amortized cost of 3 units for each append operation.</p>
                        <ul>
                            <li>1 unit pays for the immediate insertion.</li>
                            <li>2 units are stored as credit.</li>
                        </ul>
                        <p>When the array of size M (previously N, where M=2N if it just resized from N) needs to resize, it has accumulated M/2 * 2 = M credits from the appends that filled the first half of the array after the last resize (or from the start if it's the first resize). Copying M elements costs M units. These M credits can pay for the expensive copy operation. The new element's insertion is paid by its own 1 unit. Thus, the bank balance never goes negative.
                        The interactive demo above visualizes this process.
                        </p>
                    </div>
                </div>


                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-python"># Python's list append has amortized O(1) complexity.</code></pre>
                </div>

                <div class="quiz-section">
                    <h3>Knowledge Check: Amortized Analysis</h3>
                    <!-- Quiz questions will be dynamically populated here -->
                </div>
            </div>

            <div class="topic-content" id="recursion"> 
                <div class="content-header">
                    <h1 class="content-title">Recursion & Backtracking</h1>
                    <p class="content-subtitle">Solving problems by breaking them into smaller, self-similar pieces and exploring possibilities.</p>
                </div>

                <div class="section">
                    <h2 class="section-title">Understanding Recursion</h2>
                    <div class="section-content">
                        <p>Recursion is a powerful programming technique where a function calls itself, either directly or indirectly, to solve a problem. A recursive function breaks a problem down into smaller, identical or very similar subproblems until it reaches a simple enough case that can be solved directly.</p>
                        <p>Key components of a recursive function:</p>
                        <ul>
                            <li><strong>Base Case(s):</strong> The simplest version(s) of the problem that can be solved directly, without further recursion. This is crucial to prevent infinite loops. A recursive function must have at least one base case.</li>
                            <li><strong>Recursive Step (Recursive Call):</strong> The part of the function where it calls itself with a modified input, moving closer to the base case. The function performs some operations and then calls itself to solve a smaller part of the problem.</li>
                        </ul>
                        <p>Think of it like Russian nesting dolls (Matryoshka dolls), where each doll contains a smaller, similar doll inside until you reach the smallest one.</p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">The Call Stack & Recursion</h2>
                    <div class="section-content">
                        <p>When a function is called, a new "stack frame" is created on the program's call stack. This frame stores information about the function call, such as its parameters, local variables, and the return address (where execution should resume after the function finishes).</p>
                        <p>In recursion, each recursive call creates a new stack frame. This continues until a base case is reached. Then, as the functions return, their stack frames are popped off the stack one by one, and the results are passed back up the chain of calls.</p>
                        <p><strong>Stack Overflow:</strong> If a recursive function lacks a proper base case, or if the recursion goes too deep (e.g., for very large inputs with linear recursion), it can consume all available space on the call stack, leading to a "stack overflow" error.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2 class="section-title">Pros and Cons of Recursion</h2>
                    <div class="section-content">
                        <p><strong>Pros:</strong></p>
                        <ul>
                            <li><strong>Elegance and Readability:</strong> Recursive solutions can be very intuitive and closely mirror mathematical definitions for problems that are naturally recursive (e.g., factorial, Fibonacci, tree traversals).</li>
                            <li><strong>Problem Decomposition:</strong> Simplifies complex problems by breaking them into manageable subproblems.</li>
                        </ul>
                        <p><strong>Cons:</strong></p>
                        <ul>
                            <li><strong>Performance Overhead:</strong> Function calls can be slower than iteration due to the overhead of managing stack frames.</li>
                            <li><strong>Stack Overflow Risk:</strong> Deep recursion can exhaust stack memory.</li>
                            <li><strong>Debugging Complexity:</strong> Tracing recursive calls can sometimes be more challenging than stepping through iterative code.</li>
                        </ul>
                        <p>Many recursive algorithms can be converted to iterative solutions using explicit stacks or other data structures, though sometimes this makes the code less intuitive.</p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Introduction to Backtracking</h2>
                    <div class="section-content">
                        <p>Backtracking is an algorithmic technique for solving problems recursively by trying to build a solution incrementally, one piece at a time, and removing those solutions that fail to satisfy the constraints of the problem at any point in time (i.e., "backtracking").</p>
                        <p>It's a refined form of brute force search where, instead of exploring all possible candidates, we abandon a path as soon as we determine it cannot lead to a valid solution.</p>
                        <p><strong>General Approach:</strong></p>
                        <ol>
                            <li><strong>Choose:</strong> Make a choice at the current step (e.g., place a queen in a column, pick an element for a subset).</li>
                            <li><strong>Explore:</strong> Recursively try to solve the problem with the chosen option.</li>
                            <li><strong>Unchoose (Backtrack):</strong> If the recursive call doesn't lead to a solution, undo the choice made in step 1 and try another option. If all options are exhausted, return failure for this path.</li>
                        </ol>
                        <p>Backtracking is often used for constraint satisfaction problems, such as puzzles (Sudoku, N-Queens), finding paths (mazes), and generating combinations/permutations.</p>
                    </div>
                </div>

                <div class="interactive-demo" id="recursion-backtracking-interactive-demo">
                    <h3 style="margin-bottom: 1.5rem;">Recursion & Backtracking Visualizer</h3>
                    <div class="demo-controls" style="display: flex; flex-wrap: wrap; gap: 1rem; align-items: center; margin-bottom: 1.5rem; padding: 1rem; background-color: var(--gray-800); border-radius: 12px;">
                        <select id="rbDemoSelect" class="adt-input" style="flex-grow:1; min-width: 200px;">
                            <option value="factorial">Recursion: Factorial Call Stack</option>
                            <option value="maze">Backtracking: Maze Solver</option>
                            <option value="nqueens_stub">Backtracking: N-Queens (Conceptual)</option>
                        </select>
                        <div id="rbDemoSpecificControls" style="display:flex; gap: 1rem; align-items:center;">
                            <!-- Specific controls for factorial (N) or maze (size) will go here -->
                        </div>
                        <button class="btn" onclick="rb_runSelectedDemo()" style="padding: 0.75rem 1.25rem;">
                            <i class="fas fa-play-circle" style="margin-right: 0.5rem;"></i>Visualize
                        </button>
                        <button class="btn btn-warning" onclick="rb_resetDemoArea()" style="padding: 0.75rem 1.25rem;">
                            <i class="fas fa-undo" style="margin-right: 0.5rem;"></i>Reset
                        </button>
                    </div>

                    <div id="rb-visualization-area" style="min-height: 300px; background-color: var(--gray-900); border: 1px solid var(--gray-700); border-radius: 8px; padding: 1.5rem; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; overflow: auto;">
                        <div class="viz-placeholder" id="rbVizPlaceholder" style="text-align: center;">
                            <i class="fas fa-project-diagram" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i>
                            <span style="color: var(--gray-500);">Select a demo and click Visualize.</span>
                        </div>
                        <!-- Factorial call stack or Maze grid will be rendered here -->
                    </div>
                    <div id="rb-output-log" style="margin-top: 1rem; max-height: 150px; overflow-y: auto; background-color: var(--gray-800); border-radius: 8px; padding: 1rem; font-size: 0.9em; color: var(--gray-300); line-height: 1.6;">
                        Log: Visualization steps and results will appear here...
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-python"># Python code examples for Recursion and Backtracking.</code></pre>
                </div>

                <div class="quiz-section">
                    <h3>Knowledge Check: Recursion & Backtracking</h3>
                    <!-- Quiz questions will be dynamically populated here -->
                </div>
            </div>

            <div class="topic-content" id="linkedlist"> 
                <div class="content-header">
                    <h1 class="content-title">Linked Lists</h1>
                    <p class="content-subtitle">Dynamic data structures connecting elements through pointers.</p>
                </div>

                <div class="section">
                    <h2 class="section-title">What is a Linked List?</h2>
                    <div class="section-content">
                        <p>A linked list is a linear data structure where elements are not stored at contiguous memory locations. Instead, each element, called a "node," consists of two parts:</p>
                        <ul>
                            <li><strong>Data:</strong> The actual value stored in the node.</li>
                            <li><strong>Next Pointer (or Link):</strong> A reference to the next node in the sequence. The last node's next pointer typically points to <code>null</code> (or <code>None</code> in Python), indicating the end of the list.</li>
                        </ul>
                        <p>The entry point into a linked list is usually a pointer called the "head," which points to the first node. If the list is empty, the head is <code>null</code>.</p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Types of Linked Lists</h2>
                    <div class="section-content">
                        <p><strong>1. Singly Linked List:</strong></p>
                        <ul>
                            <li>Each node contains data and a pointer to the next node.</li>
                            <li>Traversal is only possible in one direction (forward).</li>
                        </ul>
                        <p><strong>2. Doubly Linked List:</strong></p>
                        <ul>
                            <li>Each node contains data, a pointer to the next node, and a pointer to the previous node.</li>
                            <li>Allows traversal in both forward and backward directions.</li>
                            <li>Operations like deletion can be more efficient if the node to be deleted is known, as we don't need to traverse to find its predecessor.</li>
                        </ul>
                        <p><strong>3. Circular Linked List:</strong></p>
                        <ul>
                            <li>The last node's next pointer points back to the first node (head) instead of <code>null</code>.</li>
                            <li>Can be singly or doubly circular.</li>
                            <li>Useful for applications where items are processed in a continuous loop (e.g., round-robin scheduling).</li>
                        </ul>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Common Operations</h2>
                    <div class="section-content">
                        <p>Key operations on linked lists include:</p>
                        <ul>
                            <li><strong>Traversal:</strong> Visiting each node in the list, usually starting from the head.</li>
                            <li><strong>Insertion:</strong> Adding a new node. This can be at the beginning (prepend), at the end (append), or at a specific position.</li>
                            <li><strong>Deletion:</strong> Removing a node. This can be the first node, the last node, or a node with a specific value/position.</li>
                            <li><strong>Search:</strong> Finding a node with a specific data value.</li>
                            <li><strong>isEmpty:</strong> Checking if the list has any nodes.</li>
                            <li><strong>Size:</strong> Counting the number of nodes in the list.</li>
                        </ul>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Linked Lists vs. Arrays (Dynamic Arrays)</h2>
                    <div class="section-content">
                        <p><strong>Linked Lists:</strong></p>
                        <ul>
                            <li><strong>Pros:</strong> Dynamic size (easy to grow/shrink). Efficient insertions/deletions at any point (O(1) if you have a pointer to the previous node, otherwise O(N) to find it).</li>
                            <li><strong>Cons:</strong> No random access (to get the i-th element, you must traverse from the head, O(N)). Extra memory overhead for storing pointers.</li>
                        </ul>
                        <p><strong>Arrays (Dynamic Arrays like Python lists):</strong></p>
                        <ul>
                            <li><strong>Pros:</strong> Random access (O(1) to get i-th element). Better memory locality (can be cache-friendly).</li>
                            <li><strong>Cons:</strong> Insertion/deletion in the middle can be expensive (O(N) due to shifting elements). Resizing can be costly (amortized O(1) for append, but occasionally O(N)).</li>
                        </ul>
                    </div>
                </div>

                <div class="interactive-demo" id="linkedlist-interactive-demo">
                    <h3 style="margin-bottom: 1.5rem;">Singly Linked List Visualizer</h3>
                    <div class="demo-controls" style="display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: flex-end; margin-bottom: 1.5rem; padding: 1rem; background-color: var(--gray-800); border-radius: 12px;">
                        <div style="flex-basis: 150px;">
                            <label for="llNodeValue" style="font-size:0.9em; color:var(--gray-300); display:block; margin-bottom:0.25rem;">Node Value:</label>
                            <input type="text" id="llNodeValue" placeholder="e.g., 10 or 'A'" class="adt-input" style="width:100%;">
                        </div>
                        <div style="flex-basis: 150px;">
                            <label for="llNodePosition" style="font-size:0.9em; color:var(--gray-300); display:block; margin-bottom:0.25rem;">Position (0-indexed):</label>
                            <input type="number" id="llNodePosition" placeholder="Index (optional)" class="adt-input" style="width:100%;">
                        </div>
                        <button class="btn btn-sm" onclick="ll_addNodeVisual()" title="Adds to end if no position, or at position."><i class="fas fa-plus-circle"></i> Add</button>
                        <button class="btn btn-sm btn-secondary" onclick="ll_removeNodeVisual()" title="Removes from position, or last if no position."><i class="fas fa-trash-alt"></i> Remove</button>
                        <button class="btn btn-sm btn-warning" onclick="ll_resetDemo()" title="Clear the list."><i class="fas fa-undo"></i> Reset</button>
                    </div>

                    <div id="ll-visualization-area" style="min-height: 120px; background-color: var(--gray-900); border: 1px solid var(--gray-700); border-radius: 8px; padding: 1.5rem; display: flex; flex-wrap: wrap; align-items: center; overflow-x: auto; gap: 10px;">
                        <div class="viz-placeholder" id="llVizPlaceholder" style="text-align: center; width:100%;">
                            <i class="fas fa-link" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i>
                            <span style="color: var(--gray-500);">Linked list will be visualized here.</span>
                        </div>
                    </div>
                     <div id="ll-output-log" style="margin-top: 1rem; max-height: 100px; overflow-y: auto; background-color: var(--gray-800); border-radius: 8px; padding: 0.75rem; font-size: 0.85em; color: var(--gray-300); line-height: 1.5;">
                        Log: Operations will be logged here...
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-python"># Python implementation of a Singly Linked List.</code></pre>
                </div>

                <div class="quiz-section">
                    <h3>Knowledge Check: Linked Lists</h3>
                    <!-- Quiz questions will be dynamically populated here -->
                </div>
            </div>

            <div class="topic-content" id="stacks-queues"> 
                <div class="content-header">
                    <h1 class="content-title">Stacks & Queues</h1>
                    <p class="content-subtitle">Fundamental linear data structures with specific access patterns.</p>
                </div>

                <div class="section">
                    <h2 class="section-title">Understanding Stacks (LIFO)</h2>
                    <div class="section-content">
                        <p>A Stack is a linear data structure that follows the <strong>LIFO (Last-In, First-Out)</strong> principle. This means the last element added to the stack is the first one to be removed. Think of a stack of plates: you add a plate to the top, and you remove a plate from the top.</p>
                        <p>Key Stack Operations:</p>
                        <ul>
                            <li><strong>Push:</strong> Adds an item to the top of the stack.</li>
                            <li><strong>Pop:</strong> Removes and returns the item from the top of the stack. An error occurs if the stack is empty.</li>
                            <li><strong>Peek (or Top):</strong> Returns the item at the top of the stack without removing it. An error occurs if the stack is empty.</li>
                            <li><strong>isEmpty:</strong> Checks if the stack contains any elements.</li>
                            <li><strong>Size:</strong> Returns the number of elements in the stack.</li>
                        </ul>
                        <p><strong>Common Applications:</strong> Function call management (the call stack), undo/redo mechanisms in software, expression evaluation (infix to postfix conversion and evaluation), syntax parsing, browser history.</p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Understanding Queues (FIFO)</h2>
                    <div class="section-content">
                        <p>A Queue is a linear data structure that follows the <strong>FIFO (First-In, First-Out)</strong> principle. This means the first element added to the queue is the first one to be removed. Think of a line of people waiting for a service: the first person in line is the first person served.</p>
                        <p>Key Queue Operations:</p>
                        <ul>
                            <li><strong>Enqueue (or Add/Offer):</strong> Adds an item to the rear (end) of the queue.</li>
                            <li><strong>Dequeue (or Remove/Poll):</strong> Removes and returns the item from the front (start) of the queue. An error occurs if the queue is empty.</li>
                            <li><strong>Peek (or Front/Element):</strong> Returns the item at the front of the queue without removing it. An error occurs if the queue is empty.</li>
                            <li><strong>isEmpty:</strong> Checks if the queue contains any elements.</li>
                            <li><strong>Size:</strong> Returns the number of elements in the queue.</li>
                        </ul>
                        <p><strong>Common Applications:</strong> Task scheduling in operating systems, print job spooling, breadth-first search (BFS) in graphs, handling requests on a server, message queues in distributed systems.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2 class="section-title">Implementations</h2>
                    <div class="section-content">
                        <p>Stacks and Queues are Abstract Data Types (ADTs) and can be implemented using various underlying data structures:</p>
                        <p><strong>Using Arrays/Dynamic Arrays (like Python lists):</strong></p>
                        <ul>
                            <li><strong>Stack:</strong> Easy to implement. <code>push</code> can be <code>append()</code>, and <code>pop</code> can be <code>pop()</code> from the end of the list. These are typically O(1) amortized.</li>
                            <li><strong>Queue:</strong> Using a list for a queue can be inefficient if not done carefully. If <code>enqueue</code> is <code>append()</code> and <code>dequeue</code> is <code>pop(0)</code> (removing from the beginning), dequeue becomes O(N) because all subsequent elements need to be shifted. A circular array (or Python's <code>collections.deque</code>) is a more efficient array-based queue implementation (O(1) for both operations).</li>
                        </ul>
                        <p><strong>Using Linked Lists:</strong></p>
                        <ul>
                            <li><strong>Stack:</strong> <code>push</code> (add to head) and <code>pop</code> (remove from head) are O(1).</li>
                            <li><strong>Queue:</strong> Requires pointers to both head (for dequeue) and tail (for enqueue) to achieve O(1) for both operations.</li>
                        </ul>
                    </div>
                </div>

                <div class="interactive-demo" id="stacks-queues-interactive-demo">
                    <h3 style="margin-bottom: 1.5rem;">Stack & Queue Visualizer</h3>
                    <div style="display: flex; flex-wrap: wrap; gap: 2rem;">
                        <!-- Stack Demo Area -->
                        <div style="flex: 1; min-width: 300px; background-color:var(--gray-800); padding:1.5rem; border-radius:12px;">
                            <h4 style="color:var(--primary); margin-bottom:1rem; text-align:center;">Stack (LIFO)</h4>
                            <div class="demo-controls" style="display:flex; gap:0.5rem; margin-bottom:1rem; justify-content:center;">
                                <input type="text" id="sqStackValue" placeholder="Value" class="adt-input" style="width:100px;">
                                <button class="btn btn-sm" onclick="sq_pushVisual()"><i class="fas fa-arrow-down"></i> Push</button>
                                <button class="btn btn-sm btn-secondary" onclick="sq_popVisual()"><i class="fas fa-arrow-up"></i> Pop</button>
                            </div>
                            <div id="sq-stack-visualization" class="sq-container" style="flex-direction: column-reverse; /* Stack grows upwards */ align-items:center;">
                                <span class="viz-placeholder" style="color:var(--gray-500);">Stack is empty</span>
                            </div>
                            <p style="text-align:center; margin-top:0.5rem; font-size:0.9em;">Top: <span id="sqStackTop" style="color:var(--accent);">-</span></p>
                        </div>

                        <!-- Queue Demo Area -->
                        <div style="flex: 1; min-width: 300px; background-color:var(--gray-800); padding:1.5rem; border-radius:12px;">
                            <h4 style="color:var(--secondary); margin-bottom:1rem; text-align:center;">Queue (FIFO)</h4>
                            <div class="demo-controls" style="display:flex; gap:0.5rem; margin-bottom:1rem; justify-content:center;">
                                <input type="text" id="sqQueueValue" placeholder="Value" class="adt-input" style="width:100px;">
                                <button class="btn btn-sm" onclick="sq_enqueueVisual()" style="background:var(--gradient-3);"><i class="fas fa-arrow-left"></i> Enqueue</button>
                                <button class="btn btn-sm btn-secondary" onclick="sq_dequeueVisual()"><i class="fas fa-arrow-right"></i> Dequeue</button>
                            </div>
                            <div id="sq-queue-visualization" class="sq-container" style="flex-direction: row; /* Queue is horizontal */ justify-content:flex-start;">
                                <span class="viz-placeholder" style="color:var(--gray-500);">Queue is empty</span>
                            </div>
                             <p style="text-align:center; margin-top:0.5rem; font-size:0.9em;">Front: <span id="sqQueueFront" style="color:var(--accent);">-</span> | Rear: <span id="sqQueueRear" style="color:var(--accent);">-</span></p>
                        </div>
                    </div>
                     <div id="sq-output-log" style="margin-top: 1.5rem; max-height: 100px; overflow-y: auto; background-color: var(--dark); border:1px solid var(--gray-700); border-radius: 8px; padding: 0.75rem; font-size: 0.85em; color: var(--gray-300); line-height: 1.5;">
                        Log: Operations will be logged here...
                    </div>
                    <button class="btn btn-warning" onclick="sq_resetDemos()" style="margin-top:1rem; display:block; margin-left:auto; margin-right:auto;"><i class="fas fa-undo"></i> Reset Both</button>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-python"># Python implementations for Stacks and Queues.</code></pre>
                </div>

                <div class="quiz-section">
                    <h3>Knowledge Check: Stacks & Queues</h3>
                    <!-- Quiz questions will be dynamically populated here -->
                </div>
            </div>

            <div class="topic-content" id="trees-heaps">
                <div class="content-header">
                    <h1 class="content-title">Trees & Heaps</h1>
                    <p class="content-subtitle">Hierarchical data structures for efficient organization and retrieval.</p>
                </div>

                <div class="section">
                    <h2 class="section-title">Understanding Trees 🌳</h2>
                    <div class="section-content">
                        <p>A <strong>tree</strong> is a non-linear, hierarchical data structure consisting of nodes connected by edges. Unlike arrays or linked lists, which are linear, trees represent relationships where elements can have multiple "children."</p>
                        <p>Key Terminology:</p>
                        <ul>
                            <li><strong>Node:</strong> An entity that contains data and may link to other nodes.</li>
                            <li><strong>Edge:</strong> A connection between two nodes.</li>
                            <li><strong>Root:</strong> The topmost node in a tree, from which all other nodes descend. A tree has only one root.</li>
                            <li><strong>Parent:</strong> A node that has an edge to a child node.</li>
                            <li><strong>Child:</strong> A node that has an edge from a parent node.</li>
                            <li><strong>Sibling:</strong> Nodes that share the same parent.</li>
                            <li><strong>Leaf Node (External Node):</strong> A node with no children.</li>
                            <li><strong>Internal Node:</strong> A node with at least one child.</li>
                            <li><strong>Path:</strong> A sequence of nodes and edges connecting a node with a descendant.</li>
                            <li><strong>Depth of a Node:</strong> The length of the path from the root to the node. The depth of the root is 0.</li>
                            <li><strong>Height of a Node:</strong> The length of the longest path from the node to a leaf. The height of a leaf is 0.</li>
                            <li><strong>Height of a Tree:</strong> The height of its root node.</li>
                            <li><strong>Level:</strong> The level of a node is its depth + 1. Level 1 is the root.</li>
                        </ul>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Types of Trees</h2>
                    <div class="section-content">
                        <p><strong>1. General Trees:</strong> Trees where a node can have any number of children.</p>
                        <p><strong>2. Binary Tree (BT):</strong> A tree where each node can have at most two children, referred to as the left child and the right child.</p>
                        <p><strong>3. Binary Search Tree (BST):</strong> A special type of binary tree with an ordering property:</p>
                        <ul>
                            <li>All nodes in the left subtree of a node have values less than the node's value.</li>
                            <li>All nodes in the right subtree of a node have values greater than the node's value.</li>
                            <li>Both left and right subtrees must also be binary search trees.</li>
                            <li>This property allows for efficient searching, insertion, and deletion (average O(log n) if balanced).</li>
                        </ul>
                        <p><strong>4. Balanced Trees:</strong> BSTs that automatically maintain a balanced height to ensure O(log n) performance for operations. Examples include AVL Trees and Red-Black Trees. (Detailed coverage in advanced topics).</p>
                        <p><strong>5. Full Binary Tree:</strong> A binary tree where every node has either 0 or 2 children.</p>
                        <p><strong>6. Complete Binary Tree:</strong> A binary tree where all levels are completely filled except possibly the last level, which is filled from left to right. Heaps are often implemented as complete binary trees.</p>
                        <p><strong>7. Perfect Binary Tree:</strong> A binary tree in which all internal nodes have two children and all leaf nodes are at the same level.</p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Tree Traversals 🚶</h2>
                    <div class="section-content">
                        <p>Tree traversal is the process of visiting (e.g., printing, processing) each node in a tree exactly once. Common traversal methods for binary trees include:</p>
                        <p><strong>Depth-First Traversals (DFS):</strong></p>
                        <ul>
                            <li><strong>Pre-order Traversal:</strong> Root -> Left Subtree -> Right Subtree. (Mnemonic: Visit Root <strong>Pre</strong> (before) subtrees)</li>
                            <li><strong>In-order Traversal:</strong> Left Subtree -> Root -> Right Subtree. (Mnemonic: Visit Root <strong>In</strong>-between subtrees). For BSTs, this yields nodes in sorted order.</li>
                            <li><strong>Post-order Traversal:</strong> Left Subtree -> Right Subtree -> Root. (Mnemonic: Visit Root <strong>Post</strong> (after) subtrees). Useful for deleting nodes in a tree.</li>
                        </ul>
                        <p><strong>Breadth-First Traversal (BFS):</strong></p>
                        <ul>
                            <li><strong>Level-order Traversal:</strong> Visits nodes level by level, from left to right at each level. Typically implemented using a queue.</li>
                        </ul>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Understanding Heaps 🔥</h2>
                    <div class="section-content">
                        <p>A <strong>Heap</strong> is a specialized tree-based data structure that satisfies the <strong>heap property</strong>. Heaps are typically used to implement Priority Queues.</p>
                        <p>Types based on heap property:</p>
                        <ul>
                            <li><strong>Min-Heap:</strong> The value of each node is less than or equal to the values of its children. The root node contains the minimum value.</li>
                            <li><strong>Max-Heap:</strong> The value of each node is greater than or equal to the values of its children. The root node contains the maximum value.</li>
                        </ul>
                        <p>Heaps are usually implemented as <strong>complete binary trees</strong>, which allows them to be efficiently stored in an array or list. For an array-based heap starting at index 0:</p>
                        <ul>
                            <li>Parent of node at index <code>i</code>: <code>floor((i-1)/2)</code></li>
                            <li>Left child of node at index <code>i</code>: <code>2*i + 1</code></li>
                            <li>Right child of node at index <code>i</code>: <code>2*i + 2</code></li>
                        </ul>
                        <p><strong>Key Heap Operations:</strong></p>
                        <ul>
                            <li><strong>Insert (or Add):</strong> Adds a new element to the heap while maintaining the heap property (often involves "sifting up" or "percolating up"). Complexity: O(log n).</li>
                            <li><strong>Extract-Min / Extract-Max:</strong> Removes and returns the root element (minimum or maximum) while maintaining the heap property (often involves replacing the root with the last element and "sifting down" or "heapifying down"). Complexity: O(log n).</li>
                            <li><strong>Peek (or Get-Min / Get-Max):</strong> Returns the root element without removing it. Complexity: O(1).</li>
                            <li><strong>Heapify:</strong> Converts an arbitrary array of elements into a heap. Can be done in O(n) time.</li>
                        </ul>
                         <p><strong>Applications:</strong> Priority Queues (e.g., task scheduling, Dijkstra's algorithm, Prim's algorithm), Heap Sort algorithm.</p>
                    </div>
                </div>

                <div class="interactive-demo" id="trees-heaps-interactive-demo">
                    <h3 style="margin-bottom: 1.5rem;">Tree & Heap Visualizer</h3>
                    <div class="demo-controls" style="display: flex; flex-wrap: wrap; gap: 1rem; align-items: center; margin-bottom: 1.5rem; padding: 1rem; background-color: var(--gray-800); border-radius: 12px;">
                        <select id="thDemoTypeSelect" class="adt-input" style="flex-grow:1; min-width: 180px;">
                            <option value="bst">Binary Search Tree (BST)</option>
                            <option value="minheap">Min-Heap</option>
                        </select>
                        <input type="text" id="thNodeValue" placeholder="Node Value(s)" class="adt-input" style="flex-grow:1; min-width:150px;" title="Enter a number, or comma-separated numbers for BST bulk insert/Heapify.">
                        <div id="thOperationControls" style="display:flex; gap:0.5rem; flex-wrap:wrap;">
                            </div>
                        <button class="btn btn-warning btn-sm" onclick="th_resetCurrentDemo()"><i class="fas fa-undo"></i> Reset Current</button>
                    </div>

                    <div id="th-visualization-area" style="min-height: 350px; background-color: var(--gray-900); border: 1px solid var(--gray-700); border-radius: 8px; padding: 1.5rem; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; overflow: auto; position: relative;">
                        <div class="viz-placeholder" id="thVizPlaceholder" style="text-align: center; width:100%;">
                            <i class="fas fa-leaf" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i>
                            <span style="color: var(--gray-500);">Select demo type, enter value(s), and choose an operation.</span>
                        </div>
                        </div>
                     <div id="th-output-log" style="margin-top: 1rem; max-height: 120px; overflow-y: auto; background-color: var(--gray-800); border-radius: 8px; padding: 0.75rem; font-size: 0.85em; color: var(--gray-300); line-height: 1.5;">
                        Log: Operations and traversal results will appear here...
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-python"># Python implementations for Trees and Heaps.</code></pre>
                </div>

                <div class="quiz-section">
                    <h3>Knowledge Check: Trees & Heaps</h3>
                    </div>
            </div>

            <div class="topic-content" id="disjoint-sets">
                <div class="content-header">
                    <h1 class="content-title">Disjoint Set Union (DSU) / Union-Find</h1>
                    <p class="content-subtitle">Efficiently managing collections of disjoint sets.</p>
                </div>

                <div class="section">
                    <h2 class="section-title">What is a Disjoint Set Union (DSU)?</h2>
                    <div class="section-content">
                        <p>A Disjoint Set Union (DSU), also known as a Union-Find data structure, is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. It provides operations to efficiently:</p>
                        <ul>
                            <li>Determine which subset a particular element belongs to (<strong>Find</strong>).</li>
                            <li>Join two subsets into a single subset (<strong>Union</strong>).</li>
                            <li>Create a new set containing a new element (<strong>MakeSet</strong>).</li>
                        </ul>
                        <p>Each subset is typically represented by a "representative" or "parent" element. The <strong>Find</strong> operation returns this representative, allowing us to check if two elements are in the same set by comparing their representatives.</p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Core Operations</h2>
                    <div class="section-content">
                        <ul>
                            <li><strong><code>MakeSet(x)</code>:</strong> Creates a new set containing only the element <code>x</code>. Element <code>x</code> becomes the representative of this new set.</li>
                            <li><strong><code>Find(x)</code>:</strong> Returns the representative of the set containing <code>x</code>. This operation is crucial for determining if two elements are in the same subset.</li>
                            <li><strong><code>Union(x, y)</code>:</strong> Merges the two (disjoint) sets containing elements <code>x</code> and <code>y</code> into a single new set. If <code>x</code> and <code>y</code> are already in the same set, the operation does nothing.</li>
                        </ul>
                    </div>
                </div>
                
                <div class="section">
                    <h2 class="section-title">Implementations & Optimizations</h2>
                    <div class="section-content">
                        <p>DSU is often implemented using a forest of trees, where each tree represents a set, and the root of the tree is the representative. An array (<code>parent[]</code>) is commonly used, where <code>parent[i]</code> stores the parent of element <code>i</code>. If <code>parent[i] == i</code>, then <code>i</code> is a root (representative).</p>
                        <p><strong>1. Simple Array (Naive Union & Find):</strong></p>
                        <ul>
                            <li><strong>Find:</strong> Traverse up from the element to its root. Can be O(N) in worst-case (skewed tree).</li>
                            <li><strong>Union:</strong> Find representatives of both elements. If different, make one root point to the other. Can lead to skewed trees.</li>
                        </ul>
                        <p><strong>2. Optimization: Union by Size/Rank:</strong></p>
                        <ul>
                            <li>During a <code>Union</code> operation, instead of arbitrarily making one root the child of another, make the root of the smaller tree (by number of nodes/size or by height/rank) a child of the root of the larger tree.</li>
                            <li>This helps keep the trees flatter, improving the performance of <code>Find</code>.</li>
                            <li><strong>Union by Size:</strong> Track the size of each set (number of nodes in the tree).
                            <li><strong>Union by Rank:</strong> Track the "rank" (an upper bound on the height) of each tree.</li>
                        </ul>
                        <p><strong>3. Optimization: Path Compression:</strong></p>
                        <ul>
                            <li>During a <code>Find(x)</code> operation, after finding the root, make all nodes along the path from <code>x</code> to the root point directly to the root.</li>
                            <li>This significantly flattens the tree structure over time, making subsequent <code>Find</code> operations much faster.</li>
                        </ul>
                        <p>When both Union by Size/Rank and Path Compression are used, the amortized time complexity for both <code>Union</code> and <code>Find</code> operations becomes nearly constant, specifically O(α(N)), where α(N) is the inverse Ackermann function, which grows extremely slowly (α(N) < 5 for any practical N).</p>
                    </div>
                </div>
                
                <div class="section">
                    <h2 class="section-title">Applications</h2>
                    <div class="section-content">
                        <ul>
                            <li><strong>Kruskal's Algorithm:</strong> For finding Minimum Spanning Trees (MST) in a graph. DSU is used to keep track of connected components of vertices and efficiently check if adding an edge forms a cycle.</li>
                            <li><strong>Cycle Detection in Undirected Graphs:</strong> If two vertices of an edge are already in the same set (their representatives are the same), adding that edge would form a cycle.</li>
                            <li><strong>Network Connectivity:</strong> Determining if nodes in a network are connected.</li>
                            <li>Image segmentation and percolation theory.</li>
                        </ul>
                    </div>
                </div>

                <div class="interactive-demo" id="disjoint-sets-interactive-demo">
                    <h3 style="margin-bottom: 1.5rem;">Disjoint Set (Union-Find) Visualizer</h3>
                    <p style="color: var(--gray-400); font-size:0.9em; margin-bottom:1rem;">Visualize MakeSet, Find, and Union operations. Elements are 0 to N-1.</p>
                    <div class="demo-controls" style="display: flex; flex-wrap: wrap; gap: 1rem; align-items: flex-end; margin-bottom: 1.5rem; padding: 1rem; background-color: var(--gray-800); border-radius: 12px;">
                        <div>
                            <label for="dsNumElements" style="font-size:0.9em; color:var(--gray-300); display:block; margin-bottom:0.25rem;">Number of Elements (N):</label>
                            <input type="number" id="dsNumElements" value="10" min="3" max="15" class="adt-input" style="width:100px;">
                        </div>
                         <button class="btn btn-sm" onclick="ds_initializeSets()"><i class="fas fa-users-cog"></i> Initialize Sets</button>
                        <div style="border-left: 2px solid var(--gray-700); padding-left:1rem; display:flex; flex-wrap:wrap; gap:1rem; align-items:flex-end;">
                            <div>
                                <label for="dsVal1" style="font-size:0.9em; color:var(--gray-300); display:block; margin-bottom:0.25rem;">Value 1 (0 to N-1):</label>
                                <input type="number" id="dsVal1" placeholder="X" class="adt-input" style="width:80px;">
                            </div>
                            <div>
                                <label for="dsVal2" style="font-size:0.9em; color:var(--gray-300); display:block; margin-bottom:0.25rem;">Value 2 (for Union):</label>
                                <input type="number" id="dsVal2" placeholder="Y" class="adt-input" style="width:80px;">
                            </div>
                            <button class="btn btn-sm btn-secondary" onclick="ds_unionVisual()"><i class="fas fa-link"></i> Union(X, Y)</button>
                            <button class="btn btn-sm btn-info" onclick="ds_findVisual()"><i class="fas fa-search"></i> Find(X)</button>
                        </div>
                    </div>

                    <div id="ds-visualization-area" style="min-height: 250px; background-color: var(--gray-900); border: 1px solid var(--gray-700); border-radius: 8px; padding: 1.5rem; display: flex; flex-wrap: wrap; align-items: flex-start; justify-content: center; gap: 20px; overflow: auto; position: relative;">
                        <div class="viz-placeholder" id="dsVizPlaceholder" style="text-align: center; width:100%;">
                            <i class="fas fa-sitemap" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i>
                            <span style="color: var(--gray-500);">Initialize sets to begin.</span>
                        </div>
                        </div>
                     <div id="ds-output-log" style="margin-top: 1rem; max-height: 100px; overflow-y: auto; background-color: var(--gray-800); border-radius: 8px; padding: 0.75rem; font-size: 0.85em; color: var(--gray-300); line-height: 1.5;">
                        Log: Operations and results will appear here...
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-python"># Python implementation of Disjoint Set Union with optimizations.</code></pre>
                </div>

                <div class="quiz-section">
                    <h3>Knowledge Check: Disjoint Sets</h3>
                    </div>
            </div>

            <div class="topic-content" id="graphs"> 
                <div class="content-header">
                    <h1 class="content-title">Graphs</h1>
                    <p class="content-subtitle">Non-linear data structures representing relationships between entities.</p>
                </div>

                <div class="section">
                    <h2 class="section-title">Understanding Graphs</h2>
                    <div class="section-content">
                        <p>A <strong>Graph</strong> is a non-linear data structure consisting of a collection of <strong>vertices (nodes)</strong> and <strong>edges</strong> that connect pairs of vertices. Graphs are used to represent relationships, networks, and connections between different entities.</p>
                        
                        <p><strong>Basic Graph Terminology:</strong></p>
                        <ul>
                            <li><strong>Vertex (Node):</strong> A fundamental unit that represents an entity in the graph.</li>
                            <li><strong>Edge:</strong> A connection between two vertices, representing a relationship.</li>
                            <li><strong>Adjacent Vertices:</strong> Two vertices connected by an edge are adjacent to each other.</li>
                            <li><strong>Degree:</strong> The number of edges connected to a vertex.</li>
                            <li><strong>Path:</strong> A sequence of vertices where each adjacent pair is connected by an edge.</li>
                            <li><strong>Cycle:</strong> A path that starts and ends at the same vertex.</li>
                            <li><strong>Connected Graph:</strong> A graph where there's a path between every pair of vertices.</li>
                        </ul>
                        
                        <p><strong>Real-world Applications:</strong> Social networks (friends/connections), transportation networks (roads, flights), computer networks (internet topology), dependency graphs (project tasks), recommendation systems, web page linking.</p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Types of Graphs</h2>
                    <div class="section-content">
                        <p><strong>1. Directed vs Undirected Graphs:</strong></p>
                        <ul>
                            <li><strong>Undirected Graph:</strong> Edges have no direction; if vertex A is connected to B, then B is also connected to A. Example: friendship relationships.</li>
                            <li><strong>Directed Graph (Digraph):</strong> Edges have direction; connection from A to B doesn't imply connection from B to A. Example: following relationships on social media.</li>
                        </ul>
                        
                        <p><strong>2. Weighted vs Unweighted Graphs:</strong></p>
                        <ul>
                            <li><strong>Unweighted Graph:</strong> All edges are considered equal (no weights/costs).</li>
                            <li><strong>Weighted Graph:</strong> Each edge has an associated weight/cost representing distance, time, or some other metric.</li>
                        </ul>
                        
                        <p><strong>3. Special Graph Types:</strong></p>
                        <ul>
                            <li><strong>Tree:</strong> A connected acyclic graph with exactly V-1 edges for V vertices.</li>
                            <li><strong>Complete Graph:</strong> Every pair of vertices is connected by an edge.</li>
                            <li><strong>Bipartite Graph:</strong> Vertices can be divided into two disjoint sets where edges only connect vertices from different sets.</li>
                            <li><strong>Cyclic/Acyclic Graph:</strong> Contains cycles or is cycle-free respectively.</li>
                        </ul>
                    </div>
                </div>
                
                <div class="section">
                    <h2 class="section-title">Graph Representations</h2>
                    <div class="section-content">
                        <p>Graphs can be represented in computer memory using different data structures, each with trade-offs:</p>
                        
                        <p><strong>1. Adjacency Matrix:</strong></p>
                        <ul>
                            <li>A 2D array where matrix[i][j] = 1 (or edge weight) if there's an edge from vertex i to vertex j.</li>
                            <li><strong>Pros:</strong> O(1) edge lookup, simple to implement, good for dense graphs.</li>
                            <li><strong>Cons:</strong> O(V²) space complexity regardless of edge count, inefficient for sparse graphs.</li>
                        </ul>
                        
                        <p><strong>2. Adjacency List:</strong></p>
                        <ul>
                            <li>An array/list where each index represents a vertex, and each element contains a list of adjacent vertices.</li>
                            <li><strong>Pros:</strong> O(V + E) space complexity, efficient for sparse graphs, easy to iterate over neighbors.</li>
                            <li><strong>Cons:</strong> O(V) time to check if specific edge exists (in worst case).</li>
                        </ul>
                        
                        <p><strong>3. Edge List:</strong></p>
                        <ul>
                            <li>A simple list of all edges, where each edge is represented as a pair (or tuple) of vertices.</li>
                            <li><strong>Pros:</strong> Simple, space-efficient for very sparse graphs.</li>
                            <li><strong>Cons:</strong> Inefficient for most graph operations, mainly used for specific algorithms.</li>
                        </ul>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Graph Traversal Algorithms</h2>
                    <div class="section-content">
                        <p>Graph traversal involves visiting all vertices in a systematic way. Two fundamental approaches:</p>
                        
                        <p><strong>1. Depth-First Search (DFS):</strong></p>
                        <ul>
                            <li>Explores as far as possible along each branch before backtracking.</li>
                            <li>Uses a stack (or recursion) to keep track of vertices to visit.</li>
                            <li><strong>Time Complexity:</strong> O(V + E), <strong>Space Complexity:</strong> O(V)</li>
                            <li><strong>Applications:</strong> Cycle detection, topological sorting, pathfinding, connected components.</li>
                        </ul>
                        
                        <p><strong>2. Breadth-First Search (BFS):</strong></p>
                        <ul>
                            <li>Explores all vertices at the current depth before moving to vertices at the next depth level.</li>
                            <li>Uses a queue to keep track of vertices to visit.</li>
                            <li><strong>Time Complexity:</strong> O(V + E), <strong>Space Complexity:</strong> O(V)</li>
                            <li><strong>Applications:</strong> Shortest path in unweighted graphs, level-order traversal, finding connected components.</li>
                        </ul>
                    </div>
                </div>

                <div class="interactive-demo" id="graphs-interactive-demo">
                    <h3 style="margin-bottom: 1.5rem;">Interactive Graph Builder & Traversal</h3>
                    
                    <div style="display: flex; flex-wrap: wrap; gap: 1.5rem; margin-bottom: 1.5rem;">
                        <!-- Graph Construction Controls -->
                        <div style="background-color:var(--gray-800); padding:1rem; border-radius:8px; flex: 1; min-width: 250px;">
                            <h4 style="color:var(--primary); margin-bottom:1rem;">Build Graph</h4>
                            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <input type="text" id="graphVertexInput" placeholder="Vertex (A-Z)" maxlength="1" style="width: 60px; text-transform: uppercase;">
                                    <button class="btn btn-sm" onclick="gr_addVertex()">Add Vertex</button>
                                </div>
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <input type="text" id="graphEdgeFrom" placeholder="From" maxlength="1" style="width: 50px; text-transform: uppercase;">
                                    <input type="text" id="graphEdgeTo" placeholder="To" maxlength="1" style="width: 50px; text-transform: uppercase;">
                                    <button class="btn btn-sm" onclick="gr_addEdge()">Add Edge</button>
                                </div>
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <label style="display: flex; align-items: center; gap: 0.3rem; font-size: 0.9em;">
                                        <input type="checkbox" id="graphDirected" onchange="gr_toggleDirected()"> Directed
                                    </label>
                                    <button class="btn btn-sm btn-warning" onclick="gr_clearGraph()">Clear All</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Traversal Controls -->
                        <div style="background-color:var(--gray-800); padding:1rem; border-radius:8px; flex: 1; min-width: 200px;">
                            <h4 style="color:var(--secondary); margin-bottom:1rem;">Traversal</h4>
                            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <input type="text" id="graphStartVertex" placeholder="Start" maxlength="1" style="width: 50px; text-transform: uppercase;">
                                    <button class="btn btn-sm" onclick="gr_runDFS()" style="background: var(--accent);">DFS</button>
                                    <button class="btn btn-sm" onclick="gr_runBFS()" style="background: var(--success);">BFS</button>
                                </div>
                                <button class="btn btn-sm btn-secondary" onclick="gr_resetTraversal()">Reset Colors</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Graph Visualization Area -->
                    <div id="gr-graph-visualization" style="min-height: 300px; background-color: var(--gray-900); border: 1px solid var(--gray-700); border-radius: 8px; padding: 1rem; position: relative; overflow: hidden;">
                        <div class="viz-placeholder" style="text-align: center; color: var(--gray-500); margin-top: 100px;">
                            <i class="fas fa-project-diagram" style="font-size: 3rem; margin-bottom: 1rem; display: block;"></i>
                            Add vertices and edges to build your graph
                        </div>
                    </div>
                    
                    <!-- Graph Info Panel -->
                    <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                        <div style="flex: 1; background-color: var(--gray-800); padding: 1rem; border-radius: 8px;">
                            <h5 style="color: var(--primary); margin-bottom: 0.5rem;">Graph Properties</h5>
                            <div id="gr-graph-info" style="font-size: 0.9em; color: var(--gray-300);">
                                Vertices: 0 | Edges: 0 | Type: Undirected
                            </div>
                        </div>
                        <div style="flex: 1; background-color: var(--gray-800); padding: 1rem; border-radius: 8px;">
                            <h5 style="color: var(--secondary); margin-bottom: 0.5rem;">Traversal Result</h5>
                            <div id="gr-traversal-result" style="font-size: 0.9em; color: var(--gray-300);">
                                Run DFS or BFS to see traversal order
                            </div>
                        </div>
                    </div>
                    
                    <!-- Activity Log -->
                    <div id="gr-output-log" style="margin-top: 1rem; max-height: 100px; overflow-y: auto; background-color: var(--dark); border:1px solid var(--gray-700); border-radius: 8px; padding: 0.75rem; font-size: 0.85em; color: var(--gray-300); line-height: 1.4;">
                        Graph Activity Log: Operations will be logged here...
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-python"># Python implementations for Graph data structure and algorithms.</code></pre>
                </div>

                <div class="quiz-section">
                    <h3>Knowledge Check: Graphs</h3>
                    <!-- Quiz questions will be dynamically populated here -->
                </div>
            </div>

            <div class="topic-content" id="sorting"> 
                <div class="content-header">
                    <h1 class="content-title">Sorting Algorithms</h1>
                    <p class="content-subtitle">Fundamental algorithms for organizing data in a specific order.</p>
                </div>

                <div class="section">
                    <h2 class="section-title">Introduction to Sorting</h2>
                    <div class="section-content">
                        <p>Sorting is one of the most fundamental problems in computer science - arranging data in a particular order (ascending or descending). Understanding sorting algorithms helps you grasp important concepts like time complexity, space complexity, and algorithm design paradigms.</p>
                        <p><strong>Why Sorting Matters:</strong></p>
                        <ul>
                            <li><strong>Searching Efficiency:</strong> Sorted data enables binary search (O(log n)) instead of linear search (O(n))</li>
                            <li><strong>Data Organization:</strong> Makes data more readable and manageable for humans</li>
                            <li><strong>Algorithm Building Block:</strong> Many algorithms require sorted input or use sorting as a subroutine</li>
                            <li><strong>Database Operations:</strong> Critical for database indexing and query optimization</li>
                        </ul>
                        <p><strong>Key Properties of Sorting Algorithms:</strong></p>
                        <ul>
                            <li><strong>Stability:</strong> Maintains relative order of equal elements</li>
                            <li><strong>In-place:</strong> Sorts with O(1) extra space</li>
                            <li><strong>Adaptive:</strong> Performs better on nearly sorted data</li>
                            <li><strong>Online:</strong> Can sort data as it arrives</li>
                        </ul>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Comparison-Based Sorting</h2>
                    <div class="section-content">
                        <p><strong>Bubble Sort (O(n²)):</strong> Repeatedly steps through the list, compares adjacent elements and swaps them if they're in wrong order. Simple but inefficient for large datasets.</p>
                        <p><strong>Selection Sort (O(n²)):</strong> Finds the minimum element and places it at the beginning, then repeats for the remaining unsorted portion.</p>
                        <p><strong>Insertion Sort (O(n²)):</strong> Builds the sorted array one element at a time by inserting each element in its correct position. Efficient for small datasets and nearly sorted arrays.</p>
                        <p><strong>Merge Sort (O(n log n)):</strong> Divide-and-conquer algorithm that divides the array into halves, sorts them recursively, then merges the sorted halves. Stable and guaranteed O(n log n) performance.</p>
                        <p><strong>Quick Sort (O(n log n) average, O(n²) worst):</strong> Selects a pivot element, partitions the array around it, then recursively sorts the partitions. Generally faster than merge sort in practice.</p>
                        <p><strong>Heap Sort (O(n log n)):</strong> Builds a max heap from the array, then repeatedly extracts the maximum element to build the sorted array.</p>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title">Non-Comparison Sorting</h2>
                    <div class="section-content">
                        <p>These algorithms don't compare elements directly and can achieve linear time complexity under specific conditions:</p>
                        <p><strong>Counting Sort (O(n + k)):</strong> Counts occurrences of each distinct element, where k is the range of input. Works well when the range is not significantly larger than the number of elements.</p>
                        <p><strong>Radix Sort (O(d × (n + k))):</strong> Sorts integers by processing individual digits, where d is the number of digits. Uses a stable sorting algorithm (like counting sort) as a subroutine.</p>
                        <p><strong>Bucket Sort (O(n + k)):</strong> Distributes elements into buckets, sorts individual buckets, then concatenates them. Effective when input is uniformly distributed.</p>
                    </div>
                </div>

                <div class="interactive-demo" id="sorting-interactive-demo">
                    <h3 style="margin-bottom: 1.5rem;">Sorting Algorithm Visualizer</h3>
                    
                    <div style="display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 1.5rem; align-items: center;">
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <label for="sortingAlgorithm" style="color: var(--gray-300);">Algorithm:</label>
                            <select id="sortingAlgorithm" style="padding: 0.5rem; background: var(--gray-800); color: var(--white); border: 1px solid var(--gray-600); border-radius: 4px;">
                                <option value="bubble">Bubble Sort</option>
                                <option value="selection">Selection Sort</option>
                                <option value="insertion">Insertion Sort</option>
                                <option value="merge">Merge Sort</option>
                                <option value="quick">Quick Sort</option>
                            </select>
                        </div>
                        
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <label for="arraySize" style="color: var(--gray-300);">Size:</label>
                            <input type="range" id="arraySize" min="5" max="20" value="10" style="width: 100px;">
                            <span id="arraySizeValue" style="color: var(--accent);">10</span>
                        </div>
                        
                        <button class="btn btn-sm" onclick="sort_generateArray()"><i class="fas fa-random"></i> New Array</button>
                        <button class="btn btn-sm" onclick="sort_startSorting()"><i class="fas fa-play"></i> Sort</button>
                        <button class="btn btn-sm btn-secondary" onclick="sort_resetDemo()"><i class="fas fa-stop"></i> Reset</button>
                    </div>

                    <div id="sorting-visualization" style="background: var(--gray-900); border: 1px solid var(--gray-700); border-radius: 8px; padding: 1rem; min-height: 200px; display: flex; align-items: end; justify-content: center; gap: 2px;">
                        <span class="viz-placeholder" style="color: var(--gray-500);">Click 'New Array' to generate data</span>
                    </div>

                    <div style="margin-top: 1rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem;">
                        <div style="font-size: 0.9em;">
                            <span style="color: var(--gray-300);">Comparisons: </span>
                            <span id="sortComparisons" style="color: var(--accent); font-weight: bold;">0</span>
                            <span style="color: var(--gray-300); margin-left: 1rem;">Swaps: </span>
                            <span id="sortSwaps" style="color: var(--accent); font-weight: bold;">0</span>
                        </div>
                        <div style="font-size: 0.9em;">
                            <span style="color: var(--gray-300);">Status: </span>
                            <span id="sortStatus" style="color: var(--gray-400);">Ready</span>
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-python"># Python implementations of common sorting algorithms</code></pre>
                </div>

                <div class="quiz-section">
                    <h3>Knowledge Check: Sorting Algorithms</h3>
                    <!-- Quiz questions will be dynamically populated here -->
                </div>
            </div>

            <div class="topic-content" id="dynamic-programming">
                <div class="content-header">
                    <h1 class="content-title">Dynamic Programming</h1>
                    <p class="content-subtitle">Optimization technique for solving complex problems</p>
                </div>
                
                <div class="section">
                    <h2 class="section-title">Core Concepts</h2>
                    <div class="section-content">
                        <p>[Content about overlapping subproblems, optimal substructure, memoization vs tabulation]</p>
                    </div>
                </div>
                
                <div class="interactive-demo">
                    <h3>DP Problem Solver</h3>
                    <div class="demo-controls">
                        <button class="btn" onclick="solveDP('fibonacci')">Fibonacci</button>
                        <button class="btn" onclick="solveDP('knapsack')">0/1 Knapsack</button>
                        <button class="btn" onclick="solveDP('lcs')">LCS</button>
                        <button class="btn btn-secondary" onclick="toggleMemoization()">Toggle Memoization</button>
                    </div>
                    <div class="visualization" id="dp-viz">
                        <div class="viz-placeholder">
                            <i class="fas fa-chess" style="font-size: 3rem; margin-bottom: 1rem; display: block;"></i>
                            Visualize dynamic programming solutions
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        // Global state management
        const appState = {
            currentTopic: 'welcome',
            completedTopics: new Set([]),
            progress: 0,
            demos: {},
            quizScores: {}
        };

        // Topic data structure for easy content management
        const topicData = {
            'data-types': {
                title: 'Python Data Types',
                description: 'Understanding fundamental data types and their operations',
                sections: ['overview', 'primitive-types', 'collections', 'operations'],
                exercises: 5,
                difficulty: 'beginner'
            },
            'adts': {
                title: 'Abstract Data Types',
                description: 'Understanding ADTs and their implementation in Python',
                sections: ['concepts', 'interfaces', 'implementations', 'examples'],
                exercises: 4,
                difficulty: 'intermediate'
            },
            'big-o': {
                title: 'Big-O, Ω, Θ Notation',
                description: 'Asymptotic notation for algorithm analysis',
                sections: ['notation-types', 'analysis', 'examples', 'comparison'],
                exercises: 6,
                difficulty: 'intermediate'
            },
            'sorting': {
                title: 'Sorting Algorithms',
                description: 'Comprehensive coverage of sorting techniques',
                sections: ['comparison-sorts', 'non-comparison', 'analysis', 'applications'],
                exercises: 8,
                difficulty: 'advanced'
            },
            'dynamic-programming': {
                title: 'Dynamic Programming',
                description: 'Optimization technique for solving complex problems',
                sections: ['principles', 'patterns', 'optimization', 'problems'],
                exercises: 10,
                difficulty: 'advanced'
            }
            // Additional topics would be defined here...
        };

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
            setupEventListeners();
            updateProgress();
            if (typeof loadDataTypesContent === 'function') {
                loadDataTypesContent(); // Load content for the data types topic
            }
            if (typeof loadAdtsContent === 'function') {
                loadAdtsContent();
            }
            if (typeof loadRuntimeAnalysisContent === 'function') {
                loadRuntimeAnalysisContent();
            }
            if (typeof loadBigOContent === 'function') {
                loadBigOContent();
            }
            if (typeof loadAsymptoticContent === 'function') {
                loadAsymptoticContent();
            }
            if (typeof loadMasterTheoremContent === 'function') {
                loadMasterTheoremContent();
                const asymSlider = document.getElementById('asymptoticN');
                const asymSpan = document.getElementById('asymptoticNValue');
                if (asymSlider && asymSpan) {
                    asymSlider.addEventListener('input', () => {
                        asymSpan.textContent = asymSlider.value;
                    });
                }
            }
            if (typeof loadAmortizedAnalysisContent === 'function') {
                loadAmortizedAnalysisContent();
                window.aa_appendItem = aa_appendItem;
                window.aa_resetDemo = aa_resetDemo;
            }
            if (typeof loadRecursionBacktrackingContent === 'function') {
                loadRecursionBacktrackingContent();
                window.rb_runSelectedDemo = rb_runSelectedDemo;
                window.rb_resetDemoArea = rb_resetDemoArea;
            }
            if (typeof loadLinkedListContent === 'function') {
                loadLinkedListContent();
                window.ll_addNodeVisual = ll_addNodeVisual;
                window.ll_removeNodeVisual = ll_removeNodeVisual;
                window.ll_resetDemo = ll_resetDemo;
            }
            if (typeof loadStacksQueuesContent === 'function') {
                loadStacksQueuesContent();
                window.sq_pushVisual = sq_pushVisual;
                window.sq_popVisual = sq_popVisual;
                window.sq_enqueueVisual = sq_enqueueVisual;
                window.sq_dequeueVisual = sq_dequeueVisual;
                window.sq_resetDemos = sq_resetDemos;
            }
            if (typeof loadTreesHeapsContent === 'function') {
                loadTreesHeapsContent();
                window.th_handleBstOperation = th_handleBstOperation;
                window.th_handleHeapOperation = th_handleHeapOperation;
                window.th_resetCurrentDemo = th_resetCurrentDemo;
            }
            if (typeof loadDisjointSetsContent === 'function') {
                loadDisjointSetsContent();
                window.ds_initializeSets = ds_initializeSets;
                window.ds_unionVisual = ds_unionVisual;
                window.ds_findVisual = ds_findVisual;
            }
            if (typeof loadGraphsContent === 'function') {
                loadGraphsContent();
            }
            if (typeof loadSortingContent === 'function') {
                loadSortingContent();
                window.sort_generateArray = sort_generateArray;
                window.sort_startSorting = sort_startSorting;
                window.sort_resetDemo = sort_resetDemo;
            }
        });

        function initializeApp() {
            // Set up initial state
            showTopic('welcome');
            updateProgress();
            
            // Add scroll effect to header
            window.addEventListener('scroll', function() {
                const header = document.getElementById('header');
                if (window.scrollY > 100) {
                    header.classList.add('scrolled');
                } else {
                    header.classList.remove('scrolled');
                }
            });
        }

        function setupEventListeners() {
            // Topic navigation
            const topicLinks = document.querySelectorAll('.topic-link');
            topicLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const topicId = this.getAttribute('data-topic');
                    showTopic(topicId);
                    updateActiveLink(this);
                });
            });

            // Mobile menu toggle
            const mobileMenuBtn = document.getElementById('mobileMenuBtn');
            if (mobileMenuBtn) {
                mobileMenuBtn.addEventListener('click', toggleMobileMenu);
            }

            // Quiz interactions
            setupQuizListeners();
        }
        //  1, DATA TYPES ---------------------------------------------------------------------
        function loadDataTypesContent() {
            const topicId = 'data-types';

            // 1. Add Code Example
            const codeExample = `
                # Numeric Types
                integer_var = 100
                float_var = 20.5
                complex_var = 1 + 2j # Complex numbers

                print(f"Integer: {integer_var}, Type: {type(integer_var)}")
                print(f"Float: {float_var}, Type: {type(float_var)}")
                print(f"Complex: {complex_var}, Type: {type(complex_var)}")

                # Boolean Type
                is_active = True
                is_admin = False
                print(f"Boolean 'is_active': {is_active}, Type: {type(is_active)}")

                # String Type (Immutable, Ordered sequence of characters)
                course_name = "DSA Mastery"
                first_char = course_name[0] # Accessing characters by index
                # course_name[0] = 'd' # This would cause a TypeError because strings are immutable
                print(f"String: '{course_name}', First character: '{first_char}', Type: {type(course_name)}")

                # List Type (Mutable, Ordered sequence of items)
                my_list = [10, "Python", 3.14, True, [1, 2]]
                my_list.append("new_item") # Add item to the end
                my_list[1] = "JavaScript" # Modify an item
                print(f"List: {my_list}, Length: {len(my_list)}, Type: {type(my_list)}")

                # Tuple Type (Immutable, Ordered sequence of items)
                my_tuple = (100, "Immutable Data", 200.5)
                # my_tuple[0] = 50 # This would raise a TypeError
                print(f"Tuple: {my_tuple}, Element at index 1: {my_tuple[1]}, Type: {type(my_tuple)}")

                # Set Type (Mutable, Unordered collection of unique items)
                my_set = {1, 2, 2, 3, "apple", "banana", "apple"}
                my_set.add(4) # Add a new element
                print(f"Set: {my_set}, Type: {type(my_set)}") # Duplicates are automatically removed

                # Dictionary Type (Mutable, Unordered (Python <3.7) / Ordered (Python 3.7+) key-value pairs)
                student_info = {
                    "name": "Alex",
                    "age": 21,
                    "courses": ["Math", "Physics", "DSA"]
                }
                student_info["grade"] = "A" # Add a new key-value pair
                student_info["age"] = 22 # Update existing value
                print(f"Dictionary: {student_info}")
                print(f"Student's name: {student_info['name']}, Type: {type(student_info)}")

                # NoneType
                no_value = None
                print(f"NoneType variable: {no_value}, Type: {type(no_value)}")
            `;
            if (window.dsaContent && typeof window.dsaContent.addCodeExample === 'function') {
                window.dsaContent.addCodeExample(topicId, codeExample);
            } else {
                console.error('dsaContent.addCodeExample function not found. Code example not added for data-types.');
            }


            const dataTypesQuizSet = [
                {
                    questionText: "Which Python data type is characterized by being an ordered and immutable sequence of items?",
                    options: ["List", "Set", "Tuple", "Dictionary"],
                    correctOptionIndex: 2
                },
                {
                    questionText: "What is the primary characteristic of a Python <code>set</code>?",
                    options: ["Ordered and mutable", "Unordered and allows duplicates", "Ordered and immutable", "Unordered and contains only unique items"],
                    correctOptionIndex: 3
                },
                {
                    questionText: "How would you create an empty dictionary in Python?",
                    options: ["<code>[]</code>", "<code>()</code>", "<code>{}</code> or <code>dict()</code>", "<code>set()</code>"],
                    correctOptionIndex: 2
                },
                {
                    questionText: "Which of the following operations would typically raise a <code>TypeError</code> if attempted on a string <code>s = \"hello\"</code>?",
                    options: ["<code>s.upper()</code>", "<code>len(s)</code>", "<code>s[0] = \"H\"</code>", "<code>s + \" world\"</code>"],
                    correctOptionIndex: 2
                },
                {
                    questionText: "Consider <code>my_list = [10, 20, 30]</code>. What does <code>my_list.append(40)</code> do?",
                    options: ["Returns a new list with 40 added", "Modifies <code>my_list</code> in-place to become <code>[10, 20, 30, 40]</code>", "Raises an error because lists are immutable", "Adds 40 at the beginning of the list"],
                    correctOptionIndex: 1
                }
            ];
            if (window.dsaContent && typeof window.dsaContent.updateQuiz === 'function') {
                window.dsaContent.updateQuiz(topicId, dataTypesQuizSet);
            } else {
                console.error('dsaContent.updateQuiz function not found. Quiz not updated for data-types.');
            }
        }

        function analyzeDataTypeInput() {
            const inputElement = document.getElementById('dataTypeInput');
            const outputElement = document.getElementById('dataTypeOutput');
            if (!inputElement || !outputElement) {
                console.error("Data Type Explorer UI elements not found.");
                outputElement.innerHTML = '<p style="color: var(--error);">Error: UI elements missing. Cannot analyze.</p>';
                return;
            }

            const inputValue = inputElement.value.trim();
            // Clear previous output and add a touch of animation
            outputElement.style.opacity = '0';
            setTimeout(() => {
                outputElement.innerHTML = ''; // Clear previous output

                if (inputValue === '') {
                    outputElement.innerHTML = '<p style="color: var(--warning);">Please enter a Python literal to analyze.</p>';
                    outputElement.style.opacity = '1';
                    return;
                }

                let type = 'Unknown';
                let properties = [];
                let examples = [];
                let notes = []; // For additional context or Python-specific details

                // Infer type (simplified client-side parsing)
                if ((inputValue.startsWith('"') && inputValue.endsWith('"')) || (inputValue.startsWith("'") && inputValue.endsWith("'"))) {
                    type = 'String (str)';
                    properties = ['Ordered: Yes', 'Mutable: No (Immutable)'];
                    examples = ['Concatenation: <code>"Hi" + " " + "There"</code> &rarr; <code>"Hi There"</code>', 'Slicing: <code>"Python"[1:4]</code> &rarr; <code>"yth"</code>', 'Methods: <code>.upper()</code>, <code>.find()</code>, <code>.split()</code>'];
                    notes = ['Strings store sequences of Unicode characters.'];
                } else if (inputValue.toLowerCase() === 'true') {
                    type = 'Boolean (bool)';
                    properties = ['Value: <code>True</code>', 'Mutable: No (Immutable)'];
                    notes = ['Represents logical true. Python booleans are <code>True</code> and <code>False</code> (case-sensitive).'];
                } else if (inputValue.toLowerCase() === 'false') {
                    type = 'Boolean (bool)';
                    properties = ['Value: <code>False</code>', 'Mutable: No (Immutable)'];
                    notes = ['Represents logical false. Python booleans are <code>True</code> and <code>False</code> (case-sensitive).'];
                } else if (inputValue.toLowerCase() === 'none') {
                    type = 'NoneType';
                    properties = ['Value: <code>None</code>', 'Mutable: No (Immutable)'];
                    notes = ['Represents the absence of a value. Python keyword is <code>None</code> (case-sensitive).'];
                } else if (/^-?\d+$/.test(inputValue)) {
                    type = 'Integer (int)';
                    properties = ['Represents: Whole numbers', 'Mutable: No (Immutable)', 'Precision: Arbitrary'];
                    examples = ['Arithmetic: <code>10 + 5</code> &rarr; <code>15</code>', '<code>10 // 3</code> &rarr; <code>3</code> (floor division)'];
                } else if (/^-?\d*(\.\d+)?(e[-+]?\d+)?$/i.test(inputValue) && inputValue.match(/[.eE]/)) { // Improved float check
                    if (!isNaN(parseFloat(inputValue))) {
                        type = 'Floating-Point (float)';
                        properties = ['Represents: Real numbers', 'Mutable: No (Immutable)'];
                        examples = ['Arithmetic: <code>3.14 * 2.0</code> &rarr; <code>6.28</code>', 'Scientific: <code>1.2e-5</code> &rarr; <code>0.000012</code>'];
                    }
                } else if (inputValue.startsWith('[') && inputValue.endsWith(']')) {
                    type = 'List (list)';
                    properties = ['Ordered: Yes', 'Mutable: Yes', 'Allows Duplicates: Yes'];
                    examples = ['Access: <code>my_list[0]</code>', 'Append: <code>my_list.append(value)</code>', 'Slicing: <code>my_list[1:3]</code>'];
                    notes = ['Can hold items of mixed data types. Example: <code>[1, "apple", True]</code>'];
                } else if (inputValue.startsWith('(') && inputValue.endsWith(')')) {
                    type = 'Tuple (tuple)';
                    properties = ['Ordered: Yes', 'Mutable: No (Immutable)', 'Allows Duplicates: Yes'];
                    examples = ['Access: <code>my_tuple[0]</code>', 'Common for fixed collections like coordinates: <code>(10, 20)</code>'];
                    if (inputValue.includes(',') || inputValue === '()') {
                        notes = ['Single element tuple needs a comma: <code>(item,)</code>. Empty tuple: <code>()</code>'];
                    } else {
                        notes = ['<code>(item)</code> is just <code>item</code> with parentheses for precedence. For a single element tuple, use a trailing comma: <code>(item,)</code>.'];
                    }
                } else if (inputValue.startsWith('{') && inputValue.endsWith('}')) {
                    if (inputValue === '{}') {
                        type = 'Dictionary (dict)';
                        properties = ['Ordered: Yes (Python 3.7+)', 'Mutable: Yes', 'Stores: Key-value pairs'];
                        notes = ['This is an empty dictionary.'];
                    } else if (inputValue.includes(':')) {
                        type = 'Dictionary (dict)';
                        properties = ['Ordered: Yes (Python 3.7+)', 'Mutable: Yes', 'Stores: Key-value pairs'];
                        examples = ['Access: <code>my_dict["key"]</code>', 'Add/Update: <code>my_dict["new_key"] = value</code>'];
                        notes = ['Keys must be unique and immutable. Example: <code>{"name": "Ada", "age": 30}</code>'];
                    } else {
                        type = 'Set (set)';
                        properties = ['Ordered: No', 'Mutable: Yes', 'Stores: Unique items'];
                        examples = ['Add: <code>my_set.add(item)</code>', 'Union: <code>set1 | set2</code>'];
                        notes = ['Example: <code>{1, "apple", 3.14}</code>. An empty set is created with <code>set()</code>, as <code>{}</code> creates an empty dictionary.'];
                    }
                }

                let outputHTML = `<h4 style="color: var(--primary); margin-bottom: 0.75rem;">Analysis for: <code style="background: var(--gray-700); padding: 2px 5px; border-radius: 4px;">${escapeHtml(inputValue)}</code></h4>`;
                outputHTML += `<p style="margin-bottom: 0.5rem;"><strong>Detected Type:</strong> <span style="color: var(--secondary); font-weight: bold;">${type}</span></p>`;

                if (properties.length > 0) {
                    outputHTML += '<p style="margin-bottom: 0.25rem; color: var(--gray-200);"><strong>Key Properties:</strong></p><ul style="list-style-type: disc; margin-left: 20px; margin-bottom: 1rem; color: var(--gray-300);">';
                    properties.forEach(prop => { outputHTML += `<li>${prop}</li>`; });
                    outputHTML += '</ul>';
                }

                if (examples.length > 0) {
                    outputHTML += '<p style="margin-bottom: 0.25rem; color: var(--gray-200);"><strong>Common Operations/Examples:</strong></p><ul style="list-style-type: disc; margin-left: 20px; margin-bottom: 1rem; color: var(--gray-300);">';
                    examples.forEach(ex => { outputHTML += `<li>${ex}</li>`; });
                    outputHTML += '</ul>';
                }
                
                if (notes.length > 0) {
                    outputHTML += '<p style="margin-bottom: 0.25rem; color: var(--gray-200);"><strong>Notes:</strong></p><ul style="list-style-type: circle; margin-left: 20px; margin-bottom: 1rem; color: var(--gray-400); font-style: italic;">';
                    notes.forEach(note => { outputHTML += `<li>${note}</li>`; });
                    outputHTML += '</ul>';
                }

                if (type === 'Unknown') {
                    outputHTML += '<p style="color: var(--warning);">Could not reliably determine the data type. Please use standard Python literal syntax (e.g., <code>"text"</code>, <code>123</code>, <code>[1,2]</code>, <code>{"a":1}</code>, <code>True</code>, <code>None</code>).</p>';
                }
                outputElement.innerHTML = outputHTML;
                outputElement.style.opacity = '1';
            }, 100); // Short delay for the opacity transition
        }

        //  2, ADTs --------------------------------------------------------------------------
        let currentAdtDemo = null; // 'stack', 'queue', 'set', or 'map'
        let adtData = null; // Holds the items for the current ADT. Will be Array, Set, or Map.

        function loadAdtsContent() {
            const topicId = 'adts';

            // Code Examples for ADTs (Including Set and Map conceptual interfaces)
            const adtCodeExamples = `
        # --- Stack ADT Implementation (using Python list) ---
        class Stack:
            def __init__(self):
                self._items = []
            def push(self, item): self._items.append(item)
            def pop(self):
                if not self.is_empty(): return self._items.pop()
                raise IndexError("pop from empty stack")
            def peek(self):
                if not self.is_empty(): return self._items[-1]
                raise IndexError("peek from empty stack")
            def is_empty(self): return len(self._items) == 0
            def size(self): return len(self._items)
            def __str__(self): return f"Stack: {self._items}"

        # --- Queue ADT Implementation (using Python list) ---
        # Note: Using list.pop(0) for dequeue is inefficient (O(N)).
        class Queue:
            def __init__(self): self._items = []
            def enqueue(self, item): self._items.append(item)
            def dequeue(self):
                if not self.is_empty(): return self._items.pop(0)
                raise IndexError("dequeue from empty queue")
            def front(self):
                if not self.is_empty(): return self._items[0]
                raise IndexError("front from empty queue")
            def is_empty(self): return len(self._items) == 0
            def size(self): return len(self._items)
            def __str__(self): return f"Queue (front to rear): {self._items}"

        # --- Set ADT (Conceptual Interface - Python's built-in 'set' is an implementation) ---
        # Operations:
        # add(item): Adds an item to the set. If the item is already present, the set is unchanged.
        # remove(item): Removes an item from the set. Raises KeyError if item not found.
        # discard(item): Removes an item if present, does nothing otherwise.
        # is_member(item) / item in set: Checks if an item is in the set.
        # union(other_set): Returns a new set with elements from both sets.
        # intersection(other_set): Returns a new set with elements common to both sets.
        # difference(other_set): Returns a new set with elements in this set but not in the other.
        # is_empty(): Checks if the set is empty.
        # size(): Returns the number of items in the set.

        # --- Map ADT (Dictionary/Associative Array - Python's 'dict' is an implementation) ---
        # Operations:
        # put(key, value) / map[key] = value: Adds a key-value pair or updates value if key exists.
        # get(key) / map[key]: Retrieves the value associated with a key. Raises KeyError if not found.
        # remove(key) / del map[key]: Removes the key-value pair. Raises KeyError if not found.
        # contains_key(key) / key in map: Checks if a key exists.
        # is_empty(): Checks if the map is empty.
        # size(): Returns the number of key-value pairs.
        # keys(): Returns a view of all keys.
        # values(): Returns a view of all values.
        # items(): Returns a view of all key-value pairs.

        # Python's built-in types are powerful implementations of these ADTs:
        # my_set = {1, 2, 3}
        # my_map = {'a': 10, 'b': 20}
            `;
            if (window.dsaContent && typeof window.dsaContent.addCodeExample === 'function') {
                window.dsaContent.addCodeExample(topicId, adtCodeExamples);
            }

            // Quiz Questions for ADTs (remains the same as previous step)
            const adtsQuizSet = [
                {
                    questionText: "What is the primary focus of an Abstract Data Type (ADT)?",
                    options: ["The specific programming language used.", "The underlying hardware.", "The logical properties and operations, independent of implementation.", "The efficiency of the algorithm in Big-O notation."],
                    correctOptionIndex: 2
                },
                {
                    questionText: "Which principle best describes the benefit of separating an ADT's interface from its implementation?",
                    options: ["Inheritance", "Polymorphism", "Abstraction (Information Hiding)", "Compilation"],
                    correctOptionIndex: 2
                },
                {
                    questionText: "A Stack ADT follows which principle for adding and removing elements?",
                    options: ["FIFO (First-In, First-Out)", "LIFO (Last-In, First-Out)", "Random Access", "Priority Based"],
                    correctOptionIndex: 1
                },
                {
                    questionText: "If you need to implement a system where tasks are processed in the order they arrive, which ADT would be most suitable?",
                    options: ["Stack", "Set", "Queue", "Map"],
                    correctOptionIndex: 2
                },
                {
                    questionText: "Changing the internal data structure of an ADT (e.g., from an array to a linked list for a List ADT) should not affect the client code if:",
                    options: ["The client code is written in the same language.", "The ADT's interface remains unchanged.", "The new data structure is more memory efficient.", "The client recompiles their code."],
                    correctOptionIndex: 1
                }
            ];
            if (window.dsaContent && typeof window.dsaContent.updateQuiz === 'function') {
                window.dsaContent.updateQuiz(topicId, adtsQuizSet);
            }
        }

        function setupAdtControls(adtType) {
            const controlsArea = document.getElementById('adt-controls-area');
            const messageArea = document.getElementById('adt-message-area');
            if (!controlsArea || !messageArea) return;

            messageArea.innerHTML = ''; // Clear previous messages
            controlsArea.innerHTML = ''; // Clear previous controls

            currentAdtDemo = adtType; // Set current demo type early

            if (adtType === 'stack') {
                controlsArea.innerHTML = `
                    <input type="text" id="adtValueInput" placeholder="Enter value" class="adt-input">
                    <button class="btn btn-sm" onclick="handleAdtOperation('push')">Push</button>
                    <button class="btn btn-sm btn-secondary" onclick="handleAdtOperation('pop')">Pop</button>
                    <button class="btn btn-sm btn-warning" onclick="handleAdtOperation('peek')">Peek</button>
                `;
                adtData = [];
            } else if (adtType === 'queue') {
                controlsArea.innerHTML = `
                    <input type="text" id="adtValueInput" placeholder="Enter value" class="adt-input">
                    <button class="btn btn-sm" onclick="handleAdtOperation('enqueue')">Enqueue</button>
                    <button class="btn btn-sm btn-secondary" onclick="handleAdtOperation('dequeue')">Dequeue</button>
                    <button class="btn btn-sm btn-warning" onclick="handleAdtOperation('front')">Front</button>
                `;
                adtData = [];
            } else if (adtType === 'set') {
                controlsArea.innerHTML = `
                    <input type="text" id="adtValueInput" placeholder="Enter value" class="adt-input">
                    <button class="btn btn-sm" onclick="handleAdtOperation('add')">Add</button>
                    <button class="btn btn-sm btn-secondary" onclick="handleAdtOperation('remove')">Remove</button>
                    <button class="btn btn-sm btn-warning" onclick="handleAdtOperation('has')">Has</button>
                `;
                adtData = new Set();
            } else if (adtType === 'map') {
                controlsArea.innerHTML = `
                    <input type="text" id="adtKeyInput" placeholder="Enter key" class="adt-input" style="min-width: 100px; margin-right: 5px;">
                    <input type="text" id="adtValueInput" placeholder="Enter value" class="adt-input" style="min-width: 100px;">
                    <button class="btn btn-sm" onclick="handleAdtOperation('put')">Put</button>
                    <button class="btn btn-sm btn-secondary" onclick="handleAdtOperation('get')">Get</button>
                    <button class="btn btn-sm btn-danger" onclick="handleAdtOperation('delete')">Delete Key</button>
                `;
                adtData = new Map();
            }
            updateAdtVisualization();
        }

        function handleAdtOperation(operation) {
            const valueInput = document.getElementById('adtValueInput');
            const keyInput = document.getElementById('adtKeyInput'); // For Map
            const messageArea = document.getElementById('adt-message-area');
            let value = valueInput ? valueInput.value.trim() : null;
            let key = keyInput ? keyInput.value.trim() : null;
            messageArea.innerHTML = ''; // Clear previous messages

            try {
                if (currentAdtDemo === 'stack') {
                    // Stack operations (unchanged from previous version)
                    switch (operation) {
                        case 'push':
                            if (!value) { messageArea.innerHTML = '<span class="adt-message-error">Please enter a value to push.</span>'; return; }
                            adtData.push(value);
                            if (valueInput) valueInput.value = '';
                            break;
                        case 'pop':
                            if (adtData.length === 0) { messageArea.innerHTML = '<span class="adt-message-error">Stack is empty. Cannot pop.</span>'; return; }
                            const poppedValue = adtData.pop();
                            messageArea.innerHTML = `<span class="adt-message-success">Popped: ${escapeHtml(poppedValue)}</span>`;
                            break;
                        case 'peek':
                            if (adtData.length === 0) { messageArea.innerHTML = '<span class="adt-message-error">Stack is empty. Cannot peek.</span>'; return; }
                            messageArea.innerHTML = `<span class="adt-message-info">Peek: ${escapeHtml(adtData[adtData.length - 1])}</span>`;
                            break;
                    }
                } else if (currentAdtDemo === 'queue') {
                    // Queue operations (unchanged from previous version)
                    switch (operation) {
                        case 'enqueue':
                            if (!value) { messageArea.innerHTML = '<span class="adt-message-error">Please enter a value to enqueue.</span>'; return; }
                            adtData.push(value);
                            if (valueInput) valueInput.value = '';
                            break;
                        case 'dequeue':
                            if (adtData.length === 0) { messageArea.innerHTML = '<span class="adt-message-error">Queue is empty. Cannot dequeue.</span>'; return; }
                            const dequeuedValue = adtData.shift();
                            messageArea.innerHTML = `<span class="adt-message-success">Dequeued: ${escapeHtml(dequeuedValue)}</span>`;
                            break;
                        case 'front':
                            if (adtData.length === 0) { messageArea.innerHTML = '<span class="adt-message-error">Queue is empty. Cannot see front.</span>'; return; }
                            messageArea.innerHTML = `<span class="adt-message-info">Front: ${escapeHtml(adtData[0])}</span>`;
                            break;
                    }
                } else if (currentAdtDemo === 'set') {
                    switch (operation) {
                        case 'add':
                            if (!value) { messageArea.innerHTML = '<span class="adt-message-error">Please enter a value to add.</span>'; return; }
                            if (adtData.has(value)) {
                                messageArea.innerHTML = `<span class="adt-message-info">Value "${escapeHtml(value)}" already in set.</span>`;
                            } else {
                                adtData.add(value);
                                messageArea.innerHTML = `<span class="adt-message-success">Added "${escapeHtml(value)}" to set.</span>`;
                            }
                            if (valueInput) valueInput.value = '';
                            break;
                        case 'remove':
                            if (!value) { messageArea.innerHTML = '<span class="adt-message-error">Please enter a value to remove.</span>'; return; }
                            if (adtData.has(value)) {
                                adtData.delete(value);
                                messageArea.innerHTML = `<span class="adt-message-success">Removed "${escapeHtml(value)}" from set.</span>`;
                            } else {
                                messageArea.innerHTML = `<span class="adt-message-error">Value "${escapeHtml(value)}" not found in set.</span>`;
                            }
                            if (valueInput) valueInput.value = '';
                            break;
                        case 'has':
                            if (!value) { messageArea.innerHTML = '<span class="adt-message-error">Please enter a value to check.</span>'; return; }
                            if (adtData.has(value)) {
                                messageArea.innerHTML = `<span class="adt-message-info">Set contains "${escapeHtml(value)}".</span>`;
                            } else {
                                messageArea.innerHTML = `<span class="adt-message-info">Set does not contain "${escapeHtml(value)}".</span>`;
                            }
                            break;
                    }
                } else if (currentAdtDemo === 'map') {
                    switch (operation) {
                        case 'put':
                            if (!key) { messageArea.innerHTML = '<span class="adt-message-error">Please enter a key.</span>'; return; }
                            // Value can be empty for map, treated as an empty string.
                            adtData.set(key, value || ""); // Store empty string if value is null/empty
                            messageArea.innerHTML = `<span class="adt-message-success">Put key "${escapeHtml(key)}" with value "${escapeHtml(value || "")}".</span>`;
                            if (keyInput) keyInput.value = '';
                            if (valueInput) valueInput.value = '';
                            break;
                        case 'get':
                            if (!key) { messageArea.innerHTML = '<span class="adt-message-error">Please enter a key to get.</span>'; return; }
                            if (adtData.has(key)) {
                                const retrievedValue = adtData.get(key);
                                messageArea.innerHTML = `<span class="adt-message-info">Value for key "${escapeHtml(key)}": "${escapeHtml(retrievedValue)}"</span>`;
                            } else {
                                messageArea.innerHTML = `<span class="adt-message-error">Key "${escapeHtml(key)}" not found in map.</span>`;
                            }
                            break;
                        case 'delete':
                            if (!key) { messageArea.innerHTML = '<span class="adt-message-error">Please enter a key to delete.</span>'; return; }
                            if (adtData.has(key)) {
                                adtData.delete(key);
                                messageArea.innerHTML = `<span class="adt-message-success">Deleted key "${escapeHtml(key)}" from map.</span>`;
                            } else {
                                messageArea.innerHTML = `<span class="adt-message-error">Key "${escapeHtml(key)}" not found in map.</span>`;
                            }
                            if (keyInput) keyInput.value = '';
                            break;
                    }
                }
            } catch (e) {
                messageArea.innerHTML = `<span class="adt-message-error">Error: ${e.message}</span>`;
            }
            updateAdtVisualization();
        }

        function updateAdtVisualization() {
            const vizArea = document.getElementById('adts-viz');
            if (!vizArea) return;

            vizArea.innerHTML = ''; // Clear previous visualization
            vizArea.style.border = '2px dashed var(--gray-600)';
            vizArea.style.padding = '1rem';
            vizArea.style.flexWrap = 'wrap'; // Allow wrapping for Set and Map items

            if ((currentAdtDemo === 'stack' || currentAdtDemo === 'queue') && adtData.length === 0) {
                let emptyMessage = currentAdtDemo ? `${currentAdtDemo.charAt(0).toUpperCase() + currentAdtDemo.slice(1)} is empty.` : 'Select an ADT to visualize.';
                vizArea.innerHTML = `<p style="color: var(--gray-500); width: 100%; text-align: center;">${emptyMessage}</p>`;
                return;
            } else if ((currentAdtDemo === 'set' || currentAdtDemo === 'map') && adtData.size === 0) {
                let emptyMessage = currentAdtDemo ? `${currentAdtDemo.charAt(0).toUpperCase() + currentAdtDemo.slice(1)} is empty.` : 'Select an ADT to visualize.';
                vizArea.innerHTML = `<p style="color: var(--gray-500); width: 100%; text-align: center;">${emptyMessage}</p>`;
                return;
            }


            if (currentAdtDemo === 'stack') {
                vizArea.style.flexDirection = 'column-reverse';
                vizArea.style.alignItems = 'center';
                adtData.forEach((item, index) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'adt-item stack-item';
                    itemDiv.textContent = escapeHtml(item);
                    if (index === adtData.length - 1) {
                        itemDiv.innerHTML += ' <span class="adt-item-label">(Top)</span>';
                    }
                    vizArea.appendChild(itemDiv);
                });
            } else if (currentAdtDemo === 'queue') {
                vizArea.style.flexDirection = 'row';
                vizArea.style.justifyContent = 'flex-start';
                vizArea.style.alignItems = 'center';
                adtData.forEach((item, index) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'adt-item queue-item';
                    if (index === 0) {
                        itemDiv.innerHTML = `<span class="adt-item-label">(Front)</span> ${escapeHtml(item)}`;
                    } else {
                        itemDiv.textContent = escapeHtml(item);
                    }
                    if (index === adtData.length - 1 && adtData.length > 0) { // Check length > 0 to avoid label on empty queue if logic changes
                        itemDiv.innerHTML += ` <span class="adt-item-label">(Rear)</span>`;
                    }
                    vizArea.appendChild(itemDiv);
                    if (index < adtData.length - 1) {
                        const arrow = document.createElement('span');
                        arrow.innerHTML = '&rarr;';
                        arrow.className = 'adt-arrow';
                        vizArea.appendChild(arrow);
                    }
                });
            } else if (currentAdtDemo === 'set') {
                vizArea.style.flexDirection = 'row'; // Display items in a row, wrap if needed
                vizArea.style.justifyContent = 'center';
                vizArea.style.alignItems = 'center';
                if (adtData.size === 0) {
                    vizArea.innerHTML = `<p style="color: var(--gray-500);">Set is empty.</p>`;
                } else {
                    adtData.forEach(item => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'adt-item set-item';
                        itemDiv.textContent = escapeHtml(item);
                        vizArea.appendChild(itemDiv);
                    });
                }
            } else if (currentAdtDemo === 'map') {
                vizArea.style.flexDirection = 'row';
                vizArea.style.justifyContent = 'center';
                vizArea.style.alignItems = 'flex-start'; // Align items to the top for better key-value pair appearance
                if (adtData.size === 0) {
                    vizArea.innerHTML = `<p style="color: var(--gray-500);">Map is empty.</p>`;
                } else {
                    adtData.forEach((value, key) => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'adt-item map-item';
                        itemDiv.innerHTML = `<span class="map-key">${escapeHtml(key)}</span>: <span class="map-value">${escapeHtml(value)}</span>`;
                        vizArea.appendChild(itemDiv);
                    });
                }
            }
        }

        const originalRunDemo = window.runDemo; // Keep reference if it's already extended
        window.runDemo = function(demoType) {
            const messageArea = document.getElementById('adt-message-area');
            if (messageArea) messageArea.innerHTML = '';

            if (['adts-stack', 'adts-queue', 'adts-set', 'adts-map'].includes(demoType)) {
                const adtSimpleType = demoType.split('-')[1]; // 'stack', 'queue', 'set', 'map'
                setupAdtControls(adtSimpleType);
            } else {
                if (originalRunDemo && typeof originalRunDemo === 'function' && originalRunDemo !== window.runDemo) {
                    originalRunDemo(demoType);
                } else {
                    const viz = document.getElementById(`${demoType}-viz`) || document.getElementById(demoType);
                    if (viz) {
                        viz.innerHTML = `<div class="viz-placeholder">Demo for ${demoType} not specifically implemented yet.</div>`;
                    }
                }
            }
        };

        const originalResetDemo = window.resetDemo; // Keep reference
        window.resetDemo = function(demoType) {
            if (demoType === 'adts') {
                const vizArea = document.getElementById('adts-viz');
                const controlsArea = document.getElementById('adt-controls-area');
                const messageArea = document.getElementById('adt-message-area');

                if (vizArea) {
                    vizArea.innerHTML = `
                        <div class="viz-placeholder">
                            <i class="fas fa-cubes" style="font-size: 3rem; margin-bottom: 1rem; display: block;"></i>
                            Select an ADT to start the interactive demo.
                        </div>`;
                    vizArea.style.flexDirection = 'column';
                    vizArea.style.border = '2px dashed var(--gray-600)';
                    vizArea.style.flexWrap = 'nowrap'; // Reset wrap
                }
                if (controlsArea) controlsArea.innerHTML = '';
                if (messageArea) messageArea.innerHTML = '';
                currentAdtDemo = null;
                adtData = null; // Reset data for any type
            } else {
                if (originalResetDemo && typeof originalResetDemo === 'function' && originalResetDemo !== window.resetDemo) {
                    originalResetDemo(demoType);
                }
            }
        };

        const adtItemStyle = document.head.querySelector('#adt-styles') || document.createElement('style');
        adtItemStyle.id = 'adt-styles'; // Add an ID to find it for updates
        adtItemStyle.innerHTML = `
            .adt-item {
                background-color: var(--primary-dark);
                color: var(--white);
                padding: 0.8rem 1.2rem;
                border: 1px solid var(--primary);
                border-radius: 8px;
                margin: 0.4rem; /* Increased margin for better separation */
                text-align: center;
                min-width: 70px; /* Slightly increased min-width */
                box-shadow: 0 2px 5px rgba(0,0,0,0.25);
                transition: transform 0.2s ease, box-shadow 0.2s ease;
                display: inline-block; /* For set/map items to flow */
            }
            .adt-item:hover {
                transform: translateY(-2px) scale(1.03);
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            }
            .stack-item { width: 80%; max-width: 220px; display: block; } /* Stack items are block */
            .queue-item { /* No specific width, let content define */ }
            .set-item { background-color: var(--secondary-dark); border-color: var(--secondary); }
            .map-item { background-color: var(--accent-dark); border-color: var(--accent); padding: 0.6rem 1rem; }
            .map-key { font-weight: bold; color: var(--gray-100); }
            .map-value { color: var(--gray-200); }
            .adt-item-label { font-size:0.75em; color:var(--gray-400); display: block; margin-top: 3px; }
            .stack-item .adt-item-label { display: inline; margin-left: 5px;} /* Top label inline for stack */
            .queue-item .adt-item-label { font-size:0.75em; color:var(--gray-400); margin: 0 3px; } /* Front/Rear labels */
            .adt-arrow { margin: 0 8px; color: var(--gray-500); font-size: 1.2em; }
            .adt-input {
                padding: 0.6rem 0.8rem; /* Standardized padding */
                border-radius: 6px;
                border: 1px solid var(--gray-600);
                background: var(--gray-800);
                color: var(--white);
                margin-right: 8px; /* Spacing between inputs/buttons */
                margin-bottom: 5px; /* Spacing for wrapping */
                min-width: 120px;
            }
            .adt-message-error { color: var(--error); font-weight: bold; }
            .adt-message-success { color: var(--success); font-weight: bold; }
            .adt-message-info { color: var(--primary-dark); font-weight: bold; }

            #adts-viz {
                display: flex; /* Ensure flex is set */
                min-height: 150px; /* Adjusted min-height */
                gap: 0.5rem; /* Gap between flex items */
            }
        `;
        if (!document.head.querySelector('#adt-styles')) {
            document.head.appendChild(adtItemStyle);
        }

        //  3, Runtime Analysis -----------------------------------------------------------------
        const raSnippets = {
            constant: {
                name: "Constant: O(1)",
                code: `
        def get_array_element(arr, index):
            # Accessing an element by index (if valid)
            # or a fixed number of arithmetic operations.
            if 0 <= index < len(arr):
                return arr[index] # 1 operation (access)
            return None # 1 operation (return)
        # Operations: Approx. 1-2, regardless of n.`,
                operationFunc: (n) => 1, // Simplified to 1 key operation
                complexity: "T(n) ≈ 1 (Constant)",
                animationType: 'constant'
            },
            linear_sum: {
                name: "Linear: O(n) - Sum Array",
                code: `
        def sum_array(arr):
            total = 0
            for x in arr: # Loop n times
                total += x # 1 operation (addition + assignment)
            return total
        # Operations: Approx. n additions.`,
                operationFunc: (n) => n,
                complexity: "T(n) ≈ n (Linear)",
                animationType: 'linear'
            },
            linear_search_worst: {
                name: "Linear: O(n) - Search (Worst)",
                code: `
        def linear_search_worst_case(arr, target):
            for x in arr: # Loop n times
                if x == target: # 1 op (comparison)
                    return True
            return False
        # Operations: Approx. n comparisons in worst case.`,
                operationFunc: (n) => n,
                complexity: "T(n) ≈ n (Linear)",
                animationType: 'linear'
            },
            n_div_2_loop: {
                name: "Linear: O(n) - Loop n/2",
                code: `
        def loop_half_n(n_val):
            count = 0
            for _ in range(n_val // 2): # Loop n/2 times
                count += 1 # 1 operation
            return count
        # Operations: Approx. n/2. Still O(n).`,
                operationFunc: (n) => Math.floor(n / 2),
                complexity: "T(n) ≈ n/2 (Linear)",
                animationType: 'linear_partial' // Special handling for n/2
            },
            logarithmic_i_doubles: {
                name: "Logarithmic: O(log n)",
                code: `
        def logarithmic_loop(n_val):
            count = 0
            i = 1
            while i < n_val: # Loop log2(n) times
                i *= 2       # 1 operation
                count += 1
            return count
        # Operations: Approx. log2(n).`,
                operationFunc: (n) => (n <= 1 ? 1 : Math.floor(Math.log2(n))),
                complexity: "T(n) ≈ log n (Logarithmic)",
                animationType: 'logarithmic'
            },
            nlogn_conceptual: {
                name: "N log N: O(n log n) - Conceptual",
                code: `
        def n_log_n_algorithm(n_val):
            # Represents algorithms like efficient sorting (Merge Sort, Heap Sort).
            # Conceptually: log n levels of processing, each doing n work.
            if n_val <= 1: return 1
            operations = 0
            # Outer loop representing log n phases
            temp_n = n_val
            while temp_n > 1:
                # Inner loop representing n operations per phase
                for _ in range(n_val): # Simplified: always n_val for inner
                    operations += 1
                temp_n //= 2
            return operations
        # Operations: Approx. n * log2(n).`,
                operationFunc: (n) => (n <= 1 ? 1 : Math.max(1, Math.round(n * (Math.log2(n) > 0 ? Math.log2(n) : 1) ))),
                complexity: "T(n) ≈ n log n (Log-linear)",
                animationType: 'nlogn'
            },
            quadratic_nested_simple: {
                name: "Quadratic: O(n²) - Simple Nested",
                code: `
        def simple_nested_loops(n_val):
            count = 0
            for _ in range(n_val):      # Loop n times
                for _ in range(n_val):  # Loop n times
                    count += 1          # 1 operation
            return count
        # Operations: n * n = n^2.`,
                operationFunc: (n) => n * n,
                complexity: "T(n) ≈ n² (Quadratic)",
                animationType: 'quadratic'
            },
            quadratic_dependent_nested: {
                name: "Quadratic: O(n²) - Dependent Nested",
                code: `
        def dependent_nested_loops(n_val):
            count = 0
            for i in range(n_val):      # Loop n times
                for _ in range(i + 1):  # Loop ~i times (0 to i)
                    count += 1          # 1 operation
            return count
        # Operations: Sum of 1 to n = n*(n+1)/2. Approx. n^2/2. Still O(n^2).`,
                operationFunc: (n) => (n * (n + 1)) / 2,
                complexity: "T(n) ≈ n²/2 (Quadratic)",
                animationType: 'quadratic_triangle'
            }
            // Add more snippets here if desired
        };

        function populateRaSnippetSelect() {
            const selectElement = document.getElementById('raSnippetSelect');
            if (!selectElement) return;
            selectElement.innerHTML = ''; // Clear existing options

            for (const key in raSnippets) {
                if (raSnippets.hasOwnProperty(key)) {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = raSnippets[key].name;
                    selectElement.appendChild(option);
                }
            }
        }

        function loadRuntimeAnalysisContent() {
            const topicId = 'runtime-analysis';
            populateRaSnippetSelect(); // Populate dropdown

            // Code Examples for Runtime Analysis (remains the same as your provided version)
            const raCodeExamples = `
        # Example 1: Constant Time O(1)
        def get_first_item(my_list):
            if not my_list:
                return None
            return my_list[0] # Accessing by index is typically O(1)

        # Example 2: Linear Time O(n)
        def sum_list_items(my_list):
            total = 0
            for item in my_list: # Loop runs 'n' times, where n is len(my_list)
                total += item    # Constant time operation inside loop
            return total

        # Example 3: Quadratic Time O(n^2)
        def find_duplicates_simple(my_list):
            n = len(my_list)
            duplicates_found = 0
            for i in range(n):          # Outer loop runs n times
                for j in range(i + 1, n): # Inner loop runs up to n-1 times
                    if my_list[i] == my_list[j]: # Constant time comparison
                        duplicates_found +=1
            return duplicates_found

        # Example 4: Logarithmic Time O(log n) - Binary Search (conceptual)
        def conceptual_binary_search_runtime(n_items):
            # In binary search, the search space is halved in each step.
            pass

        # Analyzing a slightly more complex loop
        def analyze_this(n):
            count = 0
            i = 1
            while i < n: count += 1; i *= 2 # log_2(n) times
            for j in range(n // 2): count +=1 # n/2 times
            return count # O(n)
            `;
            if (window.dsaContent && typeof window.dsaContent.addCodeExample === 'function') {
                window.dsaContent.addCodeExample(topicId, raCodeExamples);
            }

            // Quiz Questions for Runtime Analysis (remains the same)
            const raQuizSet = [
                { questionText: "What is the primary goal of runtime analysis in the context of algorithms?", options: ["To measure the exact execution time in milliseconds.", "To determine how resource usage scales with input size.", "To prove mathematical correctness of an algorithm.", "To choose the easiest algorithm to implement."], correctOptionIndex: 1 },
                { questionText: "If an algorithm performs <code>5n + 10</code> basic operations for an input of size 'n', its runtime is generally considered to be proportional to:", options: ["<code>n<sup>2</sup></code>", "<code>5</code>", "<code>n</code>", "<code>log n</code>"], correctOptionIndex: 2 },
                { questionText: "Which type of analysis usually provides the most reliable guarantee on an algorithm's performance?", options: ["Best-case analysis", "Average-case analysis", "Worst-case analysis", "Amortized analysis"], correctOptionIndex: 2 },
                { questionText: "Consider a single loop: <code>for i in range(n): print(i)</code>. How many print operations are performed?", options: ["1", "n", "n<sup>2</sup>", "log n"], correctOptionIndex: 1 },
                { questionText: "An operation that takes the same amount of time regardless of the input size is said to have:", options: ["Linear runtime", "Quadratic runtime", "Logarithmic runtime", "Constant runtime"], correctOptionIndex: 3 }
            ];
            if (window.dsaContent && typeof window.dsaContent.updateQuiz === 'function') {
                window.dsaContent.updateQuiz(topicId, raQuizSet);
            }

            const snippetSelect = document.getElementById('raSnippetSelect');
            if (snippetSelect) {
                updateRaCodeDisplay(snippetSelect.value);
                snippetSelect.addEventListener('change', (event) => {
                    updateRaCodeDisplay(event.target.value);
                    const vizArea = document.getElementById('ra-viz');
                    const analysisOutput = document.getElementById('ra-analysis-output');
                    if (vizArea) vizArea.innerHTML = '<div class="viz-placeholder" style="text-align: center;"><i class="fas fa-cogs" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i><span style="color: var(--gray-500);">Animation of operations will appear here.</span></div>';
                    if (analysisOutput) analysisOutput.innerHTML = '';
                });
            }
        }

        function updateRaCodeDisplay(snippetKey) {
            const codeDisplay = document.getElementById('raCodeSnippet');
            if (codeDisplay && raSnippets[snippetKey]) {
                codeDisplay.textContent = raSnippets[snippetKey].code;
                if (window.Prism) {
                    Prism.highlightElement(codeDisplay);
                }
            }
        }

        let raAnimationTimeoutId = null; // To cancel ongoing animations

        async function runRaDemo() {
            if (raAnimationTimeoutId) {
                clearTimeout(raAnimationTimeoutId);
                raAnimationTimeoutId = null;
            }

            const snippetKey = document.getElementById('raSnippetSelect').value;
            const inputSizeN = parseInt(document.getElementById('raInputSize').value);
            const vizArea = document.getElementById('ra-viz');
            const analysisOutput = document.getElementById('ra-analysis-output');
            const animationContainer = document.getElementById('ra-animation-container');

            vizArea.innerHTML = ''; // Clear previous visualization
            animationContainer.style.borderColor = 'var(--gray-700)'; // Reset border

            if (!raSnippets[snippetKey] || isNaN(inputSizeN) || inputSizeN < 1 || inputSizeN > 50) { // Max N for animation
                vizArea.innerHTML = '<p style="color: var(--error); text-align: center;">Invalid selection or input size (must be 1-50 for animation).</p>';
                analysisOutput.innerHTML = '';
                return;
            }

            const snippet = raSnippets[snippetKey];
            const numOperations = snippet.operationFunc(inputSizeN); // Theoretical ops
            analysisOutput.innerHTML = `Input n = ${inputSizeN}. Complexity: ${snippet.complexity}. Approx. Theoretical Operations: <strong style="color:var(--success);">${numOperations}</strong>`;

            let animatedOpsCount = 0;
            const opCounterDisplay = document.createElement('div');
            opCounterDisplay.id = 'raOpCounter';
            opCounterDisplay.style.position = 'absolute';
            opCounterDisplay.style.top = '10px';
            opCounterDisplay.style.right = '10px';
            opCounterDisplay.style.padding = '5px 10px';
            opCounterDisplay.style.background = 'rgba(0,0,0,0.5)';
            opCounterDisplay.style.color = 'var(--white)';
            opCounterDisplay.style.borderRadius = '5px';
            opCounterDisplay.style.fontSize = '0.9em';
            opCounterDisplay.textContent = `Animated Ops: 0`;
            animationContainer.appendChild(opCounterDisplay); // Add to animation container

            const delay = Math.max(10, 200 / Math.sqrt(Math.max(inputSizeN, numOperations, 10))); // Faster for more ops/n
            
            // Function to create a visual "operation" element
            function createOpElement(x, y, isData = false) {
                const opEl = document.createElement('div');
                opEl.classList.add('ra-op-element');
                opEl.style.width = isData ? '12px' : '8px';
                opEl.style.height = isData ? '12px' : '8px';
                opEl.style.backgroundColor = isData ? 'var(--secondary)' : 'var(--accent)';
                opEl.style.borderRadius = isData ? '3px' : '50%';
                opEl.style.position = 'absolute';
                opEl.style.left = `${x}px`;
                opEl.style.top = `${y}px`;
                opEl.style.opacity = '0';
                opEl.style.transform = 'scale(0.5)';
                opEl.style.transition = `opacity 0.3s ease, transform 0.3s ease`;
                vizArea.appendChild(opEl);
                // Trigger reflow for transition
                void opEl.offsetWidth;
                opEl.style.opacity = '1';
                opEl.style.transform = 'scale(1)';
                if (!isData) {
                    animatedOpsCount++;
                    opCounterDisplay.textContent = `Animated Ops: ${animatedOpsCount}`;
                }
                return opEl;
            }
            
            // Display 'n' data elements first
            const dataElements = [];
            const vizWidth = vizArea.clientWidth - 20; // Usable width
            const spacing = Math.min(20, vizWidth / (inputSizeN + 1));
            for (let i = 0; i < inputSizeN; i++) {
                const x = 10 + (i + 0.5) * spacing;
                const y = 20;
                dataElements.push(createOpElement(x, y, true));
                await new Promise(resolve => raAnimationTimeoutId = setTimeout(resolve, delay / 5));
            }


            switch (snippet.animationType) {
                case 'constant':
                    createOpElement(vizWidth / 2, 60);
                    break;
                case 'linear':
                case 'linear_partial':
                    const limit = snippet.animationType === 'linear_partial' ? Math.floor(inputSizeN / 2) : inputSizeN;
                    for (let i = 0; i < limit; i++) {
                        if (dataElements[i]) dataElements[i].style.backgroundColor = 'var(--primary)';
                        createOpElement(10 + (i + 0.5) * spacing, 60);
                        await new Promise(resolve => raAnimationTimeoutId = setTimeout(resolve, delay));
                        if (dataElements[i]) dataElements[i].style.backgroundColor = 'var(--secondary)';
                    }
                    break;
                case 'logarithmic':
                    let currentN = inputSizeN;
                    let currentElements = [...dataElements];
                    let yOffset = 60;
                    while (currentN >= 1) {
                        createOpElement(vizWidth / 2, yOffset); // One op per "level"
                        // Visually "halve" elements (just an indication)
                        currentElements.forEach((el, idx) => {
                            if (idx >= Math.floor(currentElements.length / 2)) el.style.opacity = '0.3';
                        });
                        currentElements = currentElements.slice(0, Math.floor(currentElements.length / 2));
                        currentN = Math.floor(currentN / 2);
                        yOffset += 20;
                        await new Promise(resolve => raAnimationTimeoutId = setTimeout(resolve, delay * 2));
                        if (currentN < 1 && currentElements.length === 1) break; // Avoid infinite loop for n=1
                        if (currentN < 1 && currentElements.length === 0 && inputSizeN > 0) break;


                    }
                    break;
                case 'quadratic':
                case 'quadratic_triangle':
                    let opY = 60;
                    for (let i = 0; i < inputSizeN; i++) {
                        if (dataElements[i]) dataElements[i].style.backgroundColor = 'var(--primary-dark)';
                        const innerLoopLimit = snippet.animationType === 'quadratic_triangle' ? i + 1 : inputSizeN;
                        for (let j = 0; j < innerLoopLimit; j++) {
                            createOpElement(10 + (j + 0.5) * spacing, opY);
                            await new Promise(resolve => raAnimationTimeoutId = setTimeout(resolve, delay / 2));
                        }
                        opY += 15;
                        if (opY > vizArea.clientHeight - 20) { // Prevent overflow
                            vizArea.innerHTML += '<p style="color:var(--warning);font-size:0.8em;text-align:center;width:100%;">Animation truncated due to space.</p>';
                            i = inputSizeN; // break outer loop
                        }
                        if (dataElements[i]) dataElements[i].style.backgroundColor = 'var(--secondary)';
                    }
                    break;
                case 'nlogn': // Simplified: show log N passes, each with N ops
                    let passY = 60;
                    let tempN_nlogn = inputSizeN;
                    while (tempN_nlogn >= 1) {
                        // Indicate a "pass" or "level"
                        const passMarker = createOpElement(vizWidth/2 - 20, passY - 5, true);
                        passMarker.style.backgroundColor = 'var(--gray-500)';
                        passMarker.style.width = '40px';
                        passMarker.style.height = '3px';

                        for (let i = 0; i < inputSizeN; i++) { // N operations per pass
                            createOpElement(10 + (i + 0.5) * spacing, passY + 10);
                            await new Promise(resolve => raAnimationTimeoutId = setTimeout(resolve, delay / 3));
                        }
                        passY += 30;
                        tempN_nlogn = Math.floor(tempN_nlogn / 2);
                        if (passY > vizArea.clientHeight - 30) {
                            vizArea.innerHTML += '<p style="color:var(--warning);font-size:0.8em;text-align:center;width:100%;">Animation truncated.</p>';
                            break;
                        }
                        if (tempN_nlogn < 1 && inputSizeN > 0) break;
                    }
                    break;
                default:
                    vizArea.innerHTML = '<p style="color: var(--warning); text-align:center;">Animation type not implemented.</p>';
            }
            
            // Final "Done" indication
            animationContainer.style.borderColor = 'var(--success)';
            raAnimationTimeoutId = setTimeout(() => {
                if (opCounterDisplay && opCounterDisplay.parentNode) {
                    opCounterDisplay.parentNode.removeChild(opCounterDisplay);
                }
            }, 2000 + delay * 5); // Remove counter after a bit
        }

        const raAnimStyle = document.createElement('style');
        raAnimStyle.id = 'ra-animation-styles';
        raAnimStyle.innerHTML = `
        .ra-op-element {
            /* Base styles set in JS, this is for potential overrides or shared classes */
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        #ra-animation-container {
            transition: border-color 0.5s ease;
        }
        `;
        if (!document.head.querySelector('#ra-animation-styles')) {
            document.head.appendChild(raAnimStyle);
        }
        
        //  4, Big-O Notations -----------------------------------------------------------------
        function loadBigOContent(){
            const topicId = 'big-o';
            const bigOQuizSet = [
                {
                    questionText: "What does Big-O notation primarily describe?",
                    options: [
                        "The best-case runtime of an algorithm.",
                        "The average memory usage of an algorithm.",
                        "The worst-case growth rate of an algorithm’s running time or space.",
                        "The exact number of operations an algorithm performs."
                    ],
                    correctOptionIndex: 2
                },
                {
                    questionText: "If f(n) = 3n² + 5n + 10, which term determines f(n) in Big-O notation?",
                    options: [
                        "10",
                        "5n",
                        "3n²",
                        "None, because Big-O can’t be applied here."
                    ],
                    correctOptionIndex: 2
                },
                {
                    questionText: "Which notation gives a lower bound on an algorithm’s growth?",
                    options: [
                        "Big-O (O)",
                        "Big-Omega (Ω)",
                        "Big-Theta (Θ)",
                        "Little-o (o)"
                    ],
                    correctOptionIndex: 1
                },
                {
                    questionText: "Merge Sort has which tight bound (Θ) on its time complexity?",
                    options: [
                        "Θ(n)",
                        "Θ(n log n)",
                        "Θ(n²)",
                        "Θ(log n)"
                    ],
                    correctOptionIndex: 1
                },
                {
                    questionText: "When combining f(n) = n and g(n) = log n, what is f(n) + g(n) in Big-O?",
                    options: [
                        "O(log n)",
                        "O(n log n)",
                        "O(n)",
                        "O(n + log n) (no simplification possible)"
                    ],
                    correctOptionIndex: 2
                }
            ];
            if (window.dsaContent && typeof window.dsaContent.updateQuiz === 'function') {
                window.dsaContent.updateQuiz(topicId, bigOQuizSet);
            }
        }
        
        function updateGrowthChart() {
            const slider = document.getElementById('inputSizeSlider');
            const valueSpan = document.getElementById('inputSizeValue');
            const canvas = document.getElementById('growthChart');
            
            if (!slider || !valueSpan || !canvas) return;
            
            const n = parseInt(slider.value);
            valueSpan.textContent = n;
            
            drawGrowthChart(n);
            updateGrowthTable(n);
        }

        function drawGrowthChart(maxN) {
            const canvas = document.getElementById('growthChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, 0, width, height);
            
            // Functions to plot
            const functions = [
                { name: 'O(1)', color: '#10b981', fn: n => 1 },
                { name: 'O(log n)', color: '#3b82f6', fn: n => Math.log2(n) },
                { name: 'O(n)', color: '#8b5cf6', fn: n => n },
                { name: 'O(n log n)', color: '#f59e0b', fn: n => n * Math.log2(n) },
                { name: 'O(n²)', color: '#ef4444', fn: n => n * n },
                { name: 'O(2ⁿ)', color: '#dc2626', fn: n => Math.min(Math.pow(2, n), 1000000) }
            ];
            
            // Find max value for scaling
            let maxValue = 0;
            for (let i = 1; i <= maxN; i++) {
                functions.forEach(func => {
                    const value = func.fn(i);
                    if (value > maxValue && value < 1000000) maxValue = value;
                });
            }
            
            // Draw grid
            ctx.strokeStyle = '#4b5563';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = (i / 10) * width;
                const y = (i / 10) * height;
                
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Draw functions
            functions.forEach(func => {
                ctx.strokeStyle = func.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                let firstPoint = true;
                for (let n = 1; n <= maxN; n++) {
                    const value = func.fn(n);
                    if (value > 1000000) break;
                    
                    const x = (n / maxN) * width;
                    const y = height - (value / maxValue) * height;
                    
                    if (firstPoint) {
                        ctx.moveTo(x, y);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            });
            
            // Draw legend
            const legendX = 10;
            let legendY = 20;
            ctx.font = '12px Inter';
            
            functions.forEach(func => {
                ctx.fillStyle = func.color;
                ctx.fillRect(legendX, legendY, 15, 15);
                ctx.fillStyle = '#ffffff';
                ctx.fillText(func.name, legendX + 20, legendY + 12);
                legendY += 25;
            });
        }

        function updateGrowthTable(n) {
            const tableContainer = document.getElementById('growth-table');
            if (!tableContainer) return;
            
            const functions = [
                { name: 'O(1)', fn: n => 1 },
                { name: 'O(log n)', fn: n => Math.log2(n) },
                { name: 'O(n)', fn: n => n },
                { name: 'O(n log n)', fn: n => n * Math.log2(n) },
                { name: 'O(n²)', fn: n => n * n },
                { name: 'O(2ⁿ)', fn: n => Math.pow(2, Math.min(n, 20)) }
            ];
            
            let tableHTML = `
                <div class="growth-table">
                    <table>
                        <thead>
                            <tr>
                                <th>n</th>
                                ${functions.map(f => `<th>${f.name}</th>`).join('')}
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            for (let i = 1; i <= Math.min(n, 20); i++) {
                tableHTML += `<tr><td>${i}</td>`;
                functions.forEach(func => {
                    const value = func.fn(i);
                    const displayValue = value > 1000000 ? '∞' : 
                                        value > 1000 ? Math.round(value).toLocaleString() :
                                        Math.round(value * 100) / 100;
                    tableHTML += `<td>${displayValue}</td>`;
                });
                tableHTML += '</tr>';
            }
            
            tableHTML += `
                        </tbody>
                    </table>
                </div>
            `;
            
            tableContainer.innerHTML = tableHTML;
        }

        function animateGrowth() {
            const slider = document.getElementById('inputSizeSlider');
            if (!slider) return;
            
            let currentValue = 1;
            const maxValue = 50;
            const interval = setInterval(() => {
                slider.value = currentValue;
                updateGrowthChart();
                currentValue += 1;
                
                if (currentValue > maxValue) {
                    clearInterval(interval);
                }
            }, 100);
        }

        function resetGrowthDemo() {
            const slider = document.getElementById('inputSizeSlider');
            if (slider) {
                slider.value = 10;
                updateGrowthChart();
            }
        }

        function analyzeComplexity(algorithmType) {
            const vizArea = document.getElementById('complexity-viz');
            if (!vizArea) return;
            
            const algorithms = {
                'single-loop': {
                    name: 'Single Loop',
                    code: `def process_array(arr):
            for i in range(len(arr)):  # Loop runs n times
                print(arr[i])          # O(1) operation
            return "Done"              # O(1) operation`,
                    steps: [
                        'The outer loop runs exactly n times, where n is the length of the array',
                        'Inside the loop, we have a print statement which is O(1)',
                        'After the loop, we return a string which is also O(1)',
                        'Total: n × O(1) + O(1) = O(n)'
                    ],
                    complexity: 'O(n)',
                    explanation: 'Linear time complexity because we visit each element exactly once.'
                },
                'nested-loops': {
                    name: 'Nested Loops',
                    code: `def find_pairs(arr):
            pairs = []
            for i in range(len(arr)):      # Outer loop: n times
                for j in range(len(arr)):  # Inner loop: n times
                    if i != j:
                        pairs.append((arr[i], arr[j]))  # O(1)
            return pairs`,
                    steps: [
                        'The outer loop runs n times',
                        'For each iteration of the outer loop, the inner loop runs n times',
                        'The operation inside the nested loops is O(1)',
                        'Total iterations: n × n = n²',
                        'Therefore, time complexity is O(n²)'
                    ],
                    complexity: 'O(n²)',
                    explanation: 'Quadratic time complexity due to nested loops over the same input.'
                },
                'binary-search': {
                    name: 'Binary Search',
                    code: `def binary_search(arr, target):
            left, right = 0, len(arr) - 1
            while left <= right:           # Runs log₂(n) times
                mid = (left + right) // 2  # O(1)
                if arr[mid] == target:     # O(1)
                    return mid
                elif arr[mid] < target:    # O(1)
                    left = mid + 1         # Eliminate half
                else:
                    right = mid - 1        # Eliminate half
            return -1`,
                    steps: [
                        'Each iteration eliminates half of the remaining search space',
                        'Starting with n elements, we get: n → n/2 → n/4 → ... → 1',
                        'Number of divisions needed: log₂(n)',
                        'Each iteration does O(1) work',
                        'Total: log₂(n) × O(1) = O(log n)'
                    ],
                    complexity: 'O(log n)',
                    explanation: 'Logarithmic time because we halve the search space each iteration.'
                },
                'recursive-fibonacci': {
                    name: 'Recursive Fibonacci',
                    code: `def fibonacci(n):
            if n <= 1:          # Base case: O(1)
                return n
            return fibonacci(n-1) + fibonacci(n-2)  # Two recursive calls`,
                    steps: [
                        'Each call creates two more recursive calls (except base cases)',
                        'This creates a binary tree of recursive calls',
                        'Tree height is approximately n',
                        'Number of nodes in binary tree of height n: 2ⁿ',
                        'Each node does O(1) work',
                        'Total: O(2ⁿ)'
                    ],
                    complexity: 'O(2ⁿ)',
                    explanation: 'Exponential time due to redundant calculations in the recursion tree.'
                },
                'merge-sort': {
                    name: 'Merge Sort',
                    code: `def merge_sort(arr):
            if len(arr) <= 1:
                return arr

            mid = len(arr) // 2
            left = merge_sort(arr[:mid])    # T(n/2)
            right = merge_sort(arr[mid:])   # T(n/2)

            return merge(left, right)       # O(n) to merge

        def merge(left, right):
            result = []
            i = j = 0

            while i < len(left) and j < len(right):
                if left[i] <= right[j]:
                    result.append(left[i])
                    i += 1
                else:
                    result.append(right[j])
                    j += 1

            result.extend(left[i:])
            result.extend(right[j:])
            return result`,
                    steps: [
                        'If the array length is 1 or less, it is already sorted (base case).',
                        'Split the array into two halves: left and right.',
                        'Recursively sort each half (each call is T(n/2)).',
                        'Merge the two sorted halves in linear time O(n) using the merge function.',
                        'Recurrence: T(n) = 2·T(n/2) + O(n). Applying the Master Theorem yields T(n) = O(n log n).'
                    ],
                    complexity: 'O(n log n)',
                    explanation: 'Merge Sort always divides the array in half and merges in linear time, resulting in a consistent Θ(n log n) time complexity for best, average, and worst cases.'
                }
            };

            // After defining all algorithms, render the selected one:
            const algorithm = algorithms[algorithmType];
            vizArea.innerHTML = `
                <div class="code-snippet"><pre><code>${algorithm.code}</code></pre></div>
                <div class="complexity-steps">
                    <h4 class="step-number">Analysis Steps for ${algorithm.name}:</h4>
                    ${algorithm.steps.map(step => `<div class="step">${step}</div>`).join('')}
                    <p><strong>Time Complexity:</strong> ${algorithm.complexity}</p>
                    <p>${algorithm.explanation}</p>
                </div>
            `;
        }

        //  5, Asymptotic Analysis -----------------------------------------------------------------
        function loadAsymptoticContent() {
            const topicId = 'asymptotic';
            
            // Quiz for Asymptotic Analysis
            const asymptoticQuiz = [
                {
                    questionText: "If an algorithm has time complexity T(n) = 3n² + 2n + 5, what is its Big-O notation?",
                    options: ["O(n)", "O(n²)", "O(3n²)", "O(n² + n)"],
                    correctOptionIndex: 1
                },
                {
                    questionText: "Which statement about Big-O notation is correct?",
                    options: ["O(n) is always faster than O(1)", "Constants matter in Big-O analysis", "O(n²) + O(n) = O(n² + n)", "O(n²) + O(n) = O(n²)"],
                    correctOptionIndex: 3
                },
                {
                    questionText: "An algorithm with nested loops where the outer loop runs n times and inner loop runs n times has complexity:",
                    options: ["O(n)", "O(n log n)", "O(n²)", "O(2n)"],
                    correctOptionIndex: 2
                },
                {
                    questionText: "What is the relationship between Big-O, Big-Ω, and Big-Θ?",
                    options: ["They are all equivalent", "Big-Θ = Big-O ∩ Big-Ω", "Big-O ⊆ Big-Θ ⊆ Big-Ω", "Big-Ω is the most precise"],
                    correctOptionIndex: 1
                },
                {
                    questionText: "If f(n) = n log n and g(n) = n², which is true?",
                    options: ["f(n) = O(g(n))", "g(n) = O(f(n))", "f(n) = Θ(g(n))", "They cannot be compared"],
                    correctOptionIndex: 0
                }
            ];
            
            if (window.dsaContent && typeof window.dsaContent.updateQuiz === 'function') {
                window.dsaContent.updateQuiz(topicId, asymptoticQuiz);
            }
        }

        function createAsymptoticVisualization(n) {
            const vizArea = document.getElementById('asymptotic-viz');
            const resultsArea = document.getElementById('asymptotic-results');

            if (!vizArea || !resultsArea) return;

            // Clear previous content
            vizArea.innerHTML = '';
            resultsArea.innerHTML = '';

            // Define functions and colors
            const functions = {
                'O(1)':        { fn: () => 1,                          color: '#8B5CF6' },
                'O(log n)':    { fn: x => Math.log2(x),               color: '#06B6D4' },
                'O(n)':        { fn: x => x,                          color: '#10B981' },
                'O(n log n)':  { fn: x => x * Math.log2(x),           color: '#F59E0B' },
                'O(n²)':       { fn: x => x * x,                      color: '#EF4444' },
                'O(2ⁿ)':       { fn: x => Math.min(Math.pow(2, x), 1000000), color: '#EC4899' }
            };

            // Determine chart dimensions
            const containerWidth = vizArea.clientWidth;
            const chartHeight = 250;
            const svgNS = 'http://www.w3.org/2000/svg';

            // Compute maxY across all functions for x in [1..n]
            let maxY = 0;
            for (let x = 1; x <= n; x++) {
                Object.values(functions).forEach(({ fn }) => {
                    const yVal = fn(x);
                    if (yVal > maxY && yVal < Infinity) {
                        maxY = yVal;
                    }
                });
            }
            if (maxY === 0) maxY = 1;

            // Create SVG element
            const svg = document.createElementNS(svgNS, 'svg');
            svg.setAttribute('width', containerWidth);
            svg.setAttribute('height', chartHeight);
            svg.style.background = 'var(--gray-800)';
            svg.style.borderRadius = '8px';

            // Draw grid lines
            for (let i = 0; i <= 10; i++) {
                const xPos = (i / 10) * containerWidth;
                const yPos = (i / 10) * chartHeight;

                const vLine = document.createElementNS(svgNS, 'line');
                vLine.setAttribute('x1', xPos);
                vLine.setAttribute('y1', 0);
                vLine.setAttribute('x2', xPos);
                vLine.setAttribute('y2', chartHeight);
                vLine.setAttribute('stroke', '#4b5563');
                vLine.setAttribute('stroke-width', '1');
                svg.appendChild(vLine);

                const hLine = document.createElementNS(svgNS, 'line');
                hLine.setAttribute('x1', 0);
                hLine.setAttribute('y1', yPos);
                hLine.setAttribute('x2', containerWidth);
                hLine.setAttribute('y2', yPos);
                hLine.setAttribute('stroke', '#4b5563');
                hLine.setAttribute('stroke-width', '1');
                svg.appendChild(hLine);
            }

            // Plot each function as a polyline
            Object.entries(functions).forEach(([name, { fn, color }]) => {
                let points = '';
                for (let x = 1; x <= n; x++) {
                    const value = fn(x);
                    const scaledX = (x / n) * containerWidth;
                    const scaledY = chartHeight - (value / maxY) * chartHeight;
                    points += `${scaledX},${scaledY} `;
                }
                const polyline = document.createElementNS(svgNS, 'polyline');
                polyline.setAttribute('points', points.trim());
                polyline.setAttribute('stroke', color);
                polyline.setAttribute('fill', 'none');
                polyline.setAttribute('stroke-width', '2');
                svg.appendChild(polyline);
            });

            // Add legend
            let legendY = 20;
            Object.entries(functions).forEach(([name, { color }]) => {
                // Color box
                const rect = document.createElementNS(svgNS, 'rect');
                rect.setAttribute('x', 10);
                rect.setAttribute('y', legendY - 12);
                rect.setAttribute('width', 15);
                rect.setAttribute('height', 15);
                rect.setAttribute('fill', color);
                svg.appendChild(rect);

                // Text
                const text = document.createElementNS(svgNS, 'text');
                text.setAttribute('x', 30);
                text.setAttribute('y', legendY);
                text.setAttribute('fill', '#ffffff');
                text.setAttribute('font-size', '12px');
                text.textContent = name;
                svg.appendChild(text);

                legendY +=  twenty-five;
            });

            vizArea.appendChild(svg);

            // Populate results area: show value of each function at x = n
            Object.entries(functions).forEach(([name, { fn, color }]) => {
                const val = fn(n);
                const display = val > 1000000 ? '∞' : (val > 1000 ? Math.round(val).toLocaleString() : (Math.round(val * 100) / 100));
                const card = document.createElement('div');
                card.style.background = 'var(--gray-800)';
                card.style.borderRadius = '8px';
                card.style.border = `2px solid ${color}`;
                card.style.padding = '0.75rem';
                card.style.color = 'var(--white)';
                card.innerHTML = `<div style="font-weight:bold;">${name}</div><div style="margin-top:0.5rem;">Value at n=${n}: ${display}</div>`;
                resultsArea.appendChild(card);
            });
        }

        //  6, Master Theorem -----------------------------------------------------------------
        function js_master_theorem_analyzer(a, b, fExponent, logFactor = 0) {
            if (a < 1 || b <= 1) {
                return {
                    error: "Invalid parameters: a must be ≥ 1, b must be > 1",
                    case: null, complexity: "Error", explanation: "Parameter validation failed."
                };
            }

            // Calculate critical exponent
            const log_b_a = Math.log(a) / Math.log(b);
            const epsilon = 1e-9; // For floating point comparisons

            let result = {
                a: a,
                b: b,
                f_exponent: fExponent,
                log_factor: logFactor,
                critical_exponent: log_b_a,
                case: null,
                complexity: null,
                explanation: null,
                note: null
            };

            // Determine which case applies
            if (fExponent < log_b_a - epsilon) {
                // Case 1: Recursion dominates
                result.case = 1;
                result.complexity = `Θ(n<sup>${log_b_a.toFixed(3)}</sup>)`;
                result.explanation = `f(n) = O(n<sup>${fExponent.toFixed(3)}</sup>) grows slower than n<sup>log<sub>b</sub>a</sup> (n<sup>${log_b_a.toFixed(3)}</sup>), so recursion dominates.`;
            } else if (Math.abs(fExponent - log_b_a) < epsilon) {
                // Case 2: Balanced
                result.case = 2;
                if (logFactor > -1) {
                    result.complexity = `Θ(n<sup>${log_b_a.toFixed(3)}</sup> * log<sup>${logFactor + 1}</sup>n)`;
                } else if (logFactor === -1) {
                    result.complexity = `Θ(n<sup>${log_b_a.toFixed(3)}</sup> * log log n)`;
                } else { // logFactor < -1
                    result.complexity = `Θ(n<sup>${log_b_a.toFixed(3)}</sup>)`;
                }
                result.explanation = `f(n) = Θ(n<sup>${log_b_a.toFixed(3)}</sup> * log<sup>${logFactor}</sup>n) and n<sup>log<sub>b</sub>a</sup> (n<sup>${log_b_a.toFixed(3)}</sup>) are 'balanced'.`;

            } else { // fExponent > log_b_a + epsilon
                // Case 3: Non-recursive work dominates
                // Check regularity condition: af(n/b) <= δf(n) for some δ < 1
                // For f(n) = n^c * log^k n, this condition is typically met if f(n) is polynomial.
                // A full check is complex, here we assume it holds if f(n) is polynomial.
                result.case = 3;
                let f_n_str = `n<sup>${fExponent.toFixed(3)}</sup>`;
                if (logFactor !== 0) {
                    f_n_str += ` * log<sup>${logFactor}</sup>n`;
                }
                result.complexity = `Θ(${f_n_str})`;
                result.explanation = `f(n) = Ω(n<sup>${fExponent.toFixed(3)}</sup>) grows faster than n<sup>log<sub>b</sub>a</sup> (n<sup>${log_b_a.toFixed(3)}</sup>), so f(n) dominates.`;
                result.note = "Regularity condition af(n/b) ≤ δf(n) for some constant δ < 1 and all sufficiently large n must also hold for this case.";
            }
            return result;
        }

        function js_analyze_common_algorithms() {
            const algorithms = {
                'Merge Sort': { a: 2, b: 2, f_exp: 1, log_f: 0, recurrence: "T(n) = 2T(n/2) + Θ(n)" },
                'Binary Search': { a: 1, b: 2, f_exp: 0, log_f: 0, recurrence: "T(n) = T(n/2) + Θ(1)" }, // f(n) = n^0 * log^0 n = 1
                'Karatsuba Multiplication': { a: 3, b: 2, f_exp: 1, log_f: 0, recurrence: "T(n) = 3T(n/2) + Θ(n)" }, // Note: CLRS uses Θ(n), f_exp = 1
                'Strassen Matrix Mult.': { a: 7, b: 2, f_exp: 2, log_f: 0, recurrence: "T(n) = 7T(n/2) + Θ(n²)" },
                'Quick Sort (Worst Case)': {a: 1, b: 1, f_exp: 1, log_f:0, recurrence: "T(n) = T(n-1) + Θ(n) - Not Master Theorem applicable like this directly; often T(n)=T(n-1)+T(0)+Θ(n). Simpler T(n)=T(n-1)+Θ(n) gives O(n^2). Let's use a different example for direct Master Theorem application."},
                'Example Case 1 (Recursion Dom.)': {a: 8, b: 2, f_exp: 2, log_f: 0, recurrence: "T(n) = 8T(n/2) + Θ(n²)"}, // log2(8) = 3. 2 < 3. O(n^3)
                'Example Case 3 (f(n) Dom.)': {a: 2, b: 2, f_exp: 2, log_f: 0, recurrence: "T(n) = 2T(n/2) + Θ(n²)"}, // log2(2) = 1. 2 > 1. O(n^2)
            };

            let results = {};
            for (const name in algorithms) {
                if (algorithms.hasOwnProperty(name)) {
                    const params = algorithms[name];
                    if (name === 'Quick Sort (Worst Case)') { // Skip direct Master Theorem for typical worst-case QS
                        results[name] = { name: name, recurrence: params.recurrence, complexity: "Typically O(n²) - (Not directly solved by standard Master Thm. form)", case: "N/A", explanation: "Recurrence T(n)=T(n-1)+Θ(n) is not in T(n/b) form."};
                        continue;
                    }
                    results[name] = js_master_theorem_analyzer(params.a, params.b, params.f_exp, params.log_f);
                    results[name].name = name; // Add name and recurrence to result for display
                    results[name].recurrence = params.recurrence;
                }
            }
            return results;
        }

        function createMasterTheoremVisualization() {
            const aInput = document.getElementById('masterA');
            const bInput = document.getElementById('masterB');
            const fInput = document.getElementById('masterF'); // This is f_exponent (c)
            const kInput = document.getElementById('masterK'); // This is log_factor (k)
            const vizArea = document.getElementById('master-viz');

            if (!aInput || !bInput || !fInput || !kInput || !vizArea) {
                console.error("Master Theorem demo elements not found.");
                if (vizArea) vizArea.innerHTML = "<p style='color:var(--error)'>Error: Input elements missing.</p>";
                return;
            }

            const a = parseFloat(aInput.value);
            const b = parseFloat(bInput.value);
            const fExponent = parseFloat(fInput.value);
            const logFactor = parseFloat(kInput.value);

            if (isNaN(a) || isNaN(b) || isNaN(fExponent) || isNaN(logFactor)) {
                vizArea.innerHTML = "<p style='color:var(--error)'>Error: All inputs must be valid numbers.</p>";
                return;
            }
            
            // Use the JavaScript analyzer function
            const analysis = js_master_theorem_analyzer(a, b, fExponent, logFactor);

            if (analysis.error) {
                vizArea.innerHTML = `<p style='color:var(--error)'>${analysis.error}</p>`;
                return;
            }

            vizArea.innerHTML = `
                <div style="background: var(--gray-800); border-radius: 8px; padding: 1.5rem; color: var(--white); border: 1px solid var(--gray-700); animation: fadeIn 0.5s ease;">
                    <h4 style="color: var(--primary); margin-bottom: 1rem; border-bottom: 1px solid var(--gray-700); padding-bottom: 0.5rem;">Master Theorem Analysis</h4>
                    <p><strong>Recurrence:</strong> T(n) = ${analysis.a}T(n/${analysis.b}) + Θ(n<sup>${analysis.f_exponent.toFixed(2)}</sup> log<sup>${analysis.log_factor}</sup>n)</p>
                    <p style="margin-top:0.5rem;"><strong>Calculated n<sup>log<sub>b</sub>a</sup>:</strong> n<sup>${analysis.critical_exponent.toFixed(3)}</sup> (where log<sub>${analysis.b}</sub>${analysis.a} ≈ ${analysis.critical_exponent.toFixed(3)})</p>
                    <hr style="border-color: var(--gray-700); margin: 1rem 0;">
                    <p style="font-size: 1.1em;"><strong>Applied Case: <span style="color:var(--accent);">${analysis.case}</span></strong></p>
                    <p style="margin-bottom: 0.5rem;">${analysis.explanation}</p>
                    <p style="font-size: 1.2em; margin-top:1rem;"><strong>Resulting Complexity: <span style="color:var(--success);">${analysis.complexity}</span></strong></p>
                    ${analysis.note ? `<p style="margin-top:1rem; font-size:0.9em; color:var(--gray-400);"><strong>Note:</strong> ${analysis.note}</p>` : ''}
                </div>
            `;
        }

        function createMasterExamplesVisualization() {
            const vizArea = document.getElementById('master-viz');
            if (!vizArea) {
                console.error("Master Theorem examples visualization area not found.");
                return;
            }

            // Use the JavaScript analyzer function
            const commonResults = js_analyze_common_algorithms();
            let html = `<h4 style="color: var(--primary); margin-bottom: 1rem; text-align:center;">Common Algorithm Recurrences & Master Theorem</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem;">`;

            for (const name in commonResults) {
                if (commonResults.hasOwnProperty(name)) {
                    const analysis = commonResults[name];
                    html += `
                        <div style="background: var(--gray-800); border-radius: 8px; padding: 1rem; color: var(--white); border: 1px solid var(--gray-700); animation: slideInUp 0.5s ease;">
                            <h5 style="color: var(--secondary); margin-bottom: 0.5rem;">${analysis.name}</h5>
                            <p style="font-size:0.9em; color:var(--gray-400); margin-bottom:0.5rem;">${analysis.recurrence}</p>
                            <p style="font-size:0.9em;"><strong>Parameters:</strong> a=${analysis.a !== undefined ? analysis.a : 'N/A'}, b=${analysis.b !== undefined ? analysis.b : 'N/A'}, f(n) exponent=${analysis.f_exponent !== undefined ? analysis.f_exponent : 'N/A'}, log<sup>k</sup>n (k=${analysis.log_factor !== undefined ? analysis.log_factor : 'N/A'})</p>
                            <p style="font-size:0.9em;"><strong>Case:</strong> ${analysis.case}</p>
                            <p style="font-size:1em; color:var(--success);"><strong>Complexity:</strong> ${analysis.complexity}</p>
                            ${analysis.explanation && analysis.case !== "N/A" ? `<p style="font-size:0.8em; color:var(--gray-500); margin-top:0.3rem;"><em>${analysis.explanation}</em></p>` : ''}
                        </div>
                    `;
                }
            }

            html += `</div>`;
            vizArea.innerHTML = html;
        }

        function loadMasterTheoremContent() {
            const topicId = 'master-theorem';
            
            // Quiz for Master Theorem (from your provided snippet)
            const masterQuiz = [
                { questionText: "For the recurrence T(n) = 2T(n/2) + O(n), which Master Theorem case applies?", options: ["Case 1", "Case 2", "Case 3", "None - Master Theorem doesn't apply"], correctOptionIndex: 1 },
                { questionText: "What is the time complexity of T(n) = 4T(n/2) + O(n)? (f(n)=n^1, log_b_a = log2(4)=2. Case 1)", options: ["O(n)", "O(n log n)", "O(n²)", "O(n² log n)"], correctOptionIndex: 2 },
                { questionText: "In Master Theorem, T(n) = aT(n/b) + f(n), what does 'a' represent?", options: ["Size reduction factor", "Number of subproblems", "Cost of combining results", "Depth of recursion"], correctOptionIndex: 1 },
                { questionText: "For T(n) = T(n/2) + O(1) (f(n)=n^0, log_b_a=log2(1)=0. Case 2, k=0), what is the complexity?", options: ["O(1)", "O(log n)", "O(n)", "O(n log n)"], correctOptionIndex: 1 },
                { questionText: "Master Theorem Case 3 requires which additional condition for T(n) = Θ(f(n))?", options: ["a > b", "f(n) is polynomial", "Regularity condition: af(n/b) ≤ δf(n) for δ < 1", "f(n) > 0"], correctOptionIndex: 2 }
            ];
            
            if (window.dsaContent && typeof window.dsaContent.updateQuiz === 'function') {
                window.dsaContent.updateQuiz(topicId, masterQuiz);
            } else {
                console.warn("dsaContent.updateQuiz function not found for Master Theorem quiz.");
            }

            // Initial call to reset or clear the demo area if needed
            const vizArea = document.getElementById('master-viz');
            if(vizArea && !vizArea.hasChildNodes()) { // Or based on a placeholder
                resetDemo('master');
            }
        }

        //  7, Amortized Analysis -----------------------------------------------------------------
        let aa_items = [];
        let aa_capacity = 4; // Default initial capacity
        let aa_initialCapacitySetting = 4;
        let aa_totalActualCost = 0;
        let aa_totalAmortizedCost = 0;
        let aa_creditBank = 0;
        let aa_opCounter = 0; // Counts number of append operations

        const AA_AMORTIZED_COST_PER_APPEND = 3; // For the accounting method simulation

        function aa_logEvent(message) {
            const eventLog = document.getElementById('aaEventLog');
            if (eventLog) {
                const timestamp = new Date().toLocaleTimeString();
                const newEntry = document.createElement('div');
                newEntry.innerHTML = `<span style="color:var(--gray-500);">${timestamp}:</span> ${message}`;
                eventLog.insertBefore(newEntry, eventLog.firstChild); // Add to top
                if(eventLog.children.length > 10) { // Keep log size manageable
                    eventLog.removeChild(eventLog.lastChild);
                }
            }
        }

        function aa_updateVisualization() {
            const vizArea = document.getElementById('aa-array-visualization');
            const itemsCountEl = document.getElementById('aaItemsCount');
            const currentCapacityEl = document.getElementById('aaCurrentCapacity');
            const actualCostEl = document.getElementById('aaActualCost');
            const totalActualCostEl = document.getElementById('aaTotalActualCost');
            const totalAmortizedCostEl = document.getElementById('aaTotalAmortizedCost');
            const creditBankEl = document.getElementById('aaCreditBank');
            const amortizedOpCostEl = document.getElementById('aaAmortizedOpCost');


            if (!vizArea || !itemsCountEl || !currentCapacityEl || !actualCostEl || !totalActualCostEl || !totalAmortizedCostEl || !creditBankEl || !amortizedOpCostEl) {
                console.error("One or more UI elements for amortized analysis demo not found.");
                return;
            }
            
            amortizedOpCostEl.innerHTML = `${AA_AMORTIZED_COST_PER_APPEND} units`;
            vizArea.innerHTML = ''; // Clear previous state

            for (let i = 0; i < aa_capacity; i++) {
                const cell = document.createElement('div');
                cell.className = 'aa-array-cell';
                cell.style.width = '40px';
                cell.style.height = '40px';
                cell.style.border = '1px solid var(--gray-600)';
                cell.style.display = 'flex';
                cell.style.alignItems = 'center';
                cell.style.justifyContent = 'center';
                cell.style.marginRight = '5px';
                cell.style.fontSize = '0.9em';
                cell.style.transition = 'background-color 0.3s ease, transform 0.2s ease';


                if (i < aa_items.length) {
                    cell.textContent = escapeHtml(aa_items[i].toString());
                    cell.style.backgroundColor = 'var(--primary-dark)';
                    cell.style.color = 'var(--white)';
                } else {
                    cell.textContent = ''; // Empty cell
                    cell.style.backgroundColor = 'var(--gray-800)';
                }
                vizArea.appendChild(cell);
            }
            
            // Animate the last added cell if it exists
            if (aa_items.length > 0 && vizArea.children[aa_items.length - 1]) {
                const lastCell = vizArea.children[aa_items.length - 1];
                lastCell.style.transform = 'scale(1.1)';
                setTimeout(() => {
                    lastCell.style.transform = 'scale(1)';
                }, 200);
            }


            itemsCountEl.textContent = aa_items.length;
            currentCapacityEl.textContent = aa_capacity;
            // actualCostEl is updated in aa_appendItem
            totalActualCostEl.textContent = aa_totalActualCost;
            totalAmortizedCostEl.textContent = aa_totalAmortizedCost;
            creditBankEl.textContent = aa_creditBank;

            // Style credit bank based on value
            if (aa_creditBank < 0) { // Should not happen with correct amortized cost
                creditBankEl.style.color = 'var(--error)';
            } else if (aa_creditBank > 0) {
                creditBankEl.style.color = 'var(--success)';
            } else {
                creditBankEl.style.color = 'var(--accent)';
            }
        }

        function aa_appendItem() {
            aa_opCounter++;
            let currentActualCost = 0;
            let eventMessage = "";

            // Pay amortized cost upfront (for accounting method)
            aa_totalAmortizedCost += AA_AMORTIZED_COST_PER_APPEND;
            aa_creditBank += AA_AMORTIZED_COST_PER_APPEND; // Add to bank

            if (aa_items.length >= aa_capacity) {
                // Resize needed: EXPENSIVE operation
                eventMessage = `Op #${aa_opCounter}: Array full (size ${aa_items.length}, capacity ${aa_capacity}). Resizing. `;
                const oldCapacity = aa_capacity;
                currentActualCost += oldCapacity; // Cost to copy old items
                aa_capacity = (oldCapacity === 0) ? 1 : oldCapacity * 2; // Double capacity
                eventMessage += `New capacity: ${aa_capacity}. Cost to copy ${oldCapacity} items = ${oldCapacity}. `;
                
                // Animate copy (conceptual)
                const cells = document.querySelectorAll('#aa-array-visualization .aa-array-cell');
                cells.forEach(cell => cell.style.backgroundColor = 'var(--warning-dark)'); // Indicate copying
                setTimeout(() => aa_updateVisualization(), 300); // Update after a slight delay to show copying color
            }

            // Cost for the actual insertion of the new item
            currentActualCost += 1; // Cost to add the new item
            aa_items.push(`Item${aa_opCounter}`); // Add a placeholder item
            
            if (!eventMessage) { // If no resize message was set
            eventMessage = `Op #${aa_opCounter}: Appended 'Item${aa_opCounter}'. `
            }
            eventMessage += `Actual cost for this append: ${currentActualCost}.`;

            // "Pay" actual cost from credit bank
            aa_creditBank -= currentActualCost;
            aa_totalActualCost += currentActualCost;

            document.getElementById('aaActualCost').textContent = currentActualCost;
            aa_logEvent(eventMessage + ` Credit bank: ${aa_creditBank}.`);
            aa_updateVisualization(); // Update visuals after all logic
        }

        function aa_resetDemo() {
            aa_initialCapacitySetting = parseInt(document.getElementById('aaInitialCapacity').value) || 4;
            if (aa_initialCapacitySetting < 1 || aa_initialCapacitySetting > 10) aa_initialCapacitySetting = 4;
            
            aa_items = [];
            aa_capacity = aa_initialCapacitySetting;
            aa_totalActualCost = 0;
            aa_totalAmortizedCost = 0;
            aa_creditBank = 0;
            aa_opCounter = 0;
            document.getElementById('aaActualCost').textContent = '0';
            const eventLog = document.getElementById('aaEventLog');
            if (eventLog) eventLog.innerHTML = 'Event Log: Demo Reset. Click "Append Item" to start...';
            aa_updateVisualization();
        }

        function loadAmortizedAnalysisContent() {
            const topicId = 'amortized';

            // Code Example for Amortized Analysis (conceptual)
            const amortizedCodeExample = `
        # Python's list append is a good example of an amortized O(1) operation.
        # When a Python list needs to grow, it allocates more space than immediately
        # needed. This makes most appends fast (O(1) actual time).
        # Occasionally, an append triggers a resize, which involves copying all
        # existing elements to a new, larger memory block (O(N) actual time, where N is current size).

        # Consider a simplified dynamic array implementation:
        class DynamicArray:
            def __init__(self, initial_capacity=1):
                self._size = 0
                self._capacity = initial_capacity
                self._data = [None] * self._capacity # Underlying static array

            def append(self, value):
                actual_cost_this_op = 0
                if self._size == self._capacity:
                    # Resize needed (expensive part)
                    new_capacity = self._capacity * 2 if self._capacity > 0 else 1
                    actual_cost_this_op += self._size # Cost to copy old elements
                    
                    new_data = [None] * new_capacity
                    for i in range(self._size):
                        new_data[i] = self._data[i]
                    self._data = new_data
                    self._capacity = new_capacity
                    # print(f"Resized! Old cap: {self._size}, New cap: {self._capacity}, Copy cost: {self._size}")

                self._data[self._size] = value # Actual insertion
                actual_cost_this_op += 1 
                self._size += 1
                # print(f"Appended {value}. Actual cost for this append: {actual_cost_this_op}")
                return actual_cost_this_op

            def get_size(self):
                return self._size

            def get_capacity(self):
                return self._capacity

        # Amortized analysis shows that over a sequence of 'm' appends,
        # the total time is O(m), making the amortized cost per append O(1).

        # --- Accounting Method Example (Conceptual for Dynamic Array Append) ---
        # Assign Amortized Cost = 3 units for each append.
        # - 1 unit pays for the actual insertion of the new element.
        # - 2 units are stored as "credit".
        # When resizing from size N to 2N:
        #   - N elements need to be copied.
        #   - These N elements were added when the array size was between N/2 and N.
        #   - Number of elements that contributed to credit for this resize: N/2.
        #   - Credit accumulated = (N/2 elements) * (2 credits/element) = N credits.
        #   - This N credit is enough to pay for copying N elements.
        # The bank balance never goes negative, proving amortized O(1).
            `;
            if (window.dsaContent && typeof window.dsaContent.addCodeExample === 'function') {
                window.dsaContent.addCodeExample(topicId, amortizedCodeExample);
            }

            // Quiz Questions for Amortized Analysis
            const amortizedQuizSet = [
                {
                    questionText: "Amortized analysis is most useful when:",
                    options: ["All operations in a sequence have roughly the same cost.", "Expensive operations occur frequently and unpredictably.", "A sequence of operations has occasional very expensive operations, but most are cheap.", "We only care about the absolute best-case performance."],
                    correctOptionIndex: 2
                },
                {
                    questionText: "Which method for amortized analysis involves assigning a 'potential' to states of a data structure?",
                    options: ["Aggregate Method", "Accounting Method", "Potential Method", "Worst-Case Method"],
                    correctOptionIndex: 2
                },
                {
                    questionText: "In the context of a dynamic array that doubles its capacity when full, the actual cost of an append operation that triggers a resize (copying N elements) is typically:",
                    options: ["O(1)", "O(log N)", "O(N)", "O(N<sup>2</sup>)"],
                    correctOptionIndex: 2
                },
                {
                    questionText: "Despite occasional O(N) appends, the amortized cost of appending to a well-implemented dynamic array (like Python's list) is:",
                    options: ["O(1)", "O(log N)", "O(N)", "O(N log N)"],
                    correctOptionIndex: 0
                },
                {
                    questionText: "The Accounting Method for amortized analysis works by:",
                    options: ["Averaging the cost of all possible inputs.", "Charging some operations more than their actual cost to save 'credit' for future expensive operations.", "Finding the single most expensive operation in any sequence.", "Ignoring the cost of infrequent operations."],
                    correctOptionIndex: 1
                }
            ];
            if (window.dsaContent && typeof window.dsaContent.updateQuiz === 'function') {
                window.dsaContent.updateQuiz(topicId, amortizedQuizSet);
            }
            
            // Initial setup for the demo when the topic loads
            const initialCapacityInput = document.getElementById('aaInitialCapacity');
            if (initialCapacityInput) { // Ensure element exists before adding listener
                aa_initialCapacitySetting = parseInt(initialCapacityInput.value);
                initialCapacityInput.addEventListener('change', () => {
                    const newCap = parseInt(initialCapacityInput.value);
                    if (newCap >= 1 && newCap <=10) {
                        aa_initialCapacitySetting = newCap;
                        // Reset if capacity setting changes, to apply it.
                        if (aa_opCounter > 0) { // Only reset if demo has started
                        aa_resetDemo();
                        }
                    } else {
                        initialCapacityInput.value = aa_initialCapacitySetting; // Revert if invalid
                    }
                });
            }
            aa_resetDemo(); // Initialize the demo state and visuals
        }

        const aaDemoStyle = document.createElement('style');
        aaDemoStyle.id = 'aa-demo-styles';
        aaDemoStyle.innerHTML = `
            .aa-array-cell {
                /* Styles defined in aa_updateVisualization for dynamic creation */
                box-shadow: inset 0 0 2px rgba(0,0,0,0.2);
            }
            #aaEventLog div {
                padding: 2px 0;
                border-bottom: 1px solid var(--gray-700);
            }
            #aaEventLog div:last-child {
                border-bottom: none;
            }
        `;
        if (!document.head.querySelector('#aa-demo-styles')) {
            document.head.appendChild(aaDemoStyle);
        }
        
        //  8, Recursion and Backtracking -----------------------------------------------------------------
        let rb_currentDemoType = 'factorial';
        let rb_animationFrameId = null; // For cancelling animations
        let rb_mazeGrid = [];
        let rb_mazePath = [];
        let rb_mazeRows = 5, rb_mazeCols = 7;

        function rb_logEvent(message, type = 'info') {
            const logArea = document.getElementById('rb-output-log');
            if (logArea) {
                const newEntry = document.createElement('div');
                newEntry.innerHTML = message; // Allow HTML for styling
                if (type === 'error') newEntry.style.color = 'var(--error)';
                if (type === 'success') newEntry.style.color = 'var(--success)';
                logArea.insertBefore(newEntry, logArea.firstChild);
                if (logArea.children.length > 20) {
                    logArea.removeChild(logArea.lastChild);
                }
            }
        }

        function rb_setupDemoControls(demoType) {
            rb_currentDemoType = demoType;
            const controlsContainer = document.getElementById('rbDemoSpecificControls');
            controlsContainer.innerHTML = ''; // Clear previous controls

            if (demoType === 'factorial') {
                controlsContainer.innerHTML = `
                    <label for="rbFactorialN" style="color: var(--gray-300);font-size:0.9em;">N (0-10):</label>
                    <input type="number" id="rbFactorialN" value="4" min="0" max="10" class="adt-input" style="width: 70px;">
                `;
            } else if (demoType === 'maze') {
                // Maze controls could be added here if needed (e.g., size, obstacles)
                // For now, we'll use fixed size or generate a random small maze.
                controlsContainer.innerHTML = `
                    <label for="rbMazeSize" style="color: var(--gray-300);font-size:0.9em;">Grid (RxC):</label>
                    <input type="number" id="rbMazeRowsInput" value="5" min="3" max="10" class="adt-input" style="width: 50px;" title="Rows">
                    x
                    <input type="number" id="rbMazeColsInput" value="7" min="3" max="10" class="adt-input" style="width: 50px;" title="Columns">
                `;
            } else if (demoType === 'nqueens_stub') {
                controlsContainer.innerHTML = `
                    <label for="rbNQueensN" style="color: var(--gray-300);font-size:0.9em;">N (Queens):</label>
                    <input type="number" id="rbNQueensN" value="4" min="1" max="8" class="adt-input" style="width: 70px;">
                    <span style="color:var(--gray-500); font-size:0.8em;">(Conceptual Only)</span>
                `;
            }
            rb_resetDemoArea(false); // Reset visuals but not necessarily logs if just switching
        }

        function rb_runSelectedDemo() {
            if (rb_animationFrameId) {
                cancelAnimationFrame(rb_animationFrameId);
                rb_animationFrameId = null;
            }
            rb_resetDemoArea(true); // Clear logs and visuals for new run

            const vizArea = document.getElementById('rb-visualization-area');
            vizArea.innerHTML = ''; // Clear placeholder or previous viz

            if (rb_currentDemoType === 'factorial') {
                const n = parseInt(document.getElementById('rbFactorialN').value);
                if (isNaN(n) || n < 0 || n > 10) {
                    rb_logEvent('Factorial Error: N must be between 0 and 10.', 'error');
                    return;
                }
                rb_logEvent(`Visualizing factorial(${n})...`);
                rb_visualizeFactorial(n, vizArea, 0);
            } else if (rb_currentDemoType === 'maze') {
                rb_mazeRows = parseInt(document.getElementById('rbMazeRowsInput').value) || 5;
                rb_mazeCols = parseInt(document.getElementById('rbMazeColsInput').value) || 7;
                if (rb_mazeRows < 3 || rb_mazeRows > 10 || rb_mazeCols < 3 || rb_mazeCols > 10) {
                    rb_logEvent('Maze Error: Rows/Cols must be between 3 and 10.', 'error');
                    return;
                }
                rb_logEvent(`Generating ${rb_mazeRows}x${rb_mazeCols} maze and attempting to solve...`);
                rb_initializeMaze(vizArea);
                rb_solveMaze();
            } else if (rb_currentDemoType === 'nqueens_stub') {
                const n = parseInt(document.getElementById('rbNQueensN').value);
                if (isNaN(n) || n < 1 || n > 8) {
                    rb_logEvent('N-Queens Error: N must be between 1 and 8 for this conceptual demo.', 'error');
                    return;
                }
                rb_logEvent(`N-Queens Problem for N=${n} (Conceptual). Visualization not fully implemented. This shows where it would go.`);
                vizArea.innerHTML = `<div style="text-align:center; color:var(--gray-400);">Conceptual N-Queens Board for N=${n} <br/> Full animation is complex and beyond this quick demo. <br/> One solution for N=4: Q at (1,0), (3,1), (0,2), (2,3)</div>`;
                // Actual N-Queens visualization is complex and would require significant additions
            }
        }

        function rb_resetDemoArea(clearLog = true) {
            if (rb_animationFrameId) {
                cancelAnimationFrame(rb_animationFrameId);
                rb_animationFrameId = null;
            }
            const vizArea = document.getElementById('rb-visualization-area');
            const placeholder = document.getElementById('rbVizPlaceholder') || document.createElement('div');
            if (!document.getElementById('rbVizPlaceholder')) { // if placeholder was removed
                placeholder.id = 'rbVizPlaceholder';
                placeholder.className = 'viz-placeholder';
                placeholder.style.textAlign = 'center';
                placeholder.innerHTML = `<i class="fas fa-project-diagram" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i>
                                        <span style="color: var(--gray-500);">Select a demo and click Visualize.</span>`;
            }
            vizArea.innerHTML = '';
            vizArea.appendChild(placeholder);

            if (clearLog) {
                const logArea = document.getElementById('rb-output-log');
                if (logArea) logArea.innerHTML = 'Log: Visualization steps and results will appear here...';
            }
            rb_mazePath = []; // Clear maze path
        }

        async function rb_visualizeFactorial(n, vizArea, depth) {
            const callDiv = document.createElement('div');
            callDiv.className = 'rb-callstack-frame';
            callDiv.style.marginLeft = `${depth * 20}px`;
            callDiv.innerHTML = `<span>factorial(${n})</span> <span class="rb-status">pending...</span>`;
            vizArea.appendChild(callDiv);
            rb_logEvent(`${'  '.repeat(depth)}Calling factorial(${n})`);

            await new Promise(resolve => rb_animationFrameId = setTimeout(resolve, 500)); // Animation delay

            if (n === 0) {
                callDiv.querySelector('.rb-status').textContent = 'returns 1 (Base Case)';
                callDiv.style.borderColor = 'var(--success)';
                rb_logEvent(`${'  '.repeat(depth)}factorial(${n}) is base case, returns 1.`);
                return 1;
            } else {
                const result = n * await rb_visualizeFactorial(n - 1, vizArea, depth + 1);
                callDiv.querySelector('.rb-status').textContent = `returns ${n} * ${result/n} = ${result}`;
                callDiv.style.borderColor = 'var(--primary-dark)';
                rb_logEvent(`${'  '.repeat(depth)}factorial(${n}) returns ${result}.`);
                return result;
            }
        }

        function rb_initializeMaze(vizArea) {
            vizArea.innerHTML = ''; // Clear previous
            vizArea.style.display = 'grid';
            vizArea.style.gridTemplateColumns = `repeat(${rb_mazeCols}, 1fr)`;
            vizArea.style.gridTemplateRows = `repeat(${rb_mazeRows}, 1fr)`;
            vizArea.style.width = `${rb_mazeCols * 35}px`; // Adjust cell size as needed
            vizArea.style.height = `${rb_mazeRows * 35}px`;
            vizArea.style.border = '1px solid var(--gray-700)';

            rb_mazeGrid = [];
            for (let r = 0; r < rb_mazeRows; r++) {
                rb_mazeGrid[r] = [];
                for (let c = 0; c < rb_mazeCols; c++) {
                    const cell = document.createElement('div');
                    cell.id = `maze-cell-${r}-${c}`;
                    cell.className = 'rb-maze-cell';
                    // Simple maze generation: ~30% chance of being a wall, but not start/end
                    let isWall = Math.random() < 0.3;
                    if ((r === 0 && c === 0) || (r === rb_mazeRows - 1 && c === rb_mazeCols - 1)) {
                        isWall = false; // Start and end are not walls
                    }
                    rb_mazeGrid[r][c] = isWall ? 1 : 0; // 1 for wall, 0 for path
                    cell.style.backgroundColor = isWall ? 'var(--gray-700)' : 'var(--gray-800)';
                    if (r === 0 && c === 0) cell.innerHTML = 'S';
                    if (r === rb_mazeRows - 1 && c === rb_mazeCols - 1) cell.innerHTML = 'E';
                    vizArea.appendChild(cell);
                }
            }
        }

        async function rb_solveMaze() {
            rb_mazePath = [];
            const found = await rb_findPath(0, 0);
            if (found) {
                rb_logEvent('Path found!', 'success');
            } else {
                rb_logEvent('No path found.', 'error');
            }
        }

        async function rb_findPath(r, c) {
            if (r < 0 || r >= rb_mazeRows || c < 0 || c >= rb_mazeCols || rb_mazeGrid[r][c] === 1 || rb_mazeGrid[r][c] === 2) { // Wall or visited
                return false;
            }

            const cellId = `maze-cell-${r}-${c}`;
            const cellElement = document.getElementById(cellId);

            rb_mazePath.push({r, c});
            rb_mazeGrid[r][c] = 2; // Mark as visited (part of current path)
            if(cellElement) cellElement.style.backgroundColor = 'var(--accent)'; // Current path

            rb_logEvent(`Exploring (${r},${c})`);
            await new Promise(resolve => rb_animationFrameId = setTimeout(resolve, 100));

            if (r === rb_mazeRows - 1 && c === rb_mazeCols - 1) { // Reached end
                rb_mazePath.forEach(p => {
                    const pathCell = document.getElementById(`maze-cell-${p.r}-${p.c}`);
                    if(pathCell) pathCell.style.backgroundColor = 'var(--success)';
                });
                return true;
            }

            // Explore neighbors: Down, Right, Up, Left
            if (await rb_findPath(r + 1, c)) return true;
            if (await rb_findPath(r, c + 1)) return true;
            if (await rb_findPath(r - 1, c)) return true;
            if (await rb_findPath(r, c - 1)) return true;

            // Backtrack
            rb_mazePath.pop();
            rb_mazeGrid[r][c] = 3; // Mark as visited but not part of final path (dead end)
            if(cellElement) cellElement.style.backgroundColor = 'var(--primary-dark)'; // Backtracked path
            rb_logEvent(`Backtracking from (${r},${c})`);
            await new Promise(resolve => rb_animationFrameId = setTimeout(resolve, 50));
            
            return false;
        }

        function loadRecursionBacktrackingContent() {
            const topicId = 'recursion'; // Matches ID in HTML

            // Code Example for Recursion & Backtracking
            const rbCodeExample = `
        # --- Recursion Example: Factorial ---
        def factorial(n):
            # Base case
            if n == 0:
                return 1
            # Recursive step
            else:
                return n * factorial(n - 1)

        # print(f"Factorial of 5: {factorial(5)}") # Output: 120

        # --- Recursion Example: Fibonacci ---
        def fibonacci(n):
            # Base cases
            if n <= 0:
                return 0
            elif n == 1:
                return 1
            # Recursive step
            else:
                return fibonacci(n - 1) + fibonacci(n - 2)

        # print(f"Fibonacci of 7: {fibonacci(7)}") # Output: 13 (Note: inefficient for large n)

        # --- Backtracking Example: Simple N-Queens Feasibility Check (Conceptual) ---
        # (A full N-Queens solver is more involved)

        def is_safe(board, row, col, n):
            # Check this row on left side
            for i in range(col):
                if board[row][i] == 1:
                    return False
            # Check upper diagonal on left side
            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
                if board[i][j] == 1:
                    return False
            # Check lower diagonal on left side
            for i, j in zip(range(row, n, 1), range(col, -1, -1)):
                if board[i][j] == 1:
                    return False
            return True

        def solve_n_queens_util(board, col, n):
            # Base case: If all queens are placed
            if col >= n:
                return True # Found a solution

            # Consider this column and try placing a queen in all rows one by one
            for i in range(n): # Try row 'i'
                if is_safe(board, i, col, n):
                    # Place queen
                    board[i][col] = 1

                    # Recur to place rest of the queens
                    if solve_n_queens_util(board, col + 1, n):
                        return True

                    # If placing queen in board[i][col] doesn't lead to a solution,
                    # then remove queen (BACKTRACK)
                    board[i][col] = 0 # Unchoose
            
            return False # If no queen can be placed in this column

        # Example (conceptual, a real call would initialize board etc.)
        # n_queens = 4
        # board_example = [[0 for _ in range(n_queens)] for _ in range(n_queens)]
        # if solve_n_queens_util(board_example, 0, n_queens):
        #     print("N-Queens solution exists")
        # else:
        #     print("N-Queens solution does not exist")
            `;
            if (window.dsaContent && typeof window.dsaContent.addCodeExample === 'function') {
                window.dsaContent.addCodeExample(topicId, rbCodeExample);
            }

            // Quiz Questions for Recursion & Backtracking
            const rbQuizSet = [
                {
                    questionText: "What is the primary purpose of a base case in a recursive function?",
                    options: ["To make the function run faster.", "To stop the recursion and prevent infinite loops.", "To perform the main computation.", "To call the function itself with a smaller input."],
                    correctOptionIndex: 1
                },
                {
                    questionText: "Which data structure is implicitly used by the system to manage recursive function calls?",
                    options: ["Queue", "Heap", "Call Stack", "Hash Table"],
                    correctOptionIndex: 2
                },
                {
                    questionText: "Backtracking is an algorithmic technique primarily used for:",
                    options: ["Sorting large datasets efficiently.", "Finding the shortest path in weighted graphs.", "Solving problems by incrementally building solutions and abandoning paths that don't work.", "Compressing data without loss."],
                    correctOptionIndex: 2
                },
                {
                    questionText: "A 'stack overflow' error in recursion typically occurs when:",
                    options: ["The recursive function returns a very large value.", "The base case is reached too quickly.", "The recursion depth is too large, exhausting stack memory.", "The input to the recursive function is invalid."],
                    correctOptionIndex: 2
                },
                {
                    questionText: "In backtracking, if a partial solution leads to a dead end, what is the next step?",
                    options: ["Stop the entire algorithm and report failure.", "Try a completely different algorithm.", "Undo the last choice (backtrack) and explore other options.", "Guess the rest of the solution."],
                    correctOptionIndex: 2
                }
            ];
            if (window.dsaContent && typeof window.dsaContent.updateQuiz === 'function') {
                window.dsaContent.updateQuiz(topicId, rbQuizSet);
            }
            
            // Setup initial controls for the demo
            const demoSelect = document.getElementById('rbDemoSelect');
            if (demoSelect) {
                rb_setupDemoControls(demoSelect.value); // Initialize with the default selected demo
                demoSelect.addEventListener('change', (event) => {
                    rb_setupDemoControls(event.target.value);
                });
            }
            rb_resetDemoArea(); // Call once to set initial placeholder if needed.
        }

        const rbDemoStyle = document.createElement('style');
        rbDemoStyle.id = 'rb-demo-styles';
        rbDemoStyle.innerHTML = `
            .rb-callstack-frame {
                border: 1px solid var(--gray-600);
                background-color: var(--gray-800);
                padding: 8px 12px;
                margin-bottom: 5px;
                border-radius: 6px;
                font-size: 0.9em;
                transition: border-color 0.3s ease;
                display: flex;
                justify-content: space-between;
            }
            .rb-callstack-frame .rb-status {
                color: var(--accent);
                font-style: italic;
            }
            .rb-maze-cell {
                width: 30px; /* Adjust for better fit if needed */
                height: 30px;
                border: 1px solid var(--gray-700);
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 0.8em;
                color: var(--white);
                transition: background-color 0.2s ease-out;
            }
            #rb-visualization-area { /* Ensure child elements don't overflow badly */
                position: relative; /* For absolute positioning of children if needed */
            }
        `;
        if (!document.head.querySelector('#rb-demo-styles')) {
            document.head.appendChild(rbDemoStyle);
        }

        //  9, Linked-List -----------------------------------------------------------------
        let ll_head = null; // Represents the head of our visualized linked list
        let ll_nodeCount = 0; // Keep track of number of nodes for unique IDs if needed

        function ll_logEvent(message, type = 'info') {
            const logArea = document.getElementById('ll-output-log');
            if (logArea) {
                const newEntry = document.createElement('div');
                newEntry.innerHTML = message; // Allow HTML for styling
                if (type === 'error') newEntry.style.color = 'var(--error)';
                if (type === 'success') newEntry.style.color = 'var(--success)';
                logArea.insertBefore(newEntry, logArea.firstChild);
                if (logArea.children.length > 10) {
                    logArea.removeChild(logArea.lastChild);
                }
            }
        }

        class VisualListNode {
            constructor(data) {
                this.data = data;
                this.next = null;
                this.id = `ll-node-${ll_nodeCount++}`; // Unique ID for the DOM element
            }
        }

        function ll_addNodeVisual() {
            const valueInput = document.getElementById('llNodeValue');
            const positionInput = document.getElementById('llNodePosition');
            const value = valueInput.value.trim();
            let positionStr = positionInput.value.trim();

            if (!value) {
                ll_logEvent('Error: Node value cannot be empty.', 'error');
                return;
            }

            const newNode = new VisualListNode(value);
            let current = ll_head;
            let prev = null;
            let index = 0;

            if (positionStr === "") { // Add to end
                if (!ll_head) {
                    ll_head = newNode;
                    ll_logEvent(`Added node "${escapeHtml(value)}" (head).`, 'success');
                } else {
                    while (current.next) {
                        current = current.next;
                    }
                    current.next = newNode;
                    ll_logEvent(`Appended node "${escapeHtml(value)}".`, 'success');
                }
            } else { // Add at specific position
                const position = parseInt(positionStr);
                if (isNaN(position) || position < 0) {
                    ll_logEvent('Error: Invalid position. Must be a non-negative integer.', 'error');
                    return;
                }

                if (position === 0) { // Add at head
                    newNode.next = ll_head;
                    ll_head = newNode;
                    ll_logEvent(`Added node "${escapeHtml(value)}" at head (pos 0).`, 'success');
                } else {
                    while (current && index < position) {
                        prev = current;
                        current = current.next;
                        index++;
                    }
                    if (index < position && !current) { // Position out of bounds (too large)
                        ll_logEvent(`Error: Position ${position} is out of bounds. Appending instead.`, 'error');
                        // Find tail and append
                        let tail = ll_head;
                        if (!tail) { ll_head = newNode; } // List was empty
                        else { while(tail.next) { tail = tail.next; } tail.next = newNode; }

                    } else {
                        prev.next = newNode;
                        newNode.next = current;
                        ll_logEvent(`Added node "${escapeHtml(value)}" at position ${position}.`, 'success');
                    }
                }
            }
            valueInput.value = ''; // Clear input
            positionInput.value = '';
            ll_renderList();
        }

        function ll_removeNodeVisual() {
            const positionInput = document.getElementById('llNodePosition');
            let positionStr = positionInput.value.trim();

            if (!ll_head) {
                ll_logEvent('Error: List is empty. Cannot remove.', 'error');
                return;
            }

            let current = ll_head;
            let prev = null;
            let index = 0;
            let removedNodeData = null;

            if (positionStr === "") { // Remove from end
                if (!ll_head.next) { // Only one node
                    removedNodeData = ll_head.data;
                    ll_head = null;
                } else {
                    while (current.next) {
                        prev = current;
                        current = current.next;
                    }
                    removedNodeData = current.data;
                    prev.next = null;
                }
                ll_logEvent(`Removed last node ("${escapeHtml(removedNodeData)}").`, 'success');
            } else { // Remove from specific position
                const position = parseInt(positionStr);
                if (isNaN(position) || position < 0) {
                    ll_logEvent('Error: Invalid position. Must be a non-negative integer.', 'error');
                    return;
                }

                if (position === 0) {
                    removedNodeData = ll_head.data;
                    ll_head = ll_head.next;
                    ll_logEvent(`Removed head node ("${escapeHtml(removedNodeData)}").`, 'success');
                } else {
                    while (current && index < position) {
                        prev = current;
                        current = current.next;
                        index++;
                    }
                    if (!current) { // Position out of bounds
                        ll_logEvent(`Error: Position ${position} is out of bounds. Nothing removed.`, 'error');
                        return;
                    }
                    removedNodeData = current.data;
                    prev.next = current.next;
                    ll_logEvent(`Removed node "${escapeHtml(removedNodeData)}" from position ${position}.`, 'success');
                }
            }
            positionInput.value = ''; // Clear input
            ll_renderList();
        }

        function ll_renderList() {
            const vizArea = document.getElementById('ll-visualization-area');
            vizArea.innerHTML = ''; // Clear previous
            
            const placeholder = document.getElementById('llVizPlaceholder');
            if (placeholder) placeholder.style.display = 'none';


            if (!ll_head) {
                vizArea.innerHTML = `<div class="viz-placeholder" id="llVizPlaceholder" style="text-align: center; width:100%;">
                                        <i class="fas fa-link" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i>
                                        <span style="color: var(--gray-500);">List is empty. Add some nodes!</span>
                                    </div>`;
                return;
            }

            let current = ll_head;
            let index = 0;
            while (current) {
                const nodeDiv = document.createElement('div');
                nodeDiv.className = 'll-node-visual';
                nodeDiv.id = current.id;
                nodeDiv.innerHTML = `
                    <div class="ll-node-data">${escapeHtml(current.data.toString())}</div>
                    <div class="ll-node-next"></div>
                `;
                vizArea.appendChild(nodeDiv);

                // Add arrow if not the last node
                if (current.next) {
                    const arrowDiv = document.createElement('div');
                    arrowDiv.className = 'll-arrow-visual';
                    arrowDiv.innerHTML = '&rarr;';
                    vizArea.appendChild(arrowDiv);
                }
                
                // Animate newly added node (simple pop-in)
                nodeDiv.style.transform = 'scale(0.8)';
                nodeDiv.style.opacity = '0.5';
                setTimeout(() => {
                    nodeDiv.style.transform = 'scale(1)';
                    nodeDiv.style.opacity = '1';
                }, 50 * index);


                current = current.next;
                index++;
            }
            // Add NULL at the end
            const nullDiv = document.createElement('div');
            nullDiv.className = 'll-node-visual ll-null-visual';
            nullDiv.textContent = 'NULL';
            vizArea.appendChild(nullDiv);
        }

        function ll_resetDemo() {
            ll_head = null;
            ll_nodeCount = 0;
            ll_logEvent('Demo reset. List is now empty.');
            document.getElementById('llNodeValue').value = '';
            document.getElementById('llNodePosition').value = '';
            ll_renderList();
        }

        function loadLinkedListContent() {
            const topicId = 'linkedlist';

            const llCodeExample = `
        class Node:
            def __init__(self, data=None):
                self.data = data
                self.next = None

        class SinglyLinkedList:
            def __init__(self):
                self.head = None

            def is_empty(self):
                return self.head is None

            def append(self, data):
                """Adds a new node with data to the end of the list."""
                new_node = Node(data)
                if self.is_empty():
                    self.head = new_node
                    return
                last_node = self.head
                while last_node.next:
                    last_node = last_node.next
                last_node.next = new_node

            def prepend(self, data):
                """Adds a new node with data to the beginning of the list."""
                new_node = Node(data)
                new_node.next = self.head
                self.head = new_node

            def insert_after_node(self, prev_node_data, data):
                """Inserts a new node after the node with prev_node_data."""
                current = self.head
                while current and current.data != prev_node_data:
                    current = current.next
                
                if not current: # prev_node_data not found
                    print(f"Node with data {prev_node_data} not found.")
                    return
                
                new_node = Node(data)
                new_node.next = current.next
                current.next = new_node

            def delete_node(self, key_data):
                """Deletes the first occurrence of a node with the given key_data."""
                current = self.head
                # If head node itself holds the key to be deleted
                if current and current.data == key_data:
                    self.head = current.next
                    current = None # free memory (in Python, GC handles this)
                    return
                
                # Search for the key to be deleted, keep track of the previous node
                prev = None
                while current and current.data != key_data:
                    prev = current
                    current = current.next
                
                if not current: # Key not present in the list
                    print(f"Node with data {key_data} not found.")
                    return
                
                # Unlink the node from linked list
                prev.next = current.next
                current = None

            def search(self, key_data):
                """Searches for a node with key_data and returns True if found, False otherwise."""
                current = self.head
                while current:
                    if current.data == key_data:
                        return True
                    current = current.next
                return False

            def display(self):
                elements = []
                current_node = self.head
                while current_node:
                    elements.append(str(current_node.data))
                    current_node = current_node.next
                print(" -> ".join(elements) + " -> NULL")

        # Example Usage:
        # my_list = SinglyLinkedList()
        # my_list.append(10)
        # my_list.append(20)
        # my_list.prepend(5)
        # my_list.insert_after_node(10, 15)
        # my_list.display()  # Output: 5 -> 10 -> 15 -> 20 -> NULL
        # my_list.delete_node(10)
        # my_list.display()  # Output: 5 -> 15 -> 20 -> NULL
        # print(f"Search for 20: {my_list.search(20)}") # Output: True
            `;
            if (window.dsaContent && typeof window.dsaContent.addCodeExample === 'function') {
                window.dsaContent.addCodeExample(topicId, llCodeExample);
            }

            const llQuizSet = [
                {
                    questionText: "What does the 'next' pointer in a singly linked list node typically store?",
                    options: ["The data of the next node", "The memory address of the next node", "The data of the previous node", "The size of the list"],
                    correctOptionIndex: 1
                },
                {
                    questionText: "What is the time complexity for accessing the Nth element in a singly linked list?",
                    options: ["O(1)", "O(log N)", "O(N)", "O(N log N)"],
                    correctOptionIndex: 2
                },
                {
                    questionText: "Which of the following is an advantage of linked lists over arrays?",
                    options: ["Constant time random access", "Efficient insertion/deletion at arbitrary positions (if pointer to previous is known or not needed)", "Contiguous memory allocation", "Less memory overhead per element"],
                    correctOptionIndex: 1
                },
                {
                    questionText: "In a singly linked list, to insert a new node *after* a given node (pointer to given node is `p`), what is typically required?",
                    options: ["Traverse from the head to find `p`", "Only `p` and the new node's data", "Pointer to the head and `p`", "Pointer to `p`'s previous node"],
                    correctOptionIndex: 1 // Given p, p.next = newNode; newNode.next = old_p_next
                },
                {
                    questionText: "A 'head' pointer in a linked list points to:",
                    options: ["The last node of the list", "The middle node of the list", "The first node of the list", "A special sentinel node"],
                    correctOptionIndex: 2
                }
            ];
            if (window.dsaContent && typeof window.dsaContent.updateQuiz === 'function') {
                window.dsaContent.updateQuiz(topicId, llQuizSet);
            }
            ll_resetDemo(); // Initialize the demo visuals
        }

        const llDemoStyle = document.createElement('style');
        llDemoStyle.id = 'll-demo-styles';
        llDemoStyle.innerHTML = `
            .ll-node-visual {
                display: flex;
                align-items: center;
                background-color: var(--primary-dark);
                border: 1px solid var(--primary);
                border-radius: 6px;
                color: var(--white);
                font-size: 0.9em;
                min-width: 60px; /* Ensure some width for empty data */
                transition: transform 0.3s ease, opacity 0.3s ease;
            }
            .ll-node-data {
                padding: 0.75rem 1rem;
                text-align: center;
                flex-grow: 1; /* Data part takes available space */
            }
            .ll-node-next {
                width: 20px; /* Width of the 'next' pointer part */
                height: 100%; /* Match data part height */
                background-color: var(--primary); /* Darker part for pointer */
                border-top-right-radius: 5px;
                border-bottom-right-radius: 5px;
                position: relative; /* For pseudo-elements if needed for pointer shape */
            }
            .ll-arrow-visual {
                font-size: 1.5em;
                color: var(--gray-400);
                margin: 0 5px; /* Space around arrow */
                display: flex;
                align-items: center;
            }
            .ll-null-visual {
                padding: 0.75rem 1rem;
                background-color: var(--gray-700);
                border-color: var(--gray-600);
            }
            #ll-visualization-area .viz-placeholder {
                width: 100%; /* Ensure placeholder takes full width initially */
            }
        `;
        if (!document.head.querySelector('#ll-demo-styles')) {
            document.head.appendChild(llDemoStyle);
        }

        //  10, Stacks and Queues -----------------------------------------------------------------
        let sq_stackData = [];
        let sq_queueData = []; // Using array as a simple queue (front at index 0)

        function sq_logEvent(message, type = 'info') {
            const logArea = document.getElementById('sq-output-log');
            if (logArea) {
                const newEntry = document.createElement('div');
                newEntry.innerHTML = message; // Allow HTML for styling
                if (type === 'error') newEntry.style.color = 'var(--error)';
                if (type === 'success') newEntry.style.color = 'var(--success)';
                logArea.insertBefore(newEntry, logArea.firstChild);
                if (logArea.children.length > 10) {
                    logArea.removeChild(logArea.lastChild);
                }
            }
        }

        function sq_pushVisual() {
            const valueInput = document.getElementById('sqStackValue');
            const value = valueInput.value.trim();
            if (!value) {
                sq_logEvent('Stack Push Error: Value cannot be empty.', 'error');
                return;
            }
            sq_stackData.push(value);
            sq_logEvent(`Pushed "${escapeHtml(value)}" onto stack.`, 'success');
            valueInput.value = '';
            sq_renderStack();
        }

        function sq_popVisual() {
            if (sq_stackData.length === 0) {
                sq_logEvent('Stack Pop Error: Stack is empty.', 'error');
                return;
            }
            const poppedValue = sq_stackData.pop();
            sq_logEvent(`Popped "${escapeHtml(poppedValue)}" from stack.`, 'success');
            sq_renderStack();
        }

        function sq_renderStack() {
            const vizArea = document.getElementById('sq-stack-visualization');
            const topDisplay = document.getElementById('sqStackTop');
            vizArea.innerHTML = ''; // Clear

            if (sq_stackData.length === 0) {
                vizArea.innerHTML = '<span class="viz-placeholder" style="color:var(--gray-500);">Stack is empty</span>';
                topDisplay.textContent = '-';
                return;
            }

            // Stack items are typically visualized growing upwards, so iterate normally and CSS (flex-direction: column-reverse) handles visual order.
            sq_stackData.forEach((itemData, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'sq-item stack-item-visual';
                itemDiv.textContent = escapeHtml(itemData);
                // Highlight top item
                if (index === sq_stackData.length - 1) {
                    itemDiv.style.borderColor = 'var(--accent)';
                    itemDiv.style.boxShadow = '0 0 8px var(--accent)';
                    topDisplay.textContent = escapeHtml(itemData);
                }
                vizArea.appendChild(itemDiv);
            });
            if (sq_stackData.length > 0) {
                // Add entrance animation to the last (top) element
                const topElement = vizArea.children[vizArea.children.length -1];
                if (topElement && !topElement.classList.contains('viz-placeholder')) {
                    topElement.style.opacity = '0';
                    topElement.style.transform = 'translateY(20px)';
                    setTimeout(() => {
                        topElement.style.opacity = '1';
                        topElement.style.transform = 'translateY(0)';
                    }, 50);
                }
            }
        }

        function sq_enqueueVisual() {
            const valueInput = document.getElementById('sqQueueValue');
            const value = valueInput.value.trim();
            if (!value) {
                sq_logEvent('Queue Enqueue Error: Value cannot be empty.', 'error');
                return;
            }
            sq_queueData.push(value); // Add to rear
            sq_logEvent(`Enqueued "${escapeHtml(value)}".`, 'success');
            valueInput.value = '';
            sq_renderQueue();
        }

        function sq_dequeueVisual() {
            if (sq_queueData.length === 0) {
                sq_logEvent('Queue Dequeue Error: Queue is empty.', 'error');
                return;
            }
            const dequeuedValue = sq_queueData.shift(); // Remove from front
            sq_logEvent(`Dequeued "${escapeHtml(dequeuedValue)}".`, 'success');
            sq_renderQueue();
        }

        function sq_renderQueue() {
            const vizArea = document.getElementById('sq-queue-visualization');
            const frontDisplay = document.getElementById('sqQueueFront');
            const rearDisplay = document.getElementById('sqQueueRear');
            vizArea.innerHTML = ''; // Clear

            if (sq_queueData.length === 0) {
                vizArea.innerHTML = '<span class="viz-placeholder" style="color:var(--gray-500);">Queue is empty</span>';
                frontDisplay.textContent = '-';
                rearDisplay.textContent = '-';
                return;
            }

            sq_queueData.forEach((itemData, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'sq-item queue-item-visual';
                itemDiv.textContent = escapeHtml(itemData);
                // Highlight front and rear
                if (index === 0) { // Front
                    itemDiv.style.borderColor = 'var(--accent)';
                    itemDiv.style.boxShadow = '0 0 8px var(--accent)';
                    frontDisplay.textContent = escapeHtml(itemData);
                }
                if (index === sq_queueData.length - 1) { // Rear
                    itemDiv.style.borderStyle = 'dashed';
                    rearDisplay.textContent = escapeHtml(itemData);
                }
                vizArea.appendChild(itemDiv);
            });
            
            if (sq_queueData.length > 0) {
                // Add entrance animation to the last (rear) element
                const rearElement = vizArea.children[vizArea.children.length -1];
                if (rearElement && !rearElement.classList.contains('viz-placeholder')) {
                    rearElement.style.opacity = '0';
                    rearElement.style.transform = 'translateX(-20px)';
                    setTimeout(() => {
                        rearElement.style.opacity = '1';
                        rearElement.style.transform = 'translateX(0)';
                    }, 50);
                }
            }


        }

        function sq_resetDemos() {
            sq_stackData = [];
            sq_queueData = [];
            sq_logEvent('Stack & Queue Demos Reset.');
            document.getElementById('sqStackValue').value = '';
            document.getElementById('sqQueueValue').value = '';
            sq_renderStack();
            sq_renderQueue();
        }

        function loadStacksQueuesContent() {
            const topicId = 'stacks-queues';

            const sqCodeExample = `
        # --- Stack Implementation using Python list ---
        class Stack:
            def __init__(self):
                self._items = []  # Internal list to store stack items

            def push(self, item):
                """Adds an item to the top of the stack."""
                self._items.append(item)

            def pop(self):
                """Removes and returns the item from the top. Raises IndexError if empty."""
                if not self.is_empty():
                    return self._items.pop()
                else:
                    raise IndexError("Cannot pop from an empty stack")

            def peek(self):
                """Returns the top item without removing. Raises IndexError if empty."""
                if not self.is_empty():
                    return self._items[-1]
                else:
                    raise IndexError("Cannot peek an empty stack")

            def is_empty(self):
                """Returns True if the stack is empty, False otherwise."""
                return len(self._items) == 0

            def size(self):
                """Returns the number of items in the stack."""
                return len(self._items)

        # --- Queue Implementation using Python's collections.deque (efficient) ---
        from collections import deque

        class Queue:
            def __init__(self):
                self._items = deque() # Use deque for efficient appends and pops from left

            def enqueue(self, item):
                """Adds an item to the rear of the queue."""
                self._items.append(item)

            def dequeue(self):
                """Removes and returns the item from the front. Raises IndexError if empty."""
                if not self.is_empty():
                    return self._items.popleft()
                else:
                    raise IndexError("Cannot dequeue from an empty queue")

            def front(self):
                """Returns the front item without removing. Raises IndexError if empty."""
                if not self.is_empty():
                    return self._items[0]
                else:
                    raise IndexError("Cannot peek an empty queue")

            def is_empty(self):
                """Returns True if the queue is empty, False otherwise."""
                return len(self._items) == 0

            def size(self):
                """Returns the number of items in the queue."""
                return len(self._items)

        # Example Usage:
        # s = Stack()
        # s.push(10)
        # s.push(20)
        # print(s.pop())  # 20
        # print(s.peek()) # 10

        # q = Queue()
        # q.enqueue('A')
        # q.enqueue('B')
        # print(q.dequeue()) # 'A'
        # print(q.front())   # 'B'
            `;
            if (window.dsaContent && typeof window.dsaContent.addCodeExample === 'function') {
                window.dsaContent.addCodeExample(topicId, sqCodeExample);
            }

            const sqQuizSet = [
                {
                    questionText: "A stack follows which principle for data access?",
                    options: ["FIFO (First-In, First-Out)", "LIFO (Last-In, First-Out)", "Random Access", "LOFI (Last-Out, First-In)"],
                    correctOptionIndex: 1
                },
                {
                    questionText: "Which operation is typically used to add an element to a queue?",
                    options: ["Push", "Pop", "Enqueue", "Peek"],
                    correctOptionIndex: 2
                },
                {
                    questionText: "If you implement a queue using a standard Python list and use `append()` for enqueue and `pop(0)` for dequeue, what is the time complexity of the dequeue operation in the worst case?",
                    options: ["O(1)", "O(log N)", "O(N)", "O(N log N)"],
                    correctOptionIndex: 2 // Due to shifting elements
                },
                {
                    questionText: "Which of these is a common application of stacks?",
                    options: ["Print job scheduling", "Managing function calls in a program", "Serving requests in a web server", "Breadth-First Search (BFS)"],
                    correctOptionIndex: 1
                },
                {
                    questionText: "To implement a queue efficiently with O(1) enqueue and dequeue operations using a linked list, you generally need pointers to:",
                    options: ["Only the head node", "Only the tail node", "Both the head and tail nodes", "The middle node"],
                    correctOptionIndex: 2
                }
            ];
            if (window.dsaContent && typeof window.dsaContent.updateQuiz === 'function') {
                window.dsaContent.updateQuiz(topicId, sqQuizSet);
            }
            sq_resetDemos(); // Initialize demo visuals
        }

        const sqDemoStyle = document.createElement('style');
        sqDemoStyle.id = 'sq-demo-styles';
        sqDemoStyle.innerHTML = `
            .sq-container {
                min-height: 200px;
                background-color: var(--gray-900);
                border: 1px solid var(--gray-700);
                border-radius: 8px;
                padding: 10px;
                display: flex;
                gap: 5px;
            }
            .sq-item {
                background-color: var(--primary);
                color: var(--white);
                padding: 0.5rem 0.8rem;
                border-radius: 4px;
                text-align: center;
                font-size: 0.9em;
                border: 2px solid var(--primary-dark);
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                transition: transform 0.2s ease, opacity 0.2s ease;
            }
            .stack-item-visual {
                width: 80%;
                max-width: 120px;
                margin-bottom: 5px; /* Stack items are vertical */
            }
            .queue-item-visual {
                min-width: 50px; /* Queue items horizontal */
            }
        `;
        if (!document.head.querySelector('#sq-demo-styles')) {
            document.head.appendChild(sqDemoStyle);
        }

        //  11, Trees & Heaps -----------------------------------------------------------------
        let th_currentDemoType = 'bst'; // 'bst' or 'minheap'
        let th_bstRoot = null;       // For BST visualization
        let th_heapArray = [];     // For Min-Heap visualization (array-based)
        const NODE_RADIUS = 20;
        const HORIZONTAL_SPACING = 50;
        const VERTICAL_SPACING = 60;

        function th_logEvent(message, type = 'info') {
            const logArea = document.getElementById('th-output-log');
            if (logArea) {
                const newEntry = document.createElement('div');
                newEntry.innerHTML = message;
                if (type === 'error') newEntry.style.color = 'var(--error)';
                if (type === 'success') newEntry.style.color = 'var(--success)';
                logArea.insertBefore(newEntry, logArea.firstChild);
                if (logArea.children.length > 15) logArea.removeChild(logArea.lastChild);
            }
        }

        function th_setupOperationControls(demoType) {
            th_currentDemoType = demoType;
            const controlsContainer = document.getElementById('thOperationControls');
            controlsContainer.innerHTML = ''; // Clear previous

            if (demoType === 'bst') {
                controlsContainer.innerHTML = `
                    <button class="btn btn-sm" onclick="th_handleBstOperation('insert')"><i class="fas fa-plus"></i> Insert</button>
                    <button class="btn btn-sm btn-secondary" onclick="th_handleBstOperation('delete')"><i class="fas fa-trash"></i> Delete</button>
                    <button class="btn btn-sm" onclick="th_handleBstOperation('search')"><i class="fas fa-search"></i> Search</button>
                    <select id="thTraversalType" class="adt-input btn-sm" style="padding: 0.4rem 0.6rem;">
                        <option value="inorder">In-order</option>
                        <option value="preorder">Pre-order</option>
                        <option value="postorder">Post-order</option>
                        <option value="levelorder">Level-order</option>
                    </select>
                    <button class="btn btn-sm btn-info" onclick="th_handleBstOperation('traverse')"><i class="fas fa-route"></i> Traverse</button>
                `;
            } else if (demoType === 'minheap') {
                controlsContainer.innerHTML = `
                    <button class="btn btn-sm" onclick="th_handleHeapOperation('insert')"><i class="fas fa-plus"></i> Insert</button>
                    <button class="btn btn-sm btn-secondary" onclick="th_handleHeapOperation('extractMin')"><i class="fas fa-arrow-up"></i> Extract Min</button>
                    <button class="btn btn-sm" onclick="th_handleHeapOperation('heapify')"><i class="fas fa-sync-alt"></i> Heapify Array</button>
                `;
            }
            th_resetCurrentDemo(false); // Reset visuals but not log when switching type
        }

        function th_resetCurrentDemo(clearLog = true) {
            const vizArea = document.getElementById('th-visualization-area');
            const placeholder = document.getElementById('thVizPlaceholder') || document.createElement('div'); // Recreate if needed
            if (!document.getElementById('thVizPlaceholder')) {
                placeholder.id = 'thVizPlaceholder';
                placeholder.className = 'viz-placeholder';
                placeholder.style.textAlign = 'center'; placeholder.style.width = '100%';
                placeholder.innerHTML = `<i class="fas fa-leaf" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i>
                                        <span style="color: var(--gray-500);">Select demo type, enter value(s), and choose an operation.</span>`;
            }
            vizArea.innerHTML = '';
            vizArea.appendChild(placeholder);
            if (clearLog) {
                const logArea = document.getElementById('th-output-log');
                if(logArea) logArea.innerHTML = 'Log: Operations and traversal results will appear here...';
            }
            document.getElementById('thNodeValue').value = '';

            if (th_currentDemoType === 'bst') {
                th_bstRoot = null;
            } else if (th_currentDemoType === 'minheap') {
                th_heapArray = [];
            }
        }

        class BSTNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.x = 0; this.y = 0; // For visualization
                this.id = `bstnode-${Date.now()}-${Math.random().toString(16).slice(2)}`;
            }
        }

        function th_insertBstNode(root, value) {
            if (!root) return new BSTNode(value);
            if (value < root.value) {
                root.left = th_insertBstNode(root.left, value);
            } else if (value > root.value) {
                root.right = th_insertBstNode(root.right, value);
            } else { // Value already exists
                th_logEvent(`Value ${value} already exists in BST.`, 'error');
            }
            return root;
        }
        
        function th_deleteBstNode(root, value) {
            if (!root) {
                th_logEvent(`Value ${value} not found for deletion.`, 'error');
                return null;
            }
            if (value < root.value) {
                root.left = th_deleteBstNode(root.left, value);
            } else if (value > root.value) {
                root.right = th_deleteBstNode(root.right, value);
            } else { // Node to be deleted found
                th_logEvent(`Deleting node ${value}.`, 'success');
                if (!root.left) return root.right;
                if (!root.right) return root.left;
                // Node with two children: Get the inorder successor (smallest in the right subtree)
                let temp = root.right;
                while (temp.left) temp = temp.left;
                root.value = temp.value; // Copy inorder successor's content to this node
                root.right = th_deleteBstNode(root.right, temp.value); // Delete the inorder successor
            }
            return root;
        }

        function th_searchBstNode(root, value, pathTaken = []) {
            if (!root) {
                pathTaken.push({ value: 'NULL', found: false });
                return { found: false, path: pathTaken };
            }
            pathTaken.push({ value: root.value, found: false, id: root.id });
            if (root.value === value) {
                pathTaken[pathTaken.length - 1].found = true;
                return { found: true, path: pathTaken };
            }
            if (value < root.value) {
                return th_searchBstNode(root.left, value, pathTaken);
            } else {
                return th_searchBstNode(root.right, value, pathTaken);
            }
        }

        function th_getTraversalResult(root, type) {
            const result = [];
            function inorder(node) { if (node) { inorder(node.left); result.push(node.value); inorder(node.right); } }
            function preorder(node) { if (node) { result.push(node.value); preorder(node.left); preorder(node.right); } }
            function postorder(node) { if (node) { postorder(node.left); postorder(node.right); result.push(node.value); } }
            function levelorder(node) {
                if (!node) return;
                const queue = [node];
                while (queue.length > 0) {
                    const current = queue.shift();
                    result.push(current.value);
                    if (current.left) queue.push(current.left);
                    if (current.right) queue.push(current.right);
                }
            }
            switch (type) {
                case 'inorder': inorder(root); break;
                case 'preorder': preorder(root); break;
                case 'postorder': postorder(root); break;
                case 'levelorder': levelorder(root); break;
            }
            return result;
        }

        function th_heapInsert(value) {
            th_heapArray.push(value);
            let currentIndex = th_heapArray.length - 1;
            th_siftUp(currentIndex);
        }
        
        function th_siftUp(index) {
            let parentIndex = Math.floor((index - 1) / 2);
            while (index > 0 && th_heapArray[index] < th_heapArray[parentIndex]) {
                [th_heapArray[index], th_heapArray[parentIndex]] = [th_heapArray[parentIndex], th_heapArray[index]]; // Swap
                index = parentIndex;
                parentIndex = Math.floor((index - 1) / 2);
            }
        }
        
        function th_heapExtractMin() {
            if (th_heapArray.length === 0) return null;
            if (th_heapArray.length === 1) return th_heapArray.pop();
            const min = th_heapArray[0];
            th_heapArray[0] = th_heapArray.pop(); // Move last to root
            th_siftDown(0);
            return min;
        }
        
        function th_siftDown(index) {
            let leftChildIndex = 2 * index + 1;
            let rightChildIndex = 2 * index + 2;
            let smallest = index;
            if (leftChildIndex < th_heapArray.length && th_heapArray[leftChildIndex] < th_heapArray[smallest]) {
                smallest = leftChildIndex;
            }
            if (rightChildIndex < th_heapArray.length && th_heapArray[rightChildIndex] < th_heapArray[smallest]) {
                smallest = rightChildIndex;
            }
            if (smallest !== index) {
                [th_heapArray[index], th_heapArray[smallest]] = [th_heapArray[smallest], th_heapArray[index]]; // Swap
                th_siftDown(smallest);
            }
        }
        
        function th_heapifyArray(arr) {
            th_heapArray = [...arr];
            for (let i = Math.floor(th_heapArray.length / 2) - 1; i >= 0; i--) {
                th_siftDown(i);
            }
        }

        function th_drawBstNode(svg, node, x, y, parentX, parentY, levelWidth) {
            if (!node) return;
            node.x = x; node.y = y;

            // Draw line from parent
            if (parentX !== null && parentY !== null) {
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", parentX); line.setAttribute("y1", parentY + NODE_RADIUS);
                line.setAttribute("x2", x); line.setAttribute("y2", y - NODE_RADIUS);
                line.setAttribute("stroke", "var(--gray-600)"); line.setAttribute("stroke-width", "2");
                line.classList.add('tree-edge-visual');
                svg.appendChild(line);
            }

            // Draw node circle
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", x); circle.setAttribute("cy", y);
            circle.setAttribute("r", NODE_RADIUS);
            circle.setAttribute("fill", "var(--primary-dark)");
            circle.setAttribute("stroke", "var(--primary)");
            circle.setAttribute("stroke-width", "2");
            circle.id = `svg-${node.id}`; // Link SVG element to node data
            svg.appendChild(circle);

            // Draw node value
            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("x", x); text.setAttribute("y", y + NODE_RADIUS / 4); // Adjust for better centering
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("fill", "var(--white)");
            text.setAttribute("font-size", "0.8em");
            text.textContent = node.value;
            svg.appendChild(text);
            
            // Recursively draw children
            const nextLevelWidth = levelWidth / 2;
            if (node.left) th_drawBstNode(svg, node.left, x - nextLevelWidth, y + VERTICAL_SPACING, x, y, nextLevelWidth);
            if (node.right) th_drawBstNode(svg, node.right, x + nextLevelWidth, y + VERTICAL_SPACING, x, y, nextLevelWidth);
        }

        function th_visualizeBst() {
            const vizArea = document.getElementById('th-visualization-area');
            vizArea.innerHTML = ''; // Clear placeholder or previous
            if (!th_bstRoot) {
                vizArea.innerHTML = `<div class="viz-placeholder" id="thVizPlaceholder" style="text-align: center; width:100%;"><i class="fas fa-leaf" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i><span style="color: var(--gray-500);">BST is empty.</span></div>`;
                return;
            }

            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            // Calculate SVG dimensions dynamically (very basic)
            function getTreeDepth(node) {
                if (!node) return 0;
                return 1 + Math.max(getTreeDepth(node.left), getTreeDepth(node.right));
            }
            const depth = getTreeDepth(th_bstRoot);
            const maxWidth = Math.pow(2, depth -1) * HORIZONTAL_SPACING * 1.5; // Approximate max width
            svg.setAttribute("width", Math.max(300, maxWidth));
            svg.setAttribute("height", depth * VERTICAL_SPACING + NODE_RADIUS * 2);
            svg.style.overflow = "visible";

            const initialX = parseFloat(svg.getAttribute("width")) / 2;
            const initialY = NODE_RADIUS + 10;
            const initialLevelWidth = parseFloat(svg.getAttribute("width")) / 3; // Adjust initial spacing based on overall width

            th_drawBstNode(svg, th_bstRoot, initialX, initialY, null, null, initialLevelWidth);
            vizArea.appendChild(svg);
        }

        async function th_animateSearchPath(path) {
            for (const step of path) {
                const nodeEl = document.getElementById(`svg-${step.id}`);
                if (nodeEl) {
                    nodeEl.setAttribute("fill", step.found ? "var(--success)" : "var(--accent)");
                    await new Promise(resolve => setTimeout(resolve, 400));
                }
            }
            // Reset colors after a delay
            setTimeout(() => {
                path.forEach(step => {
                    const nodeEl = document.getElementById(`svg-${step.id}`);
                    if(nodeEl) nodeEl.setAttribute("fill", "var(--primary-dark)");
                });
            }, 1500);
        }

        function th_visualizeHeap() {
            const vizArea = document.getElementById('th-visualization-area');
            vizArea.innerHTML = ''; // Clear placeholder or previous
            if (th_heapArray.length === 0) {
                vizArea.innerHTML = `<div class="viz-placeholder" id="thVizPlaceholder" style="text-align: center; width:100%;"><i class="fas fa-leaf" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i><span style="color: var(--gray-500);">Heap is empty.</span></div>`;
                return;
            }

            // Simple array visualization for heap for now
            const container = document.createElement('div');
            container.style.display = 'flex';
            container.style.flexWrap = 'wrap';
            container.style.gap = '10px';
            container.style.justifyContent = 'center';

            th_heapArray.forEach((value, index) => {
                const heapNodeDiv = document.createElement('div');
                heapNodeDiv.className = 'sq-item heap-node-visual'; // Use similar styling to stack/queue items
                heapNodeDiv.textContent = escapeHtml(value.toString());
                if (index === 0) { // Root
                    heapNodeDiv.style.borderColor = 'var(--accent)';
                    heapNodeDiv.style.boxShadow = '0 0 8px var(--accent)';
                }
                container.appendChild(heapNodeDiv);
            });
            vizArea.appendChild(container);
            // A proper tree-like visualization for heap array is more complex and can be added later
        }

        function th_handleBstOperation(operation) {
            const valueInput = document.getElementById('thNodeValue');
            const valueStr = valueInput.value.trim();
            const values = valueStr.split(',').map(v => parseInt(v.trim())).filter(v => !isNaN(v));

            if ((operation === 'insert' || operation === 'delete' || operation === 'search') && values.length !== 1) {
                th_logEvent(`Error: Please enter a single number for BST ${operation}.`, 'error');
                return;
            }
            const singleValue = values[0];


            switch (operation) {
                case 'insert':
                    if (valueStr === "") { th_logEvent('Error: Value cannot be empty for insert.', 'error'); return; }
                    if (isNaN(singleValue)) { th_logEvent('Error: Invalid number for insert.', 'error'); return; }
                    th_bstRoot = th_insertBstNode(th_bstRoot, singleValue);
                    th_logEvent(`Inserted ${singleValue} into BST.`);
                    break;
                case 'delete':
                    if (valueStr === "") { th_logEvent('Error: Value cannot be empty for delete.', 'error'); return; }
                    if (isNaN(singleValue)) { th_logEvent('Error: Invalid number for delete.', 'error'); return; }
                    th_bstRoot = th_deleteBstNode(th_bstRoot, singleValue);
                    // Log message is handled inside th_deleteBstNode
                    break;
                case 'search':
                    if (valueStr === "") { th_logEvent('Error: Value cannot be empty for search.', 'error'); return; }
                    if (isNaN(singleValue)) { th_logEvent('Error: Invalid number for search.', 'error'); return; }
                    const searchResult = th_searchBstNode(th_bstRoot, singleValue);
                    th_logEvent(`Search for ${singleValue}: ${searchResult.found ? 'Found!' : 'Not Found.'} Path: ${searchResult.path.map(p=>p.value).join('->')}`);
                    if (searchResult.path.length > 0) th_animateSearchPath(searchResult.path);
                    break;
                case 'traverse':
                    const traversalType = document.getElementById('thTraversalType').value;
                    const result = th_getTraversalResult(th_bstRoot, traversalType);
                    th_logEvent(`${traversalType.charAt(0).toUpperCase() + traversalType.slice(1)} Traversal: ${result.join(', ')}`);
                    break;
            }
            if (operation !== 'search') th_visualizeBst(); // Re-render unless it's search (search animates)
            if(operation === 'insert' || operation === 'delete') valueInput.value = '';
        }

        function th_handleHeapOperation(operation) {
            const valueInput = document.getElementById('thNodeValue');
            const valueStr = valueInput.value.trim();
            const values = valueStr.split(',').map(v => parseInt(v.trim())).filter(v => !isNaN(v));

            switch (operation) {
                case 'insert':
                    if (values.length !== 1) { th_logEvent('Error: Please enter a single number for heap insert.', 'error'); return; }
                    const singleValue = values[0];
                    if (isNaN(singleValue)) { th_logEvent('Error: Invalid number for insert.', 'error'); return; }
                    th_heapInsert(singleValue);
                    th_logEvent(`Inserted ${singleValue} into Min-Heap.`);
                    break;
                case 'extractMin':
                    const min = th_heapExtractMin();
                    if (min !== null) {
                        th_logEvent(`Extracted Min: ${min} from Min-Heap.`, 'success');
                    } else {
                        th_logEvent('Heap is empty. Cannot extract min.', 'error');
                    }
                    break;
                case 'heapify':
                    if (values.length === 0 && valueStr !== "") { th_logEvent('Error: Invalid numbers for heapify. Enter comma-separated numbers.', 'error'); return; }
                    if (values.length > 0) {
                        th_heapifyArray(values);
                        th_logEvent(`Heapified array: [${values.join(', ')}] into Min-Heap.`, 'success');
                    } else {
                        th_logEvent(`Heapify called on current heap (or empty input). Re-heapifying.`, 'info');
                        th_heapifyArray([...th_heapArray]); // Re-heapify existing if no input
                    }
                    break;
            }
            th_visualizeHeap();
            valueInput.value = '';
        }

        function loadTreesHeapsContent() {
            const topicId = 'trees-heaps';

            const thCodeExample = `
        # --- Binary Tree Node ---
        class TreeNode:
            def __init__(self, key):
                self.key = key
                self.left = None
                self.right = None

        # --- Tree Traversals ---
        def inorder_traversal(root):
            result = []
            if root:
                result.extend(inorder_traversal(root.left))
                result.append(root.key)
                result.extend(inorder_traversal(root.right))
            return result

        def preorder_traversal(root):
            result = []
            if root:
                result.append(root.key)
                result.extend(preorder_traversal(root.left))
                result.extend(preorder_traversal(root.right))
            return result

        def postorder_traversal(root):
            result = []
            if root:
                result.extend(postorder_traversal(root.left))
                result.extend(postorder_traversal(root.right))
                result.append(root.key)
            return result

        from collections import deque
        def levelorder_traversal(root):
            if not root: return []
            q, result = deque([root]), []
            while q:
                node = q.popleft()
                result.append(node.key)
                if node.left: q.append(node.left)
                if node.right: q.append(node.right)
            return result

        # --- Binary Search Tree (BST) Basic Operations ---
        def bst_insert(root, key):
            if not root:
                return TreeNode(key)
            if key < root.key:
                root.left = bst_insert(root.left, key)
            elif key > root.key:
                root.right = bst_insert(root.right, key)
            return root # No change if key already exists

        def bst_search(root, key):
            if not root or root.key == key:
                return root
            if key < root.key:
                return bst_search(root.left, key)
            return bst_search(root.right, key)

        # --- Min-Heap (using Python's heapq module for simplicity) ---
        import heapq

        # min_heap = []
        # heapq.heappush(min_heap, 5)
        # heapq.heappush(min_heap, 1)
        # heapq.heappush(min_heap, 3)
        # print(min_heap)  # Output: [1, 5, 3] (heap property maintained)
        # print(heapq.heappop(min_heap)) # Output: 1
        # print(min_heap) # Output: [3, 5]

        # To build a heap from a list in-place:
        # my_list = [5, 2, 8, 1, 9, 4]
        # heapq.heapify(my_list) # my_list is now a min-heap: [1, 2, 4, 5, 9, 8]

        # Conceptual array-based Min-Heap (as visualized in demo)
        # Parent(i) = floor((i-1)/2)
        # LeftChild(i) = 2*i + 1
        # RightChild(i) = 2*i + 2

        # Sift-up (for insert):
        # def sift_up(heap, index):
        #     parent_idx = (index - 1) // 2
        #     while index > 0 and heap[index] < heap[parent_idx]:
        #         heap[index], heap[parent_idx] = heap[parent_idx], heap[index]
        #         index = parent_idx
        #         parent_idx = (index - 1) // 2

        # Sift-down (for extract-min and heapify):
        # def sift_down(heap, index, heap_size):
        #     min_index = index
        #     left = 2 * index + 1
        #     if left < heap_size and heap[left] < heap[min_index]:
        #         min_index = left
        #     right = 2 * index + 2
        #     if right < heap_size and heap[right] < heap[min_index]:
        #         min_index = right
        #     if index != min_index:
        #         heap[index], heap[min_index] = heap[min_index], heap[index]
        #         sift_down(heap, min_index, heap_size)
            `;
            if (window.dsaContent && typeof window.dsaContent.addCodeExample === 'function') {
                window.dsaContent.addCodeExample(topicId, thCodeExample);
            }

            const thQuizSet = [
                { questionText: "In a Binary Search Tree (BST), where are values smaller than the root node typically found?", options: ["Right subtree", "Left subtree", "At the same level", "Anywhere"], correctOptionIndex: 1 },
                { questionText: "Which tree traversal visits the root node last?", options: ["Pre-order", "In-order", "Post-order", "Level-order"], correctOptionIndex: 2 },
                { questionText: "What is the defining property of a Min-Heap?", options: ["Root is the largest value", "Every node's value is less than or equal to its children's values", "All leaves are at the same depth", "It's always a perfectly balanced tree"], correctOptionIndex: 1 },
                { questionText: "What is the typical time complexity for inserting an element into a binary heap?", options: ["O(1)", "O(log N)", "O(N)", "O(N log N)"], correctOptionIndex: 1 },
                { questionText: "Which data structure is commonly used to implement the Level-order traversal of a tree?", options: ["Stack", "Queue", "Heap", "Array"], correctOptionIndex: 1 }
            ];
            if (window.dsaContent && typeof window.dsaContent.updateQuiz === 'function') {
                window.dsaContent.updateQuiz(topicId, thQuizSet);
            }
            
            const demoTypeSelect = document.getElementById('thDemoTypeSelect');
            if (demoTypeSelect) {
                th_setupOperationControls(demoTypeSelect.value); // Initial setup
                demoTypeSelect.addEventListener('change', (event) => {
                    th_setupOperationControls(event.target.value);
                });
            }
            th_resetCurrentDemo(); // Initial render for placeholder
        }

        const thDemoStyle = document.createElement('style');
        thDemoStyle.id = 'th-demo-styles';
        thDemoStyle.innerHTML = `
            #th-visualization-area svg {
                display: block;
                margin: auto;
            }
            .heap-node-visual { /* Using sq-item style as base defined in Stacks/Queues */
                /* Add any heap-specific overrides if needed */
            }
            /* Styles for tree edges, if needed beyond SVG attributes */
            .tree-edge-visual {
                /* Example: marker-end: url(#arrowhead); */
            }
        `;
        if (!document.head.querySelector('#th-demo-styles')) {
            document.head.appendChild(thDemoStyle);
        }

        //  12, Disjoint Sets -----------------------------------------------------------------
        let ds_parent = [];    // Stores the parent of each element
        let ds_rank = [];      // Stores the rank (or size) for union by rank/size heuristic
        let ds_numElements = 0;
        let ds_vizElements = {}; // To store references to DOM elements for animation

        function ds_logEvent(message, type = 'info') {
            const logArea = document.getElementById('ds-output-log');
            if (logArea) {
                const newEntry = document.createElement('div');
                newEntry.innerHTML = message;
                if (type === 'error') newEntry.style.color = 'var(--error)';
                if (type === 'success') newEntry.style.color = 'var(--success)';
                logArea.insertBefore(newEntry, logArea.firstChild);
                if (logArea.children.length > 10) logArea.removeChild(logArea.lastChild);
            }
        }

        function ds_initializeSets() {
            const numElementsInput = document.getElementById('dsNumElements');
            ds_numElements = parseInt(numElementsInput.value);

            if (isNaN(ds_numElements) || ds_numElements < 3 || ds_numElements > 15) {
                ds_logEvent('Error: Number of elements must be between 3 and 15.', 'error');
                return;
            }

            ds_parent = new Array(ds_numElements);
            ds_rank = new Array(ds_numElements);
            ds_vizElements = {};

            for (let i = 0; i < ds_numElements; i++) {
                ds_parent[i] = i; // Each element is its own parent initially (MakeSet)
                ds_rank[i] = 0;   // Initial rank is 0
            }
            ds_logEvent(`Initialized ${ds_numElements} disjoint sets (0 to ${ds_numElements - 1}).`, 'success');
            ds_renderSets();
        }

        function ds_find_op(i) {
            if (ds_parent[i] === i) {
                return i;
            }
            // Path compression: make all nodes on path point directly to root
            ds_parent[i] = ds_find_op(ds_parent[i]);
            return ds_parent[i];
        }

        function ds_union_op(i, j) {
            if (i < 0 || i >= ds_numElements || j < 0 || j >= ds_numElements) {
                ds_logEvent(`Error: Invalid element values for Union. Must be between 0 and ${ds_numElements - 1}.`, 'error');
                return false;
            }
            const root_i = ds_find_op(i);
            const root_j = ds_find_op(j);

            if (root_i !== root_j) { // Only union if they are in different sets
                if (ds_rank[root_i] < ds_rank[root_j]) {
                    ds_parent[root_i] = root_j;
                } else if (ds_rank[root_i] > ds_rank[root_j]) {
                    ds_parent[root_j] = root_i;
                } else { // Ranks are same, make one parent and increment its rank
                    ds_parent[root_j] = root_i;
                    ds_rank[root_i]++;
                }
                ds_logEvent(`Union(${i}, ${j}): Merged sets. New representative might be ${ds_find_op(i)}. Ranks updated.`, 'success');
                return true;
            }
            ds_logEvent(`Union(${i}, ${j}): Elements already in the same set (Representative: ${root_i}). No action taken.`, 'info');
            return false;
        }

        function ds_renderSets() {
            const vizArea = document.getElementById('ds-visualization-area');
            vizArea.innerHTML = ''; // Clear previous
            ds_vizElements = {}; // Clear old DOM element references

            if (ds_numElements === 0) {
                vizArea.innerHTML = `<div class="viz-placeholder" id="dsVizPlaceholder" style="text-align: center; width:100%;"><i class="fas fa-sitemap" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i><span style="color: var(--gray-500);">Initialize sets to begin.</span></div>`;
                return;
            }

            // Create a map from parent to children to build tree structure for visualization
            const sets = {};
            for (let i = 0; i < ds_numElements; i++) {
                const root = ds_find_op(i); // Ensure path compression is reflected for finding root
                if (!sets[root]) {
                    sets[root] = [];
                }
                // Only add if it's not the root itself, or if it's a set of one
                if (i !== root || ds_parent[i] === i && !sets[root].includes(i) && Object.values(sets).every(s => !s.includes(i))) {
                    // Check if this element i has already been added as a child of another root due to path compression
                    let alreadyChild = false;
                    for(const r in sets){
                        if(sets[r].some(child => child.el === i && r != root)) {
                            alreadyChild = true;
                            break;
                        }
                    }
                    if(!alreadyChild) sets[root].push({el: i, isRoot: ds_parent[i] === i});
                }
            }
            // Add roots that might not have children explicitly listed yet
            for (let i = 0; i < ds_numElements; i++) {
                if (ds_parent[i] === i && !sets[i]) {
                    sets[i] = [{el: i, isRoot: true}];
                } else if (ds_parent[i] === i && sets[i] && !sets[i].some(item => item.el ===i && item.isRoot)) {
                    // Ensure root is in its own list if it has other children
                    if(!sets[i].find(n => n.el === i)) sets[i].unshift({el:i, isRoot:true});
                }
            }


            Object.keys(sets).forEach(rootValStr => {
                const rootVal = parseInt(rootValStr);
                const setContainer = document.createElement('div');
                setContainer.className = 'ds-set-container';
                setContainer.style.border = '1px solid var(--primary-dark)';
                setContainer.style.borderRadius = '8px';
                setContainer.style.padding = '10px';
                setContainer.style.margin = '5px';
                setContainer.style.minWidth = '80px';
                setContainer.style.textAlign = 'center';

                const rootElementDiv = document.createElement('div');
                rootElementDiv.className = 'ds-node-visual ds-root-visual';
                rootElementDiv.textContent = rootVal;
                rootElementDiv.id = `ds-node-${rootVal}`;
                ds_vizElements[rootVal] = rootElementDiv;
                setContainer.appendChild(rootElementDiv);

                const childrenContainer = document.createElement('div');
                childrenContainer.style.display = 'flex';
                childrenContainer.style.flexWrap = 'wrap';
                childrenContainer.style.justifyContent = 'center';
                childrenContainer.style.marginTop = '5px';

                sets[rootVal].filter(item => item.el !== rootVal).forEach(item => { // Display children
                    const childElementDiv = document.createElement('div');
                    childElementDiv.className = 'ds-node-visual';
                    childElementDiv.textContent = item.el;
                    childElementDiv.id = `ds-node-${item.el}`;
                    ds_vizElements[item.el] = childElementDiv;
                    childrenContainer.appendChild(childElementDiv);
                });
                if (childrenContainer.children.length > 0) {
                    setContainer.appendChild(childrenContainer);
                }
                vizArea.appendChild(setContainer);
            });
        }

        function ds_unionVisual() {
            const val1Input = document.getElementById('dsVal1');
            const val2Input = document.getElementById('dsVal2');
            const val1 = parseInt(val1Input.value);
            const val2 = parseInt(val2Input.value);

            if (isNaN(val1) || isNaN(val2)) {
                ds_logEvent('Error: Both values must be numbers for Union.', 'error');
                return;
            }
            if (ds_union_op(val1, val2)) { // If union happened
                ds_renderSets(); // Re-render to show changes
            }
            val1Input.value = '';
            val2Input.value = '';
        }

        async function ds_findVisual() {
            const val1Input = document.getElementById('dsVal1');
            const val = parseInt(val1Input.value);

            if (isNaN(val) || val < 0 || val >= ds_numElements) {
                ds_logEvent(`Error: Invalid element value for Find. Must be between 0 and ${ds_numElements - 1}.`, 'error');
                return;
            }

            // Animate path traversal
            let curr = val;
            const path = [];
            while(ds_parent[curr] !== curr) {
                path.push(curr);
                if(ds_vizElements[curr]) ds_vizElements[curr].style.backgroundColor = 'var(--accent-dark)';
                await new Promise(r => setTimeout(r, 200));
                curr = ds_parent[curr];
            }
            path.push(curr); // Add the root
            if(ds_vizElements[curr]) ds_vizElements[curr].style.backgroundColor = 'var(--success-dark)'; // Highlight root

            const root = ds_find_op(val); // This call also performs path compression
            ds_logEvent(`Find(${val}): Representative is ${root}. Path: ${path.join(' -> ')}. Path compression applied.`, 'success');
            
            // Re-render after a delay to show path compression effect
            setTimeout(() => {
                path.forEach(p => {
                    if(ds_vizElements[p]) ds_vizElements[p].style.backgroundColor = ''; // Reset color
                });
                ds_renderSets();
            }, 1000 + path.length * 100);
            val1Input.value = '';
        }

        function loadDisjointSetsContent() {
            const topicId = 'disjoint-sets';

            const dsCodeExample = `
        class DisjointSetUnion:
            def __init__(self, n):
                self.parent = list(range(n)) # Each element is its own parent initially
                self.rank = [0] * n          # For union by rank heuristic
                self.num_sets = n            # Optional: track number of disjoint sets

            def find(self, i):
                """Finds the representative (root) of the set containing i, with path compression."""
                if self.parent[i] == i:
                    return i
                self.parent[i] = self.find(self.parent[i]) # Path compression
                return self.parent[i]

            def union(self, i, j):
                """Merges the sets containing elements i and j using union by rank."""
                root_i = self.find(i)
                root_j = self.find(j)

                if root_i != root_j: # Only union if they are in different sets
                    if self.rank[root_i] < self.rank[root_j]:
                        self.parent[root_i] = root_j
                    elif self.rank[root_i] > self.rank[root_j]:
                        self.parent[root_j] = root_i
                    else: # Ranks are same, make one root parent of other, increment rank
                        self.parent[root_j] = root_i
                        self.rank[root_i] += 1
                    self.num_sets -= 1 # Optional
                    return True
                return False # Already in the same set

        # Example Usage:
        # dsu = DisjointSetUnion(5) # Initialize with 5 elements (0 to 4)
        # print(dsu.parent) # Output: [0, 1, 2, 3, 4]

        # dsu.union(0, 1)
        # dsu.union(2, 3)
        # dsu.union(0, 3) # Unioning sets {0,1} and {2,3}

        # print(f"Parent of 0: {dsu.find(0)}")
        # print(f"Parent of 1: {dsu.find(1)}")
        # print(f"Parent of 2: {dsu.find(2)}")
        # print(f"Parent of 3: {dsu.find(3)}")
        # print(f"Parent of 4: {dsu.find(4)}") # Should be 4

        # print(f"Are 1 and 3 in the same set? {'Yes' if dsu.find(1) == dsu.find(3) else 'No'}")
        # print(dsu.parent) # Parents after path compression and unions
        # print(f"Number of disjoint sets: {dsu.num_sets}")
            `;
            if (window.dsaContent && typeof window.dsaContent.addCodeExample === 'function') {
                window.dsaContent.addCodeExample(topicId, dsCodeExample);
            }

            const dsQuizSet = [
                { questionText: "What is the primary goal of the 'Find' operation in a DSU structure?", options: ["To merge two sets", "To return the representative element of a set", "To count the number of elements in a set", "To add a new element to a set"], correctOptionIndex: 1 },
                { questionText: "Path compression optimization is applied during which DSU operation?", options: ["MakeSet", "Union", "Find", "Both Union and Find"], correctOptionIndex: 2 },
                { questionText: "When using Union by Rank/Size, the tree with the smaller rank/size typically becomes:", options: ["The new root of the combined set", "A child of the root of the larger tree", "A separate new tree", "Its rank is doubled"], correctOptionIndex: 1 },
                { questionText: "What is a common application of the Disjoint Set Union data structure?", options: ["Sorting an array", "Implementing a hash table", "Kruskal's algorithm for Minimum Spanning Trees", "Depth-First Search traversal"], correctOptionIndex: 2 },
                { questionText: "With both path compression and union by rank/size, the amortized time complexity of Union and Find operations is nearly:", options: ["O(N)", "O(log N)", "O(N log N)", "O(α(N)) (inverse Ackermann function, nearly constant)"], correctOptionIndex: 3 }
            ];
            if (window.dsaContent && typeof window.dsaContent.updateQuiz === 'function') {
                window.dsaContent.updateQuiz(topicId, dsQuizSet);
            }
            ds_initializeSets(); // Initialize the demo
        }

        const dsDemoStyle = document.createElement('style');
        dsDemoStyle.id = 'ds-demo-styles';
        dsDemoStyle.innerHTML = `
            .ds-set-container {
                /* Styles defined in ds_renderSets for dynamic creation */
            }
            .ds-node-visual {
                background-color: var(--secondary-dark);
                color: var(--white);
                padding: 0.6rem 0.9rem;
                border: 1px solid var(--secondary);
                border-radius: 50%; /* Circular nodes */
                min-width: 35px;
                min-height: 35px;
                display: inline-flex; /* Use inline-flex for centering text in circle */
                align-items: center;
                justify-content: center;
                margin: 5px;
                font-size: 0.9em;
                transition: background-color 0.3s ease;
            }
            .ds-root-visual {
                background-color: var(--primary-dark);
                border-color: var(--primary);
                font-weight: bold;
            }
        `;
        if (!document.head.querySelector('#ds-demo-styles')) {
            document.head.appendChild(dsDemoStyle);
        }

        //  13, Graphs -----------------------------------------------------------------
        let gr_vertices = new Set();
        let gr_edges = new Map(); // adjacency list representation
        let gr_isDirected = false;
        let gr_vertexPositions = new Map(); // for visualization positioning
        let gr_traversalColors = new Map(); // for coloring during traversal

        function gr_logEvent(message, type = 'info') {
            const logArea = document.getElementById('gr-output-log');
            if (logArea) {
                const newEntry = document.createElement('div');
                newEntry.innerHTML = message;
                if (type === 'error') newEntry.style.color = 'var(--error)';
                if (type === 'success') newEntry.style.color = 'var(--success)';
                if (type === 'warning') newEntry.style.color = 'var(--warning)';
                logArea.insertBefore(newEntry, logArea.firstChild);
                if (logArea.children.length > 8) {
                    logArea.removeChild(logArea.lastChild);
                }
            }
        }

        function gr_addVertex() {
            const input = document.getElementById('graphVertexInput');
            const vertex = input.value.trim().toUpperCase();
            
            if (!vertex) {
                gr_logEvent('Error: Vertex name cannot be empty.', 'error');
                return;
            }
            
            if (!/^[A-Z]$/.test(vertex)) {
                gr_logEvent('Error: Vertex must be a single letter A-Z.', 'error');
                return;
            }
            
            if (gr_vertices.has(vertex)) {
                gr_logEvent(`Warning: Vertex "${vertex}" already exists.`, 'warning');
                return;
            }
            
            gr_vertices.add(vertex);
            gr_edges.set(vertex, []);
            gr_traversalColors.set(vertex, 'default');
            
            // Assign a position for visualization
            const angle = (gr_vertices.size - 1) * (2 * Math.PI / Math.max(6, gr_vertices.size));
            const radius = 80;
            const centerX = 150;
            const centerY = 150;
            const x = centerX + radius * Math.cos(angle);
            const y = centerY + radius * Math.sin(angle);
            gr_vertexPositions.set(vertex, { x, y });
            
            gr_logEvent(`Added vertex "${vertex}".`, 'success');
            input.value = '';
            gr_updateVisualization();
            gr_updateGraphInfo();
        }

        function gr_addEdge() {
            const fromInput = document.getElementById('graphEdgeFrom');
            const toInput = document.getElementById('graphEdgeTo');
            const from = fromInput.value.trim().toUpperCase();
            const to = toInput.value.trim().toUpperCase();
            
            if (!from || !to) {
                gr_logEvent('Error: Both vertices must be specified for an edge.', 'error');
                return;
            }
            
            if (!gr_vertices.has(from) || !gr_vertices.has(to)) {
                gr_logEvent('Error: Both vertices must exist before adding an edge.', 'error');
                return;
            }
            
            if (from === to) {
                gr_logEvent('Error: Self-loops are not supported in this demo.', 'error');
                return;
            }
            
            // Check if edge already exists
            if (gr_edges.get(from).includes(to)) {
                gr_logEvent(`Warning: Edge ${from} → ${to} already exists.`, 'warning');
                return;
            }
            
            // Add edge
            gr_edges.get(from).push(to);
            if (!gr_isDirected) {
                gr_edges.get(to).push(from);
            }
            
            const edgeType = gr_isDirected ? '→' : '↔';
            gr_logEvent(`Added edge ${from} ${edgeType} ${to}.`, 'success');
            
            fromInput.value = '';
            toInput.value = '';
            gr_updateVisualization();
            gr_updateGraphInfo();
        }

        function gr_toggleDirected() {
            const wasDirected = gr_isDirected;
            gr_isDirected = document.getElementById('graphDirected').checked;
            
            if (wasDirected && !gr_isDirected) {
                // Converting from directed to undirected - make all edges bidirectional
                gr_makeUndirected();
                gr_logEvent('Converted to undirected graph.', 'success');
            } else if (!wasDirected && gr_isDirected) {
                gr_logEvent('Converted to directed graph.', 'success');
            }
            
            gr_updateVisualization();
            gr_updateGraphInfo();
        }

        function gr_makeUndirected() {
            for (const [vertex, neighbors] of gr_edges) {
                for (const neighbor of neighbors) {
                    if (!gr_edges.get(neighbor).includes(vertex)) {
                        gr_edges.get(neighbor).push(vertex);
                    }
                }
            }
        }

        function gr_clearGraph() {
            gr_vertices.clear();
            gr_edges.clear();
            gr_vertexPositions.clear();
            gr_traversalColors.clear();
            gr_logEvent('Graph cleared.', 'success');
            gr_updateVisualization();
            gr_updateGraphInfo();
        }

        function gr_updateVisualization() {
            const viz = document.getElementById('gr-graph-visualization');
            if (!viz) return;
            
            if (gr_vertices.size === 0) {
                viz.innerHTML = `
                    <div class="viz-placeholder" style="text-align: center; color: var(--gray-500); margin-top: 100px;">
                        <i class="fas fa-project-diagram" style="font-size: 3rem; margin-bottom: 1rem; display: block;"></i>
                        Add vertices and edges to build your graph
                    </div>
                `;
                return;
            }
            
            let svgContent = '';
            
            // Draw edges first (so they appear behind vertices)
            const drawnEdges = new Set();
            for (const [from, neighbors] of gr_edges) {
                const fromPos = gr_vertexPositions.get(from);
                if (!fromPos) continue;
                
                for (const to of neighbors) {
                    const toPos = gr_vertexPositions.get(to);
                    if (!toPos) continue;
                    
                    const edgeKey = gr_isDirected ? `${from}->${to}` : [from, to].sort().join('-');
                    if (drawnEdges.has(edgeKey)) continue;
                    drawnEdges.add(edgeKey);
                    
                    if (gr_isDirected) {
                        // Draw directed edge with arrow
                        const angle = Math.atan2(toPos.y - fromPos.y, toPos.x - fromPos.x);
                        const arrowX = toPos.x - 15 * Math.cos(angle);
                        const arrowY = toPos.y - 15 * Math.sin(angle);
                        
                        svgContent += `
                            <line x1="${fromPos.x}" y1="${fromPos.y}" x2="${arrowX}" y2="${arrowY}" 
                                stroke="#6366f1" stroke-width="2" opacity="0.7"/>
                            <polygon points="${arrowX + 8 * Math.cos(angle - 0.3)},${arrowY + 8 * Math.sin(angle - 0.3)} 
                                            ${arrowX + 8 * Math.cos(angle + 0.3)},${arrowY + 8 * Math.sin(angle + 0.3)} 
                                            ${arrowX + 15 * Math.cos(angle)},${arrowY + 15 * Math.sin(angle)}" 
                                    fill="#6366f1" opacity="0.7"/>
                        `;
                    } else {
                        // Draw undirected edge
                        svgContent += `
                            <line x1="${fromPos.x}" y1="${fromPos.y}" x2="${toPos.x}" y2="${toPos.y}" 
                                stroke="#6366f1" stroke-width="2" opacity="0.7"/>
                        `;
                    }
                }
            }
            
            // Draw vertices
            for (const vertex of gr_vertices) {
                const pos = gr_vertexPositions.get(vertex);
                if (!pos) continue;
                
                const color = gr_getVertexColor(vertex);
                
                svgContent += `
                    <circle cx="${pos.x}" cy="${pos.y}" r="15" fill="${color}" stroke="#fff" stroke-width="2"/>
                    <text x="${pos.x}" y="${pos.y + 5}" text-anchor="middle" fill="#fff" font-weight="bold" font-size="14">
                        ${vertex}
                    </text>
                `;
            }
            
            viz.innerHTML = `
                <svg width="100%" height="300" viewBox="0 0 300 300" style="background: transparent;">
                    ${svgContent}
                </svg>
            `;
        }

        function gr_getVertexColor(vertex) {
            const colorState = gr_traversalColors.get(vertex) || 'default';
            const colors = {
                'default': '#6366f1',
                'visiting': '#f59e0b',
                'visited': '#10b981',
                'current': '#ef4444'
            };
            return colors[colorState] || colors['default'];
        }

        function gr_updateGraphInfo() {
            const infoDiv = document.getElementById('gr-graph-info');
            if (!infoDiv) return;
            
            let edgeCount = 0;
            for (const neighbors of gr_edges.values()) {
                edgeCount += neighbors.length;
            }
            if (!gr_isDirected) edgeCount /= 2; // Each undirected edge counted twice
            
            const graphType = gr_isDirected ? 'Directed' : 'Undirected';
            infoDiv.textContent = `Vertices: ${gr_vertices.size} | Edges: ${edgeCount} | Type: ${graphType}`;
        }

        function gr_runDFS() {
            const startInput = document.getElementById('graphStartVertex');
            const startVertex = startInput.value.trim().toUpperCase();
            
            if (!startVertex) {
                gr_logEvent('Error: Please specify a start vertex for DFS.', 'error');
                return;
            }
            
            if (!gr_vertices.has(startVertex)) {
                gr_logEvent('Error: Start vertex does not exist in the graph.', 'error');
                return;
            }
            
            gr_resetTraversal();
            
            const visited = new Set();
            const traversalOrder = [];
            const stack = [startVertex];
            
            // Simulate DFS with visualization
            let step = 0;
            const dfsStep = () => {
                if (stack.length === 0) {
                    gr_displayTraversalResult('DFS', traversalOrder);
                    gr_logEvent(`DFS completed. Order: ${traversalOrder.join(' → ')}`, 'success');
                    return;
                }
                
                const current = stack.pop();
                
                if (visited.has(current)) {
                    setTimeout(dfsStep, 300);
                    return;
                }
                
                visited.add(current);
                traversalOrder.push(current);
                gr_traversalColors.set(current, 'current');
                gr_updateVisualization();
                
                // Add unvisited neighbors to stack (in reverse order for correct traversal)
                const neighbors = gr_edges.get(current) || [];
                for (let i = neighbors.length - 1; i >= 0; i--) {
                    const neighbor = neighbors[i];
                    if (!visited.has(neighbor)) {
                        stack.push(neighbor);
                        if (gr_traversalColors.get(neighbor) === 'default') {
                            gr_traversalColors.set(neighbor, 'visiting');
                        }
                    }
                }
                
                setTimeout(() => {
                    gr_traversalColors.set(current, 'visited');
                    gr_updateVisualization();
                    setTimeout(dfsStep, 300);
                }, 500);
            };
            
            gr_logEvent(`Starting DFS from vertex "${startVertex}".`, 'success');
            dfsStep();
        }

        function gr_runBFS() {
            const startInput = document.getElementById('graphStartVertex');
            const startVertex = startInput.value.trim().toUpperCase();
            
            if (!startVertex) {
                gr_logEvent('Error: Please specify a start vertex for BFS.', 'error');
                return;
            }
            
            if (!gr_vertices.has(startVertex)) {
                gr_logEvent('Error: Start vertex does not exist in the graph.', 'error');
                return;
            }
            
            gr_resetTraversal();
            
            const visited = new Set();
            const traversalOrder = [];
            const queue = [startVertex];
            
            // Simulate BFS with visualization
            const bfsStep = () => {
                if (queue.length === 0) {
                    gr_displayTraversalResult('BFS', traversalOrder);
                    gr_logEvent(`BFS completed. Order: ${traversalOrder.join(' → ')}`, 'success');
                    return;
                }
                
                const current = queue.shift();
                
                if (visited.has(current)) {
                    setTimeout(bfsStep, 300);
                    return;
                }
                
                visited.add(current);
                traversalOrder.push(current);
                gr_traversalColors.set(current, 'current');
                gr_updateVisualization();
                
                // Add unvisited neighbors to queue
                const neighbors = gr_edges.get(current) || [];
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor) && !queue.includes(neighbor)) {
                        queue.push(neighbor);
                        if (gr_traversalColors.get(neighbor) === 'default') {
                            gr_traversalColors.set(neighbor, 'visiting');
                        }
                    }
                }
                
                setTimeout(() => {
                    gr_traversalColors.set(current, 'visited');
                    gr_updateVisualization();
                    setTimeout(bfsStep, 300);
                }, 500);
            };
            
            gr_logEvent(`Starting BFS from vertex "${startVertex}".`, 'success');
            bfsStep();
        }

        function gr_displayTraversalResult(algorithm, order) {
            const resultDiv = document.getElementById('gr-traversal-result');
            if (resultDiv) {
                resultDiv.innerHTML = `<strong>${algorithm}:</strong> ${order.join(' → ')}`;
            }
        }

        function gr_resetTraversal() {
            for (const vertex of gr_vertices) {
                gr_traversalColors.set(vertex, 'default');
            }
            gr_updateVisualization();
            
            const resultDiv = document.getElementById('gr-traversal-result');
            if (resultDiv) {
                resultDiv.textContent = 'Run DFS or BFS to see traversal order';
            }
        }

        function loadGraphsContent() {
            const topicId = 'graphs';

            const grCodeExample = `
        # --- Graph Implementation using Adjacency List ---
        from collections import defaultdict, deque

        class Graph:
            def __init__(self, directed=False):
                self.adjacency_list = defaultdict(list)
                self.directed = directed
            
            def add_vertex(self, vertex):
                """Add a vertex to the graph."""
                if vertex not in self.adjacency_list:
                    self.adjacency_list[vertex] = []
            
            def add_edge(self, from_vertex, to_vertex, weight=1):
                """Add an edge between two vertices."""
                self.adjacency_list[from_vertex].append((to_vertex, weight))
                if not self.directed:
                    self.adjacency_list[to_vertex].append((from_vertex, weight))
            
            def get_vertices(self):
                """Return all vertices in the graph."""
                return list(self.adjacency_list.keys())
            
            def get_neighbors(self, vertex):
                """Return neighbors of a given vertex."""
                return self.adjacency_list[vertex]
            
            def has_edge(self, from_vertex, to_vertex):
                """Check if an edge exists between two vertices."""
                neighbors = [neighbor for neighbor, _ in self.adjacency_list[from_vertex]]
                return to_vertex in neighbors
            
            def dfs(self, start_vertex, visited=None):
                """Depth-First Search traversal."""
                if visited is None:
                    visited = set()
                
                visited.add(start_vertex)
                result = [start_vertex]
                
                for neighbor, _ in self.adjacency_list[start_vertex]:
                    if neighbor not in visited:
                        result.extend(self.dfs(neighbor, visited))
                
                return result
            
            def bfs(self, start_vertex):
                """Breadth-First Search traversal."""
                visited = set()
                queue = deque([start_vertex])
                result = []
                
                while queue:
                    vertex = queue.popleft()
                    if vertex not in visited:
                        visited.add(vertex)
                        result.append(vertex)
                        
                        for neighbor, _ in self.adjacency_list[vertex]:
                            if neighbor not in visited:
                                queue.append(neighbor)
                
                return result
            
            def has_cycle(self):
                """Check if the graph has a cycle using DFS."""
                visited = set()
                rec_stack = set()
                
                def dfs_cycle_check(vertex):
                    visited.add(vertex)
                    rec_stack.add(vertex)
                    
                    for neighbor, _ in self.adjacency_list[vertex]:
                        if neighbor not in visited:
                            if dfs_cycle_check(neighbor):
                                return True
                        elif neighbor in rec_stack:
                            return True
                    
                    rec_stack.remove(vertex)
                    return False
                
                for vertex in self.adjacency_list:
                    if vertex not in visited:
                        if dfs_cycle_check(vertex):
                            return True
                return False
            
            def shortest_path_unweighted(self, start, end):
                """Find shortest path between two vertices (unweighted graph)."""
                if start == end:
                    return [start]
                
                visited = set()
                queue = deque([(start, [start])])
                
                while queue:
                    vertex, path = queue.popleft()
                    if vertex in visited:
                        continue
                        
                    visited.add(vertex)
                    
                    for neighbor, _ in self.adjacency_list[vertex]:
                        new_path = path + [neighbor]
                        if neighbor == end:
                            return new_path
                            if neighbor not in visited:
                                queue.append((neighbor, new_path))
                    return None

                Example Usage:
                g = Graph(directed=False)
                g.add_vertex('A')
                g.add_vertex('B')
                g.add_edge('A', 'B')
                print(g.dfs('A'))  # ['A', 'B']
                print(g.bfs('A'))  # ['A', 'B']
                print(g.shortest_path_unweighted('A', 'B'))  # ['A', 'B']
                `;
            if (window.dsaContent && typeof window.dsaContent.addCodeExample === 'function') {
                window.dsaContent.addCodeExample(topicId, grCodeExample);
            }

            const grQuizSet = [
                {
                    questionText: "Which data structure is commonly used to implement Breadth-First Search (BFS)?",
                    options: ["Stack", "Queue", "Priority Queue", "Hash Table"],
                    correctOptionIndex: 1
                },
                {
                    questionText: "In an adjacency matrix representation of a graph with V vertices, what is the space complexity?",
                    options: ["O(V + E)", "O(V²)", "O(E)", "O(log V)"],
                    correctOptionIndex: 1
                },
                {
                    questionText: "What is the primary advantage of using an adjacency list over an adjacency matrix for sparse graphs?",
                    options: ["Faster edge lookup", "Lower space usage", "Simpler implementation", "Guaranteed O(1) time to find neighbors"],
                    correctOptionIndex: 1
                },
                {
                    questionText: "Which traversal would you use to find the shortest path in an unweighted graph?",
                    options: ["Depth-First Search (DFS)", "Dijkstra's Algorithm", "Breadth-First Search (BFS)", "Topological Sort"],
                    correctOptionIndex: 2
                },
                {
                    questionText: "To detect a cycle in a directed graph, which additional data structure is commonly used alongside DFS?",
                    options: ["Visited Set", "Priority Queue", "Recursion Stack", "Disjoint Set Union (DSU)"],
                    correctOptionIndex: 2
                }
            ];
            if (window.dsaContent && typeof window.dsaContent.updateQuiz === 'function') {
                window.dsaContent.updateQuiz(topicId, grQuizSet);
            }
            gr_clearGraph(); // Initialize the interactive demo with an empty graph
        }

        //  14, Sorting Algorithms -----------------------------------------------------------------
        let sort_arrayData = [];
        let sort_isAnimating = false;
        let sort_animationSpeed = 500;
        let sort_comparisons = 0;
        let sort_swaps = 0;

        function sort_generateArray() {
            if (sort_isAnimating) return;
            
            const size = parseInt(document.getElementById('arraySize').value);
            sort_arrayData = [];
            
            // Generate random array
            for (let i = 0; i < size; i++) {
                sort_arrayData.push(Math.floor(Math.random() * 100) + 1);
            }
            
            sort_resetCounters();
            sort_renderArray();
            sort_updateStatus('Array generated');
        }

        function sort_renderArray() {
            const vizArea = document.getElementById('sorting-visualization');
            vizArea.innerHTML = '';
            
            if (sort_arrayData.length === 0) {
                vizArea.innerHTML = '<span class="viz-placeholder" style="color: var(--gray-500);">Click \'New Array\' to generate data</span>';
                return;
            }
            
            const maxValue = Math.max(...sort_arrayData);
            const barWidth = Math.max(20, Math.min(40, (vizArea.offsetWidth - sort_arrayData.length * 4) / sort_arrayData.length));
            
            sort_arrayData.forEach((value, index) => {
                const bar = document.createElement('div');
                bar.className = 'sort-bar';
                bar.id = `bar-${index}`;
                bar.style.width = `${barWidth}px`;
                bar.style.height = `${(value / maxValue) * 150}px`;
                bar.style.backgroundColor = 'var(--primary)';
                bar.style.display = 'flex';
                bar.style.alignItems = 'end';
                bar.style.justifyContent = 'center';
                bar.style.margin = '0 1px';
                bar.style.transition = 'all 0.3s ease';
                bar.style.borderRadius = '4px 4px 0 0';
                bar.innerHTML = `<span style="color: white; font-size: 0.8em; margin-bottom: 2px;">${value}</span>`;
                vizArea.appendChild(bar);
            });
        }

        function sort_highlightBars(indices, color = 'var(--accent)') {
            // Clear previous highlights
            document.querySelectorAll('.sort-bar').forEach(bar => {
                bar.style.backgroundColor = 'var(--primary)';
            });
            
            // Highlight specified bars
            indices.forEach(index => {
                const bar = document.getElementById(`bar-${index}`);
                if (bar) {
                    bar.style.backgroundColor = color;
                }
            });
        }

        function sort_swapBars(i, j) {
            const bar1 = document.getElementById(`bar-${i}`);
            const bar2 = document.getElementById(`bar-${j}`);
            
            if (bar1 && bar2) {
                // Visual swap animation
                const temp = bar1.style.transform;
                bar1.style.transform = bar2.style.transform;
                bar2.style.transform = temp;
                
                // Update IDs after visual swap
                setTimeout(() => {
                    bar1.id = `bar-${j}`;
                    bar2.id = `bar-${i}`;
                }, 300);
            }
        }

        async function sort_startSorting() {
            if (sort_isAnimating || sort_arrayData.length === 0) return;
            
            sort_isAnimating = true;
            sort_resetCounters();
            
            const algorithm = document.getElementById('sortingAlgorithm').value;
            sort_updateStatus(`Sorting with ${algorithm} sort...`);
            
            try {
                switch(algorithm) {
                    case 'bubble':
                        await sort_bubbleSort();
                        break;
                    case 'selection':
                        await sort_selectionSort();
                        break;
                    case 'insertion':
                        await sort_insertionSort();
                        break;
                    case 'merge':
                        await sort_mergeSort(0, sort_arrayData.length - 1);
                        break;
                    case 'quick':
                        await sort_quickSort(0, sort_arrayData.length - 1);
                        break;
                }
                sort_updateStatus('Sorting completed!');
                sort_highlightBars(Array.from({length: sort_arrayData.length}, (_, i) => i), 'var(--success)');
            } catch (error) {
                sort_updateStatus('Sorting interrupted');
            }
            
            sort_isAnimating = false;
        }

        async function sort_bubbleSort() {
            const n = sort_arrayData.length;
            
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    sort_highlightBars([j, j + 1], 'var(--warning)');
                    await sort_sleep(sort_animationSpeed);
                    
                    sort_comparisons++;
                    sort_updateCounters();
                    
                    if (sort_arrayData[j] > sort_arrayData[j + 1]) {
                        // Swap
                        [sort_arrayData[j], sort_arrayData[j + 1]] = [sort_arrayData[j + 1], sort_arrayData[j]];
                        sort_swaps++;
                        sort_swapBars(j, j + 1);
                        await sort_sleep(sort_animationSpeed);
                    }
                }
                // Mark sorted position
                sort_highlightBars([n - i - 1], 'var(--success)');
            }
        }

        async function sort_selectionSort() {
            const n = sort_arrayData.length;
            
            for (let i = 0; i < n - 1; i++) {
                let minIdx = i;
                sort_highlightBars([i], 'var(--warning)');
                
                for (let j = i + 1; j < n; j++) {
                    sort_highlightBars([i, j, minIdx], 'var(--warning)');
                    await sort_sleep(sort_animationSpeed);
                    
                    sort_comparisons++;
                    sort_updateCounters();
                    
                    if (sort_arrayData[j] < sort_arrayData[minIdx]) {
                        minIdx = j;
                    }
                }
                
                if (minIdx !== i) {
                    [sort_arrayData[i], sort_arrayData[minIdx]] = [sort_arrayData[minIdx], sort_arrayData[i]];
                    sort_swaps++;
                    sort_swapBars(i, minIdx);
                    await sort_sleep(sort_animationSpeed);
                }
                
                sort_highlightBars([i], 'var(--success)');
            }
        }

        async function sort_insertionSort() {
            const n = sort_arrayData.length;
            
            for (let i = 1; i < n; i++) {
                let key = sort_arrayData[i];
                let j = i - 1;
                
                sort_highlightBars([i], 'var(--warning)');
                await sort_sleep(sort_animationSpeed);
                
                while (j >= 0) {
                    sort_highlightBars([j, j + 1], 'var(--warning)');
                    await sort_sleep(sort_animationSpeed);
                    
                    sort_comparisons++;
                    sort_updateCounters();
                    
                    if (sort_arrayData[j] > key) {
                        sort_arrayData[j + 1] = sort_arrayData[j];
                        sort_swaps++;
                        sort_swapBars(j, j + 1);
                        await sort_sleep(sort_animationSpeed);
                        j--;
                    } else {
                        break;
                    }
                }
                sort_arrayData[j + 1] = key;
            }
        }

        async function sort_mergeSort(left, right) {
            if (left < right) {
                const mid = Math.floor((left + right) / 2);
                
                await sort_mergeSort(left, mid);
                await sort_mergeSort(mid + 1, right);
                await sort_merge(left, mid, right);
            }
        }

        async function sort_merge(left, mid, right) {
            const leftArr = sort_arrayData.slice(left, mid + 1);
            const rightArr = sort_arrayData.slice(mid + 1, right + 1);
            
            let i = 0, j = 0, k = left;
            
            while (i < leftArr.length && j < rightArr.length) {
                sort_highlightBars([k], 'var(--warning)');
                await sort_sleep(sort_animationSpeed);
                
                sort_comparisons++;
                sort_updateCounters();
                
                if (leftArr[i] <= rightArr[j]) {
                    sort_arrayData[k] = leftArr[i];
                    i++;
                } else {
                    sort_arrayData[k] = rightArr[j];
                    j++;
                }
                k++;
                sort_renderArray();
            }
            
            while (i < leftArr.length) {
                sort_arrayData[k] = leftArr[i];
                i++;
                k++;
            }
            
            while (j < rightArr.length) {
                sort_arrayData[k] = rightArr[j];
                j++;
                k++;
            }
            
            sort_renderArray();
        }

        async function sort_quickSort(low, high) {
            if (low < high) {
                const pi = await sort_partition(low, high);
                await sort_quickSort(low, pi - 1);
                await sort_quickSort(pi + 1, high);
            }
        }

        async function sort_partition(low, high) {
            const pivot = sort_arrayData[high];
            let i = low - 1;
            
            sort_highlightBars([high], 'var(--error)'); // Pivot in red
            
            for (let j = low; j < high; j++) {
                sort_highlightBars([j, high], 'var(--warning)');
                await sort_sleep(sort_animationSpeed);
                
                sort_comparisons++;
                sort_updateCounters();
                
                if (sort_arrayData[j] < pivot) {
                    i++;
                    if (i !== j) {
                        [sort_arrayData[i], sort_arrayData[j]] = [sort_arrayData[j], sort_arrayData[i]];
                        sort_swaps++;
                        sort_swapBars(i, j);
                        await sort_sleep(sort_animationSpeed);
                    }
                }
            }
            
            [sort_arrayData[i + 1], sort_arrayData[high]] = [sort_arrayData[high], sort_arrayData[i + 1]];
            sort_swaps++;
            sort_swapBars(i + 1, high);
            await sort_sleep(sort_animationSpeed);
            
            return i + 1;
        }

        function sort_sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function sort_resetCounters() {
            sort_comparisons = 0;
            sort_swaps = 0;
            sort_updateCounters();
        }

        function sort_updateCounters() {
            document.getElementById('sortComparisons').textContent = sort_comparisons;
            document.getElementById('sortSwaps').textContent = sort_swaps;
        }

        function sort_updateStatus(status) {
            document.getElementById('sortStatus').textContent = status;
        }

        function sort_resetDemo() {
            sort_isAnimating = false;
            sort_arrayData = [];
            sort_resetCounters();
            sort_updateStatus('Ready');
            sort_renderArray();
        }

        // Initialize sorting content
        function loadSortingContent() {
            const topicId = 'sorting';
            
            // Setup array size slider
            const slider = document.getElementById('arraySize');
            const sizeDisplay = document.getElementById('arraySizeValue');
            
            if (slider && sizeDisplay) {
                slider.addEventListener('input', () => {
                    sizeDisplay.textContent = slider.value;
                });
            }
            
            // Code example
            const sortingCodeExample = `
        # --- Bubble Sort ---
        def bubble_sort(arr):
            n = len(arr)
            for i in range(n - 1):
                for j in range(n - i - 1):
                    if arr[j] > arr[j + 1]:
                        arr[j], arr[j + 1] = arr[j + 1], arr[j]
            return arr

        # --- Selection Sort ---
        def selection_sort(arr):
            n = len(arr)
            for i in range(n - 1):
                min_idx = i
                for j in range(i + 1, n):
                    if arr[j] < arr[min_idx]:
                        min_idx = j
                arr[i], arr[min_idx] = arr[min_idx], arr[i]
            return arr

        # --- Insertion Sort ---
        def insertion_sort(arr):
            for i in range(1, len(arr)):
                key = arr[i]
                j = i - 1
                while j >= 0 and arr[j] > key:
                    arr[j + 1] = arr[j]
                    j -= 1
                arr[j + 1] = key
            return arr

        # --- Merge Sort ---
        def merge_sort(arr):
            if len(arr) <= 1:
                return arr
            
            mid = len(arr) // 2
            left = merge_sort(arr[:mid])
            right = merge_sort(arr[mid:])
            
            return merge(left, right)

        def merge(left, right):
            result = []
            i = j = 0
            
            while i < len(left) and j < len(right):
                if left[i] <= right[j]:
                    result.append(left[i])
                    i += 1
                else:
                    result.append(right[j])
                    j += 1
            
            result.extend(left[i:])
            result.extend(right[j:])
            return result

        # --- Quick Sort ---
        def quick_sort(arr, low=0, high=None):
            if high is None:
                high = len(arr) - 1
            
            if low < high:
                pi = partition(arr, low, high)
                quick_sort(arr, low, pi - 1)
                quick_sort(arr, pi + 1, high)
            
            return arr

        def partition(arr, low, high):
            pivot = arr[high]
            i = low - 1
            
            for j in range(low, high):
                if arr[j] < pivot:
                    i += 1
                    arr[i], arr[j] = arr[j], arr[i]
            
            arr[i + 1], arr[high] = arr[high], arr[i + 1]
            return i + 1

        # --- Counting Sort (Non-comparison) ---
        def counting_sort(arr):
            if not arr:
                return arr
            
            max_val = max(arr)
            min_val = min(arr)
            range_val = max_val - min_val + 1
            
            count = [0] * range_val
            output = [0] * len(arr)
            
            # Count occurrences
            for num in arr:
                count[num - min_val] += 1
            
            # Calculate cumulative count
            for i in range(1, range_val):
                count[i] += count[i - 1]
            
            # Build output array
            for i in range(len(arr) - 1, -1, -1):
                output[count[arr[i] - min_val] - 1] = arr[i]
                count[arr[i] - min_val] -= 1
            
            return output

        # Example usage:
        # data = [64, 34, 25, 12, 22, 11, 90]
        # print("Original:", data)
        # print("Bubble Sort:", bubble_sort(data.copy()))
        # print("Quick Sort:", quick_sort(data.copy()))
            `;
            
            if (window.dsaContent && typeof window.dsaContent.addCodeExample === 'function') {
                window.dsaContent.addCodeExample(topicId, sortingCodeExample);
            }
            
            // Quiz questions
            const sortingQuizSet = [
                {
                    questionText: "Which sorting algorithm has the best average-case time complexity?",
                    options: ["Bubble Sort - O(n²)", "Merge Sort - O(n log n)", "Selection Sort - O(n²)", "Insertion Sort - O(n²)"],
                    correctOptionIndex: 1
                },
                {
                    questionText: "Which property describes a sorting algorithm that maintains the relative order of equal elements?",
                    options: ["In-place", "Stable", "Adaptive", "Online"],
                    correctOptionIndex: 1
                },
                {
                    questionText: "What is the worst-case time complexity of Quick Sort?",
                    options: ["O(n)", "O(n log n)", "O(n²)", "O(n³)"],
                    correctOptionIndex: 2
                },
                {
                    questionText: "Which of these is NOT a comparison-based sorting algorithm?",
                    options: ["Merge Sort", "Heap Sort", "Counting Sort", "Quick Sort"],
                    correctOptionIndex: 2
                },
                {
                    questionText: "Which sorting algorithm is most efficient for small datasets or nearly sorted arrays?",
                    options: ["Bubble Sort", "Quick Sort", "Insertion Sort", "Merge Sort"],
                    correctOptionIndex: 2
                }
            ];
            
            if (window.dsaContent && typeof window.dsaContent.updateQuiz === 'function') {
                window.dsaContent.updateQuiz(topicId, sortingQuizSet);
            }
            
            // Initialize demo
            sort_resetDemo();
        }

        function showTopic(topicId) {
            // Hide all topic content
            const allTopics = document.querySelectorAll('.topic-content');
            allTopics.forEach(topic => {
                topic.classList.remove('active');
            });

            // Show selected topic
            const selectedTopic = document.getElementById(topicId);
            if (selectedTopic) {
                selectedTopic.classList.add('active');
                appState.currentTopic = topicId;
                
                // Update URL without page reload
                history.pushState({topic: topicId}, '', `#${topicId}`);
                
                // Initialize topic-specific features
                initializeTopicFeatures(topicId);
            }
        }

        function updateActiveLink(activeLink) {
            // Remove active class from all links
            const allLinks = document.querySelectorAll('.topic-link');
            allLinks.forEach(link => link.classList.remove('active'));
            
            // Add active class to clicked link
            activeLink.classList.add('active');
        }

        function updateProgress() {
            const totalTopics = 24;
            const completed = appState.completedTopics.size;
            const progressPercent = (completed / totalTopics) * 100;
            
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            if (progressFill) {
                progressFill.style.width = progressPercent + '%';
            }
            
            if (progressText) {
                progressText.textContent = `${completed}/${totalTopics} topics completed`;
            }
            
            appState.progress = progressPercent;
        }

        function initializeTopicFeatures(topicId) {
            // Initialize code syntax highlighting
            if (window.Prism) {
                Prism.highlightAll();
            }
            
            // Initialize topic-specific demos
            initializeDemos(topicId);
            
            // Load topic progress
            loadTopicProgress(topicId);
        }

        function initializeDemos(topicId) {
            // Initialize demo state for the topic
            if (!appState.demos[topicId]) {
                appState.demos[topicId] = {
                    initialized: true,
                    state: 'ready'
                };
            }
        }

        function loadTopicProgress(topicId) {
            // Mark topic as visited
            if (!appState.completedTopics.has(topicId) && topicId !== 'welcome') {
                // Simulate progress tracking
                setTimeout(() => {
                    // Auto-mark as completed after viewing for demo purposes
                    // In real implementation, this would be based on actual completion criteria
                }, 5000);
            }
        }

        // Demo functions
        function runDemo(demoType) {
            if (demoType === 'data-types-explorer') {
                // Existing Data Types Explorer logic
                const viz = document.getElementById('data-types-viz');
                if (viz) {
                    viz.innerHTML = `
                        <div id="dataTypeExplorerUI" style="width: 100%; padding: 1rem; animation: fadeIn 0.5s ease;">
                            <p style="margin-bottom: 1rem; color: var(--gray-300); font-size: 0.95rem;">
                                Enter a Python literal (e.g., <code>"Hello"</code>, <code>123</code>, <code>[1, "a"]</code>, <code>{"key": "value"}</code>, <code>True</code>) to see its type and basic properties.
                            </p>
                            <div style="display: flex; flex-wrap: wrap; gap: 0.75rem; margin-bottom: 1.25rem; align-items: center;">
                                <input type="text" id="dataTypeInput" placeholder="Enter Python literal..." style="flex-grow: 1; min-width: 200px; padding: 0.65rem 0.9rem; border-radius: 8px; border: 1px solid var(--gray-600); background: var(--gray-800); color: var(--white); font-size: 0.95rem;">
                                <button class="btn" onclick="analyzeDataTypeInput()" style="padding: 0.65rem 1.2rem; font-size: 0.9rem;">Analyze</button>
                            </div>
                            <div id="dataTypeOutput" style="min-height: 120px; background: var(--gray-800); border-radius: 12px; padding: 1.25rem; border: 1px solid var(--gray-700); font-size: 0.9rem; line-height: 1.6;">
                                <p style="color: var(--gray-500);">Analysis will appear here...</p>
                            </div>
                        </div>
                    `;
                    const inputField = document.getElementById('dataTypeInput');
                    if (inputField) {
                        inputField.focus();
                        inputField.addEventListener('keypress', function(event) {
                            if (event.key === 'Enter') {
                                event.preventDefault();
                                analyzeDataTypeInput();
                            }
                        });
                    }
                }
            }
            else if (demoType === 'asymptotic-comparison') {
                // Asymptotic Analysis visualization logic
                const slider = document.getElementById('asymptoticN');
                const valueSpan = document.getElementById('asymptoticNValue');
                if (slider && valueSpan) {
                    const n = parseInt(slider.value, 10);
                    valueSpan.textContent = n;
                    createAsymptoticVisualization(n);
                } else {
                    console.warn(`Visualization area or slider for 'asymptotic-comparison' not found.`);
                }
            }
            else if (demoType === 'master-theorem' || demoType === 'master') {
                // Master Theorem analysis logic
                const aInput = document.getElementById('masterA');
                const bInput = document.getElementById('masterB');
                const fInput = document.getElementById('masterF');
                const kInput = document.getElementById('masterK');
                if (aInput && bInput && fInput && kInput) {
                    createMasterTheoremVisualization();
                } else {
                    console.warn(`Master Theorem input fields not found.`);
                }
            }
            else if (demoType === 'master-examples') {
                // Master Theorem examples logic
                createMasterExamplesVisualization();
            }
            else {
                // Generic spinner fallback for any other demoType
                const viz = document.getElementById(`${demoType}-viz`)
                        || document.getElementById(demoType + 'Viz')
                        || document.getElementById(demoType);
                if (viz) {
                    viz.innerHTML = `
                        <div style="text-align: center; color: var(--primary); padding: 2rem; animation: fadeIn 0.5s ease;">
                            <i class="fas fa-spinner fa-spin" style="font-size: 2.5rem; margin-bottom: 1rem; display: block;"></i>
                            <p style="font-size: 1.1rem;">Running ${demoType.replace(/-/g, ' ')} demonstration...</p>
                            <p style="font-size: 0.9rem; color: var(--gray-400); margin-top: 1rem;">
                                [Interactive content for this demo will be populated here]
                            </p>
                        </div>
                    `;
                    setTimeout(() => {
                        if (viz.querySelector && viz.querySelector('.fa-spinner')) {
                            viz.innerHTML = `
                                <div style="text-align: center; color: var(--success); padding: 2rem; animation: fadeIn 0.5s ease;">
                                    <i class="fas fa-check-circle" style="font-size: 2.5rem; margin-bottom: 1rem; display: block;"></i>
                                    <p style="font-size: 1.1rem;">Demo for ${demoType.replace(/-/g, ' ')} completed!</p>
                                    <p style="font-size: 0.9rem; color: var(--gray-400); margin-top: 1rem;">
                                        (Placeholder for ${demoType.replace(/-/g, ' ')} visualization)
                                    </p>
                                </div>
                            `;
                        }
                    }, 2000);
                } else {
                    console.warn(`Visualization area for demo type "${demoType}" not found.`);
                }
            }
        }

        function resetDemo(demoType) {
            if (demoType === 'data-types-explorer') {
                const viz = document.getElementById('data-types-viz');
                if (viz) {
                    viz.innerHTML = `
                        <div class="viz-placeholder" style="animation: fadeIn 0.5s ease;">
                            <i class="fas fa-flask" style="font-size: 3rem; margin-bottom: 1rem; display: block;"></i>
                            Interactive area to explore data types and their properties. <br/> Click "Explore Types" to start.
                        </div>
                    `;
                }
            }
            else if (demoType === 'asymptotic') {
                // Reset Asymptotic Analysis visualization
                const slider = document.getElementById('asymptoticN');
                const valueSpan = document.getElementById('asymptoticNValue');
                const vizArea = document.getElementById('asymptotic-viz');
                const resultsArea = document.getElementById('asymptotic-results');
                if (slider && valueSpan) {
                    slider.value = 10;
                    valueSpan.textContent = '10';
                }
                if (vizArea) {
                    vizArea.innerHTML = `
                        <div class="viz-placeholder">
                            <i class="fas fa-chart-line" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i>
                            <span style="color: var(--gray-500);">Click 'Update Chart' to visualize growth rates.</span>
                        </div>
                    `;
                }
                if (resultsArea) {
                    resultsArea.innerHTML = '';
                }
            }
            else if (demoType === 'master-theorem' || demoType === 'master') {
                // Reset Master Theorem visualization
                const aInput = document.getElementById('masterA');
                const bInput = document.getElementById('masterB');
                const fInput = document.getElementById('masterF');
                const kInput = document.getElementById('masterK');
                const vizArea = document.getElementById('master-viz');
                if (aInput) aInput.value = 2;
                if (bInput) bInput.value = 2;
                if (fInput) fInput.value = 1;
                if (kInput) kInput.value = 0;
                if (vizArea) {
                    vizArea.innerHTML = `
                        <div class="viz-placeholder">
                            <i class="fas fa-calculator" style="font-size: 3rem; margin-bottom: 1rem; display: block; color: var(--gray-500);"></i>
                            <span style="color: var(--gray-500);">Enter parameters and click 'Analyze Recurrence' to see the Master Theorem analysis.</span>
                        </div>
                    `;
                }
            }
            else {
                // Generic reset logic for other demo types
                const viz = document.getElementById(`${demoType}-viz`)
                        || document.getElementById(demoType + 'Viz')
                        || document.getElementById(demoType);
                if (viz) {
                    viz.innerHTML = `
                        <div class="viz-placeholder" style="animation: fadeIn 0.5s ease;">
                            <i class="fas fa-play-circle" style="font-size: 3rem; margin-bottom: 1rem; display: block;"></i>
                            Click "Run Example" to see the demonstration for ${demoType.replace(/-/g, ' ')}.
                        </div>
                    `;
                } else {
                    console.warn(`Visualization area for demo type "${demoType}" to reset not found.`);
                }
            }
        }

        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') {
                // If it's not a string, try to convert it or return an empty string
                try {
                    unsafe = String(unsafe);
                } catch (e) {
                    return '';
                }
            }
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
        // Sorting visualization functions
        function visualizeSort(algorithm) {
            const viz = document.getElementById('sorting-viz');
            if (viz) {
                viz.innerHTML = `
                    <div style="text-align: center; color: var(--primary);">
                        <i class="fas fa-sort" style="font-size: 2rem; margin-bottom: 1rem; display: block;"></i>
                        <p>Visualizing ${algorithm} sort algorithm...</p>
                        <div style="margin-top: 2rem;">
                            <div style="display: flex; justify-content: center; gap: 4px; margin-bottom: 1rem;">
                                ${generateSortBars()}
                            </div>
                            <p style="font-size: 0.9rem; color: var(--gray-400);">
                                [Interactive sorting animation will be implemented here]
                            </p>
                        </div>
                    </div>
                `;
            }
        }

        function generateSortBars() {
            const bars = [];
            const heights = [40, 80, 30, 90, 60, 20, 70, 50];
            
            for (let i = 0; i < heights.length; i++) {
                bars.push(`
                    <div style="
                        width: 30px;
                        height: ${heights[i]}px;
                        background: var(--gradient-1);
                        border-radius: 4px;
                        display: flex;
                        align-items: flex-end;
                        justify-content: center;
                        color: white;
                        font-size: 0.8rem;
                        font-weight: bold;
                        padding-bottom: 4px;
                    ">${heights[i]}</div>
                `);
            }
            
            return bars.join('');
        }

        function generateArray() {
            visualizeSort('random');
        }

        // Dynamic Programming functions
        function solveDP(problem) {
            const viz = document.getElementById('dp-viz');
            if (viz) {
                viz.innerHTML = `
                    <div style="text-align: center; color: var(--primary);">
                        <i class="fas fa-chess" style="font-size: 2rem; margin-bottom: 1rem; display: block;"></i>
                        <p>Solving ${problem} using Dynamic Programming...</p>
                        <div style="margin-top: 2rem; font-family: monospace;">
                            <div style="background: var(--gray-800); padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                                <p style="color: var(--gray-300);">Problem: ${problem}</p>
                                <p style="color: var(--success);">Status: Computing optimal solution...</p>
                            </div>
                            <p style="font-size: 0.9rem; color: var(--gray-400);">
                                [DP table and solution steps will be visualized here]
                            </p>
                        </div>
                    </div>
                `;
            }
        }

        function toggleMemoization() {
            const button = event.target;
            const isMemoized = button.textContent.includes('Disable');
            
            button.textContent = isMemoized ? 'Enable Memoization' : 'Disable Memoization';
            button.classList.toggle('btn-warning');
            
            // Update visualization based on memoization state
            const viz = document.getElementById('dp-viz');
            if (viz && !viz.innerHTML.includes('play-circle')) {
                const status = isMemoized ? 'Memoization disabled' : 'Memoization enabled';
                viz.querySelector('.section-content')?.insertAdjacentHTML('beforeend', 
                    `<p style="color: var(--warning); margin-top: 1rem;">${status}</p>`
                );
            }
        }

        // Complexity visualization
        function showComplexity(type) {
            const viz = document.getElementById('complexity-viz');
            if (viz) {
                viz.innerHTML = `
                    <div style="text-align: center; color: var(--primary);">
                        <i class="fas fa-chart-line" style="font-size: 2rem; margin-bottom: 1rem; display: block;"></i>
                        <p>Visualizing ${type} complexity...</p>
                        <div style="margin-top: 2rem;">
                            <canvas id="complexityChart" width="400" height="200" style="background: var(--gray-800); border-radius: 8px;"></canvas>
                            <p style="font-size: 0.9rem; color: var(--gray-400); margin-top: 1rem;">
                                [Interactive complexity graph will be rendered here]
                            </p>
                        </div>
                    </div>
                `;
                
                // Simulate chart drawing
                drawComplexityChart(type);
            }
        }

        function drawComplexityChart(type) {
            // Placeholder for chart drawing logic
            // In a real implementation, this would use Chart.js or similar library
            console.log(`Drawing ${type} complexity chart`);
        }

        // Quiz functions
        function setupQuizListeners() {
            // Quiz option selection will be handled by onclick attributes in HTML
        }

        function selectOption(selectedOptionElement) {
            const optionsContainer = selectedOptionElement.parentNode;
            const quizItemContainer = optionsContainer.parentNode;
            const allOptionsInQuestion = optionsContainer.querySelectorAll('.quiz-option');
            const feedbackElement = quizItemContainer.querySelector('.quiz-feedback');

            // Prevent re-answering if already answered (optional, based on desired UX)
            if (optionsContainer.classList.contains('answered')) {
                // You could provide a message like "Already answered" or just do nothing
                // feedbackElement.textContent = "You have already answered this question.";
                return;
            }

            const selectedOptionIndex = parseInt(selectedOptionElement.getAttribute('data-option-index'));
            const correctOptionIndex = parseInt(optionsContainer.getAttribute('data-correct-index'));

            // Clear previous selection states for this question's options
            allOptionsInQuestion.forEach(opt => {
                opt.classList.remove('selected', 'correct', 'incorrect');
            });

            // Mark the clicked option as selected
            selectedOptionElement.classList.add('selected');

            // Check if correct and apply styling
            if (selectedOptionIndex === correctOptionIndex) {
                selectedOptionElement.classList.add('correct');
                if (feedbackElement) feedbackElement.innerHTML = '<span style="color: var(--success); font-weight: bold;">Correct!</span>';
            } else {
                selectedOptionElement.classList.add('incorrect');
                if (feedbackElement) feedbackElement.innerHTML = `<span style="color: var(--error); font-weight: bold;">Incorrect.</span> The correct answer is highlighted.`;
                // Highlight the correct answer if the user was wrong
                allOptionsInQuestion.forEach(opt => {
                    if (parseInt(opt.getAttribute('data-option-index')) === correctOptionIndex) {
                        opt.classList.add('correct'); // Show the correct one
                    }
                });
            }

            // Mark this question as answered to prevent re-selection (optional)
            optionsContainer.classList.add('answered');
            allOptionsInQuestion.forEach(opt => opt.style.pointerEvents = 'none'); // Disable further clicks on options for this question
        }

        // Utility functions
        function copyCode(button) {
            const codeBlock = button.closest('.code-block').querySelector('code');
            const text = codeBlock.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.style.background = 'var(--success)';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = 'var(--primary)';
                }, 2000);
            });
        }

        function startLearning() {
            showTopic('data-types');
            const firstLink = document.querySelector('[data-topic="data-types"]');
            if (firstLink) {
                updateActiveLink(firstLink);
            }
        }

        function showProgress() {
            alert(`Current Progress: ${Math.round(appState.progress)}%\nCompleted Topics: ${appState.completedTopics.size}/24`);
        }

        function toggleMobileMenu() {
            // Mobile menu implementation
            const sidebar = document.querySelector('.sidebar');
            if (sidebar) {
                sidebar.style.display = sidebar.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Handle browser back/forward buttons
        window.addEventListener('popstate', function(e) {
            if (e.state && e.state.topic) {
                showTopic(e.state.topic);
            }
        });

        // Content management helper functions for easy content integration
        window.dsaContent = {
            // Function to add content to a topic
            addTopicContent: function(topicId, sectionName, content) {
                const topic = document.getElementById(topicId);
                if (topic) {
                    const section = topic.querySelector(`[data-section="${sectionName}"]`) ||
                                   topic.querySelector('.section-content');
                    if (section) {
                        section.innerHTML = content;
                    }
                }
            },
            
            // Function to add code examples
            addCodeExample: function(topicId, code, language = 'python') {
                const topic = document.getElementById(topicId);
                if (topic) {
                    const codeBlock = topic.querySelector('.code-block code');
                    if (codeBlock) {
                        codeBlock.textContent = code;
                        codeBlock.className = `language-${language}`;
                        if (window.Prism) {
                            Prism.highlightElement(codeBlock);
                        }
                    }
                }
            },
            
            // Function to update quiz questions
            updateQuiz: function(topicId, quizSet) {
                const topicElement = document.getElementById(topicId);
                if (!topicElement) {
                    console.error(`Topic element with ID '${topicId}' not found for quiz.`);
                    return;
                }

                const quizSection = topicElement.querySelector('.quiz-section');
                if (!quizSection) {
                    console.error(`Quiz section not found in topic '${topicId}'.`);
                    return;
                }

                // Clear previous quiz content, keeping the "Knowledge Check" title if it exists
                const quizTitleElement = quizSection.querySelector('h3');
                quizSection.innerHTML = ''; // Clear everything
                if (quizTitleElement) {
                    quizSection.appendChild(quizTitleElement); // Add title back
                } else {
                    const newTitle = document.createElement('h3');
                    newTitle.textContent = 'Knowledge Check';
                    quizSection.appendChild(newTitle);
                }


                if (!quizSet || quizSet.length === 0) {
                    quizSection.innerHTML += '<p>No quiz questions available for this topic yet.</p>';
                    return;
                }

                quizSet.forEach((quizItem, questionIndex) => {
                    const quizItemContainer = document.createElement('div');
                    quizItemContainer.className = 'quiz-item';
                    quizItemContainer.setAttribute('data-question-id', questionIndex);

                    const questionElement = document.createElement('div');
                    questionElement.className = 'quiz-question';
                    questionElement.innerHTML = quizItem.questionText; // Use innerHTML to allow for <code> etc.
                    quizItemContainer.appendChild(questionElement);

                    const optionsElement = document.createElement('div');
                    optionsElement.className = 'quiz-options';
                    // Store the correct index on the options container for easy access
                    optionsElement.setAttribute('data-correct-index', quizItem.correctOptionIndex);

                    quizItem.options.forEach((optionText, optionIndex) => {
                        const optionDiv = document.createElement('div');
                        optionDiv.className = 'quiz-option';
                        optionDiv.innerHTML = optionText; // Use innerHTML
                        optionDiv.setAttribute('data-option-index', optionIndex);
                        optionDiv.onclick = function() { selectOption(this); };
                        optionsElement.appendChild(optionDiv);
                    });

                    quizItemContainer.appendChild(optionsElement);

                    const feedbackElement = document.createElement('div');
                    feedbackElement.className = 'quiz-feedback';
                    feedbackElement.id = `quiz-feedback-${topicId}-${questionIndex}`;
                    quizItemContainer.appendChild(feedbackElement);

                    quizSection.appendChild(quizItemContainer);
                });
            }
        };
    </script>
</body>
</html>